<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Hypothesis Tests · MacroEconometricModels.jl</title><meta name="title" content="Hypothesis Tests · MacroEconometricModels.jl"/><meta property="og:title" content="Hypothesis Tests · MacroEconometricModels.jl"/><meta property="twitter:title" content="Hypothesis Tests · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://FriedmanJP.github.io/MacroEconometricModels.jl/hypothesis_tests/"/><meta property="twitter:url" content="https://FriedmanJP.github.io/MacroEconometricModels.jl/hypothesis_tests/"/><link rel="canonical" href="https://FriedmanJP.github.io/MacroEconometricModels.jl/hypothesis_tests/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/theme-toggle.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../data/">Data Management</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../filters/">Time Series Filters</a></li><li><a class="tocitem" href="../arima/">ARIMA</a></li><li><a class="tocitem" href="../volatility/">Volatility Models</a></li></ul></li><li><span class="tocitem">Multivariate Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li><li><a class="tocitem" href="../vecm/">VECM</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Panel Models</span><ul><li><a class="tocitem" href="../pvar/">Panel VAR</a></li></ul></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><a class="tocitem" href="../nowcast/">Nowcasting</a></li><li><a class="tocitem" href="../nongaussian/">Statistical Identification</a></li><li class="is-active"><a class="tocitem" href>Hypothesis Tests</a><ul class="internal"><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Unit-Root-Tests"><span>Unit Root Tests</span></a></li><li><a class="tocitem" href="#Cointegration-Tests"><span>Cointegration Tests</span></a></li><li><a class="tocitem" href="#VAR"><span>VAR</span></a></li><li><a class="tocitem" href="#Panel-VAR"><span>Panel VAR</span></a></li><li><a class="tocitem" href="#Model-Comparison-Tests"><span>Model Comparison Tests</span></a></li><li><a class="tocitem" href="#Reference"><span>Reference</span></a></li></ul></li><li><a class="tocitem" href="../plotting/">Visualization</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li><a class="tocitem" href="../api_functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Hypothesis Tests</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Hypothesis Tests</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FriedmanJP/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/main/docs/src/hypothesis_tests.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Hypothesis-Tests"><a class="docs-heading-anchor" href="#Hypothesis-Tests">Hypothesis Tests</a><a id="Hypothesis-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Hypothesis-Tests" title="Permalink"></a></h1><p>This chapter covers statistical hypothesis tests for time series analysis: unit root tests for stationarity detection, cointegration tests for multivariate equilibrium relationships, model-specific specification tests, and generic model comparison tests.</p><p>Before fitting dynamic models like VARs or Local Projections, it is essential to understand the stationarity properties of the data. Non-stationary series (those with unit roots) require different treatment than stationary series, as standard regression methods can lead to spurious results. After estimation, specification tests help validate the model and explore causal relationships.</p><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MacroEconometricModels

# --- Pre-estimation: Unit root &amp; stationarity ---
fred = load_example(:fred_md)
cpi = to_vector(fred[:, &quot;CPIAUCSL&quot;])
cpi_clean = filter(isfinite, cpi)                         # CPI price level (I(1))
adf_result = adf_test(cpi_clean; lags=:aic, regression=:constant)
kpss_result = kpss_test(cpi_clean; regression=:constant)
pp_result = pp_test(cpi_clean; regression=:constant)

# --- Pre-estimation: Cointegration ---
qd = load_example(:fred_qd)
Y_coint = log.(to_matrix(qd[:, [&quot;GDPC1&quot;, &quot;PCECC96&quot;]]))
Y_coint = Y_coint[all.(isfinite, eachrow(Y_coint)), :]
johansen_result = johansen_test(Y_coint, 2; deterministic=:constant)

# --- Post-estimation: VAR specification tests ---
Y = to_matrix(apply_tcode(fred[:, [&quot;INDPRO&quot;, &quot;CPIAUCSL&quot;, &quot;FEDFUNDS&quot;]]))
Y = Y[all.(isfinite, eachrow(Y)), :]
m = estimate_var(Y, 2)
is_stationary(m)                     # VAR stability check
granger_test(m, 3, 1)               # Does FFR Granger-cause INDPRO?
granger_test_all(m)                  # all-pairs causality matrix

# --- Post-estimation: Model comparison ---
m1 = estimate_var(Y, 1)
lr_test(m1, m)                       # likelihood ratio test</code></pre><h3 id="Test-Summary"><a class="docs-heading-anchor" href="#Test-Summary">Test Summary</a><a id="Test-Summary-1"></a><a class="docs-heading-anchor-permalink" href="#Test-Summary" title="Permalink"></a></h3><p><strong>Unit Root Tests</strong> (pre-estimation)</p><ol><li><strong>ADF (Augmented Dickey-Fuller)</strong>: Tests the null of a unit root against stationarity</li><li><strong>KPSS</strong>: Tests the null of stationarity against a unit root</li><li><strong>Phillips-Perron</strong>: Non-parametric unit root test with autocorrelation correction</li><li><strong>Zivot-Andrews</strong>: Unit root test allowing for endogenous structural break</li><li><strong>Ng-Perron</strong>: Modified tests with improved size properties</li></ol><p><strong>Cointegration Tests</strong> (pre-estimation)</p><ol><li><strong>Johansen Cointegration</strong>: Tests for cointegrating relationships among variables</li></ol><p><strong>VAR</strong> (post-estimation)</p><ol><li><strong>Stationarity Check</strong>: Eigenvalue stability of companion matrix</li><li><strong>Granger Causality</strong>: Pairwise and block Wald tests for predictive causality</li></ol><p><strong>Panel VAR</strong> (post-estimation)</p><ol><li><strong>Hansen J-Test</strong>: Overidentifying restrictions test for GMM instruments</li><li><strong>Andrews-Lu MMSC</strong>: Model and moment selection criteria</li><li><strong>Lag Selection</strong>: Optimal lag order via MMSC comparison</li></ol><p><strong>Model Comparison Tests</strong> (post-estimation, generic)</p><ol><li><strong>Likelihood Ratio (LR)</strong>: Compares nested models via log-likelihood difference</li><li><strong>Lagrange Multiplier (LM)</strong>: Score-based test requiring only the restricted model</li></ol><hr/><h2 id="Unit-Root-Tests"><a class="docs-heading-anchor" href="#Unit-Root-Tests">Unit Root Tests</a><a id="Unit-Root-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Root-Tests" title="Permalink"></a></h2><h3 id="Augmented-Dickey-Fuller-Test"><a class="docs-heading-anchor" href="#Augmented-Dickey-Fuller-Test">Augmented Dickey-Fuller Test</a><a id="Augmented-Dickey-Fuller-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Augmented-Dickey-Fuller-Test" title="Permalink"></a></h3><h4 id="Theory"><a class="docs-heading-anchor" href="#Theory">Theory</a><a id="Theory-1"></a><a class="docs-heading-anchor-permalink" href="#Theory" title="Permalink"></a></h4><p>The Augmented Dickey-Fuller (ADF) test examines whether a time series has a unit root. Consider the autoregressive model:</p><p class="math-container">\[y_t = \rho y_{t-1} + u_t\]</p><p>The null hypothesis is <span>$H_0: \rho = 1$</span> (unit root) against <span>$H_1: \rho &lt; 1$</span> (stationary).</p><p>The test is performed via the regression:</p><p class="math-container">\[\Delta y_t = \alpha + \beta t + \gamma y_{t-1} + \sum_{j=1}^{p} \delta_j \Delta y_{t-j} + \varepsilon_t\]</p><p>where:</p><ul><li><span>$\gamma = \rho - 1$</span> is the coefficient of interest</li><li><span>$\alpha$</span> is an optional constant</li><li><span>$\beta t$</span> is an optional linear trend</li><li>Lagged differences are included to control for serial correlation</li></ul><p>The ADF statistic is the t-ratio <span>$\tau = \hat{\gamma} / \text{se}(\hat{\gamma})$</span>.</p><p><strong>Critical values</strong> depend on the specification (none, constant, or trend) and are tabulated using MacKinnon (1994, 2010) response surfaces.</p><p><strong>Reference</strong>: Dickey &amp; Fuller (1979), MacKinnon (2010)</p><h4 id="Julia-Implementation"><a class="docs-heading-anchor" href="#Julia-Implementation">Julia Implementation</a><a id="Julia-Implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# CPI price level — expected to have a unit root
fred = load_example(:fred_md)
cpi = filter(isfinite, to_vector(fred[:, &quot;CPIAUCSL&quot;]))

# ADF test with automatic lag selection via AIC
result = adf_test(cpi; lags=:aic, regression=:constant)

# The result displays with publication-quality formatting:
# - Test statistic and significance stars
# - Critical values at 1%, 5%, 10% levels
# - Automatic conclusion (expect: fail to reject unit root)</code></pre><h4 id="Function-Signature"><a class="docs-heading-anchor" href="#Function-Signature">Function Signature</a><a id="Function-Signature-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Signature" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="MacroEconometricModels.adf_test"><a class="docstring-binding" href="#MacroEconometricModels.adf_test"><code>MacroEconometricModels.adf_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">adf_test(y; lags=:aic, max_lags=nothing, regression=:constant) -&gt; ADFResult</code></pre><p>Augmented Dickey-Fuller test for unit root.</p><p>Tests H₀: y has a unit root (non-stationary) against H₁: y is stationary.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>lags</code>: Number of augmenting lags, or :aic/:bic/:hqic for automatic selection</li><li><code>max_lags</code>: Maximum lags for automatic selection (default: floor(12*(T/100)^0.25))</li><li><code>regression</code>: Deterministic terms - :none, :constant (default), or :trend</li></ul><p><strong>Returns</strong></p><p><code>ADFResult</code> containing test statistic, p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk (has unit root)
result = adf_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀</code></pre><p><strong>References</strong></p><ul><li>Dickey, D. A., &amp; Fuller, W. A. (1979). Distribution of the estimators for autoregressive time series with a unit root. JASA, 74(366), 427-431.</li><li>MacKinnon, J. G. (2010). Critical values for cointegration tests. Queen&#39;s Economics Department Working Paper No. 1227.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/adf.jl#L23-L51">source</a></section></details></article><h4 id="Options"><a class="docs-heading-anchor" href="#Options">Options</a><a id="Options-1"></a><a class="docs-heading-anchor-permalink" href="#Options" title="Permalink"></a></h4><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right">Number of augmenting lags, or <code>:aic</code>/<code>:bic</code>/<code>:hqic</code> for automatic selection</td><td style="text-align: right"><code>:aic</code></td></tr><tr><td style="text-align: right"><code>max_lags</code></td><td style="text-align: right">Maximum lags for automatic selection</td><td style="text-align: right"><code>floor(12*(T/100)^0.25)</code></td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right">Deterministic terms: <code>:none</code>, <code>:constant</code>, or <code>:trend</code></td><td style="text-align: right"><code>:constant</code></td></tr></table><h4 id="ADFResult-Return-Values"><a class="docs-heading-anchor" href="#ADFResult-Return-Values">ADFResult Return Values</a><a id="ADFResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ADFResult-Return-Values" title="Permalink"></a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">ADF test statistic (<span>$\tau$</span>-ratio)</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Asymptotic p-value (MacKinnon response surface)</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of augmenting lags used</td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Deterministic specification (<code>:none</code>, <code>:constant</code>, <code>:trend</code>)</td></tr><tr><td style="text-align: right"><code>critical_values</code></td><td style="text-align: right"><code>Dict{Int,T}</code></td><td style="text-align: right">Critical values at 1%, 5%, 10% significance levels</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations used</td></tr></table><h4 id="Interpreting-Results"><a class="docs-heading-anchor" href="#Interpreting-Results">Interpreting Results</a><a id="Interpreting-Results-1"></a><a class="docs-heading-anchor-permalink" href="#Interpreting-Results" title="Permalink"></a></h4><ul><li><strong>Reject H₀</strong> (p-value &lt; 0.05): Evidence against unit root; series appears stationary</li><li><strong>Fail to reject H₀</strong> (p-value &gt; 0.05): Cannot reject unit root; series may be non-stationary</li></ul><hr/><h3 id="KPSS-Stationarity-Test"><a class="docs-heading-anchor" href="#KPSS-Stationarity-Test">KPSS Stationarity Test</a><a id="KPSS-Stationarity-Test-1"></a><a class="docs-heading-anchor-permalink" href="#KPSS-Stationarity-Test" title="Permalink"></a></h3><h4 id="Theory-2"><a class="docs-heading-anchor" href="#Theory-2">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-2" title="Permalink"></a></h4><p>The KPSS test (Kwiatkowski, Phillips, Schmidt &amp; Shin, 1992) reverses the hypotheses of the ADF test:</p><ul><li><span>$H_0$</span>: Series is stationary (level or trend stationary)</li><li><span>$H_1$</span>: Series has a unit root</li></ul><p>This complementary approach is valuable because failure to reject in the ADF test does not confirm stationarity—it may simply reflect low power.</p><p>The test decomposes the series:</p><p class="math-container">\[y_t = \xi t + r_t + \varepsilon_t\]</p><p>where <span>$r_t = r_{t-1} + u_t$</span> is a random walk. Under <span>$H_0$</span>, the variance of <span>$u_t$</span> is zero.</p><p>The KPSS statistic is:</p><p class="math-container">\[\text{KPSS} = \frac{\sum_{t=1}^T S_t^2}{T^2 \hat{\sigma}^2_{LR}}\]</p><p>where <span>$S_t = \sum_{s=1}^t \hat{e}_s$</span> are partial sums of residuals and <span>$\hat{\sigma}^2_{LR}$</span> is the long-run variance estimated using a Bartlett kernel.</p><p><strong>Reference</strong>: Kwiatkowski et al. (1992)</p><h4 id="Julia-Implementation-2"><a class="docs-heading-anchor" href="#Julia-Implementation-2">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-2" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# CPI inflation rate (Δlog CPI) — expected stationary
fred = load_example(:fred_md)
cpi_growth = diff(log.(filter(isfinite, to_vector(fred[:, &quot;CPIAUCSL&quot;]))))
result = kpss_test(cpi_growth; regression=:constant)

# For trend stationarity
result_trend = kpss_test(cpi_growth; regression=:trend)</code></pre><h4 id="Function-Signature-2"><a class="docs-heading-anchor" href="#Function-Signature-2">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-2" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="MacroEconometricModels.kpss_test"><a class="docstring-binding" href="#MacroEconometricModels.kpss_test"><code>MacroEconometricModels.kpss_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">kpss_test(y; regression=:constant, bandwidth=:auto) -&gt; KPSSResult</code></pre><p>Kwiatkowski-Phillips-Schmidt-Shin test for stationarity.</p><p>Tests H₀: y is stationary against H₁: y has a unit root.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :constant (level stationarity) or :trend (trend stationarity)</li><li><code>bandwidth</code>: Bartlett kernel bandwidth, or :auto for Newey-West selection</li></ul><p><strong>Returns</strong></p><p><code>KPSSResult</code> containing test statistic, p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)  # Stationary series
result = kpss_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀ (stationarity)</code></pre><p><strong>References</strong></p><ul><li>Kwiatkowski, D., Phillips, P. C., Schmidt, P., &amp; Shin, Y. (1992). Testing the null hypothesis of stationarity against the alternative of a unit root. Journal of Econometrics, 54(1-3), 159-178.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/kpss.jl#L25-L51">source</a></section></details></article><h4 id="Options-2"><a class="docs-heading-anchor" href="#Options-2">Options</a><a class="docs-heading-anchor-permalink" href="#Options-2" title="Permalink"></a></h4><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right">Stationarity type: <code>:constant</code> (level) or <code>:trend</code></td><td style="text-align: right"><code>:constant</code></td></tr><tr><td style="text-align: right"><code>bandwidth</code></td><td style="text-align: right">Bartlett kernel bandwidth, or <code>:auto</code> for Newey-West selection</td><td style="text-align: right"><code>:auto</code></td></tr></table><h4 id="KPSSResult-Return-Values"><a class="docs-heading-anchor" href="#KPSSResult-Return-Values">KPSSResult Return Values</a><a id="KPSSResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#KPSSResult-Return-Values" title="Permalink"></a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">KPSS test statistic</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Asymptotic p-value</td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Stationarity type (<code>:constant</code> or <code>:trend</code>)</td></tr><tr><td style="text-align: right"><code>critical_values</code></td><td style="text-align: right"><code>Dict{Int,T}</code></td><td style="text-align: right">Critical values at 1%, 5%, 10%</td></tr><tr><td style="text-align: right"><code>bandwidth</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Bartlett kernel bandwidth used</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr></table><h4 id="Interpreting-Results-2"><a class="docs-heading-anchor" href="#Interpreting-Results-2">Interpreting Results</a><a class="docs-heading-anchor-permalink" href="#Interpreting-Results-2" title="Permalink"></a></h4><ul><li><strong>Reject H₀</strong> (p-value &lt; 0.05): Evidence against stationarity; series has a unit root</li><li><strong>Fail to reject H₀</strong> (p-value &gt; 0.05): Cannot reject stationarity</li></ul><h4 id="Combining-ADF-and-KPSS"><a class="docs-heading-anchor" href="#Combining-ADF-and-KPSS">Combining ADF and KPSS</a><a id="Combining-ADF-and-KPSS-1"></a><a class="docs-heading-anchor-permalink" href="#Combining-ADF-and-KPSS" title="Permalink"></a></h4><p>Using both tests together provides stronger inference:</p><table><tr><th style="text-align: right">ADF Result</th><th style="text-align: right">KPSS Result</th><th style="text-align: right">Conclusion</th></tr><tr><td style="text-align: right">Reject H₀ (stationary)</td><td style="text-align: right">Fail to reject H₀ (stationary)</td><td style="text-align: right"><strong>Stationary</strong></td></tr><tr><td style="text-align: right">Fail to reject H₀ (unit root)</td><td style="text-align: right">Reject H₀ (unit root)</td><td style="text-align: right"><strong>Unit root</strong></td></tr><tr><td style="text-align: right">Reject H₀</td><td style="text-align: right">Reject H₀</td><td style="text-align: right">Conflicting (possible structural break)</td></tr><tr><td style="text-align: right">Fail to reject H₀</td><td style="text-align: right">Fail to reject H₀</td><td style="text-align: right">Inconclusive</td></tr></table><hr/><h3 id="Phillips-Perron-Test"><a class="docs-heading-anchor" href="#Phillips-Perron-Test">Phillips-Perron Test</a><a id="Phillips-Perron-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Phillips-Perron-Test" title="Permalink"></a></h3><h4 id="Theory-3"><a class="docs-heading-anchor" href="#Theory-3">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-3" title="Permalink"></a></h4><p>The Phillips-Perron (PP) test is a non-parametric alternative to the ADF test. Instead of augmenting with lagged differences, the PP test corrects the t-statistic for serial correlation using Newey-West standard errors.</p><p>The regression is:</p><p class="math-container">\[y_t = \alpha + \rho y_{t-1} + u_t\]</p><p>The PP <span>$Z_t$</span> statistic adjusts the OLS t-ratio:</p><p class="math-container">\[Z_t = \sqrt{\frac{\hat{\gamma}_0}{\hat{\lambda}^2}} t_\rho - \frac{\hat{\lambda}^2 - \hat{\gamma}_0}{2\hat{\lambda} \cdot \text{se}(\hat{\rho}) \cdot \sqrt{T}}\]</p><p>where <span>$\hat{\gamma}_0$</span> is the short-run variance and <span>$\hat{\lambda}^2$</span> is the long-run variance.</p><p><strong>Advantage</strong>: Does not require specifying the number of lags.</p><p><strong>Reference</strong>: Phillips &amp; Perron (1988)</p><h4 id="Julia-Implementation-3"><a class="docs-heading-anchor" href="#Julia-Implementation-3">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-3" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# CPI price level — non-parametric unit root test
fred = load_example(:fred_md)
cpi = filter(isfinite, to_vector(fred[:, &quot;CPIAUCSL&quot;]))
result = pp_test(cpi; regression=:constant)</code></pre><h4 id="Function-Signature-3"><a class="docs-heading-anchor" href="#Function-Signature-3">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-3" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pp_test"><a class="docstring-binding" href="#MacroEconometricModels.pp_test"><code>MacroEconometricModels.pp_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pp_test(y; regression=:constant, bandwidth=:auto) -&gt; PPResult</code></pre><p>Phillips-Perron test for unit root with non-parametric correction.</p><p>Tests H₀: y has a unit root against H₁: y is stationary.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :none, :constant (default), or :trend</li><li><code>bandwidth</code>: Newey-West bandwidth, or :auto for automatic selection</li></ul><p><strong>Returns</strong></p><p><code>PPResult</code> containing test statistic (Zt), p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk
result = pp_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀</code></pre><p><strong>References</strong></p><ul><li>Phillips, P. C., &amp; Perron, P. (1988). Testing for a unit root in time series regression. Biometrika, 75(2), 335-346.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/pp.jl#L25-L50">source</a></section></details></article><h4 id="Options-3"><a class="docs-heading-anchor" href="#Options-3">Options</a><a class="docs-heading-anchor-permalink" href="#Options-3" title="Permalink"></a></h4><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right">Deterministic terms: <code>:none</code>, <code>:constant</code>, or <code>:trend</code></td><td style="text-align: right"><code>:constant</code></td></tr><tr><td style="text-align: right"><code>bandwidth</code></td><td style="text-align: right">Newey-West bandwidth, or <code>:auto</code></td><td style="text-align: right"><code>:auto</code></td></tr></table><h4 id="PPResult-Return-Values"><a class="docs-heading-anchor" href="#PPResult-Return-Values">PPResult Return Values</a><a id="PPResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#PPResult-Return-Values" title="Permalink"></a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Phillips-Perron <span>$Z_t$</span> test statistic</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Asymptotic p-value</td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Deterministic specification</td></tr><tr><td style="text-align: right"><code>critical_values</code></td><td style="text-align: right"><code>Dict{Int,T}</code></td><td style="text-align: right">Critical values at 1%, 5%, 10%</td></tr><tr><td style="text-align: right"><code>bandwidth</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Newey-West bandwidth used</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr></table><hr/><h3 id="Zivot-Andrews-Test"><a class="docs-heading-anchor" href="#Zivot-Andrews-Test">Zivot-Andrews Test</a><a id="Zivot-Andrews-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Zivot-Andrews-Test" title="Permalink"></a></h3><h4 id="Theory-4"><a class="docs-heading-anchor" href="#Theory-4">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-4" title="Permalink"></a></h4><p>The Zivot-Andrews test extends the ADF test by allowing for an <strong>endogenous structural break</strong> in the series. This is important because standard unit root tests have low power against stationary alternatives with structural breaks.</p><p>Three specifications are available:</p><ol><li><strong>Break in intercept</strong> (<code>:constant</code>):</li></ol><p class="math-container">\[\Delta y_t = \alpha + \beta t + \theta DU_t + \gamma y_{t-1} + \sum_j \delta_j \Delta y_{t-j} + \varepsilon_t\]</p><ol><li><strong>Break in trend</strong> (<code>:trend</code>):</li></ol><p class="math-container">\[\Delta y_t = \alpha + \beta t + \phi DT_t + \gamma y_{t-1} + \sum_j \delta_j \Delta y_{t-j} + \varepsilon_t\]</p><ol><li><strong>Break in both</strong> (<code>:both</code>):</li></ol><p class="math-container">\[\Delta y_t = \alpha + \beta t + \theta DU_t + \phi DT_t + \gamma y_{t-1} + \sum_j \delta_j \Delta y_{t-j} + \varepsilon_t\]</p><p>where:</p><ul><li><span>$DU_t = 1$</span> if <span>$t &gt; T_B$</span> (level shift dummy)</li><li><span>$DT_t = t - T_B$</span> if <span>$t &gt; T_B$</span> (trend shift dummy)</li><li><span>$T_B$</span> is the break point, selected to minimize the t-statistic on <span>$\gamma$</span></li></ul><p><strong>Reference</strong>: Zivot &amp; Andrews (1992)</p><h4 id="Julia-Implementation-4"><a class="docs-heading-anchor" href="#Julia-Implementation-4">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-4" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# CPI price level — test for unit root allowing a structural break
fred = load_example(:fred_md)
cpi = filter(isfinite, to_vector(fred[:, &quot;CPIAUCSL&quot;]))
result = za_test(cpi; regression=:constant)

# Access break point
println(&quot;Break detected at observation: &quot;, result.break_index)
println(&quot;Break location: &quot;, result.break_fraction * 100, &quot;% of sample&quot;)</code></pre><h4 id="Function-Signature-4"><a class="docs-heading-anchor" href="#Function-Signature-4">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-4" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="MacroEconometricModels.za_test"><a class="docstring-binding" href="#MacroEconometricModels.za_test"><code>MacroEconometricModels.za_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">za_test(y; regression=:both, trim=0.15, lags=:aic, max_lags=nothing) -&gt; ZAResult</code></pre><p>Zivot-Andrews test for unit root with endogenous structural break.</p><p>Tests H₀: y has a unit root without break against H₁: y is stationary with break.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: Type of break - :constant (intercept), :trend (slope), or :both</li><li><code>trim</code>: Trimming fraction for break search (default 0.15)</li><li><code>lags</code>: Number of augmenting lags, or :aic/:bic for automatic selection</li><li><code>max_lags</code>: Maximum lags for selection</li></ul><p><strong>Returns</strong></p><p><code>ZAResult</code> containing minimum t-statistic, break point, p-value, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Series with structural break
y = vcat(randn(100), randn(100) .+ 2)
result = za_test(y; regression=:constant)</code></pre><p><strong>References</strong></p><ul><li>Zivot, E., &amp; Andrews, D. W. K. (1992). Further evidence on the great crash, the oil-price shock, and the unit-root hypothesis. JBES, 10(3), 251-270.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/za.jl#L25-L52">source</a></section></details></article><h4 id="Options-4"><a class="docs-heading-anchor" href="#Options-4">Options</a><a class="docs-heading-anchor-permalink" href="#Options-4" title="Permalink"></a></h4><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right">Break type: <code>:constant</code>, <code>:trend</code>, or <code>:both</code></td><td style="text-align: right"><code>:both</code></td></tr><tr><td style="text-align: right"><code>trim</code></td><td style="text-align: right">Trimming fraction for break search</td><td style="text-align: right"><code>0.15</code></td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right">Augmenting lags, or <code>:aic</code>/<code>:bic</code></td><td style="text-align: right"><code>:aic</code></td></tr></table><h4 id="ZAResult-Return-Values"><a class="docs-heading-anchor" href="#ZAResult-Return-Values">ZAResult Return Values</a><a id="ZAResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#ZAResult-Return-Values" title="Permalink"></a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Minimum ADF t-statistic over break candidates</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Asymptotic p-value</td></tr><tr><td style="text-align: right"><code>break_index</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Estimated break point (observation index)</td></tr><tr><td style="text-align: right"><code>break_fraction</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Break location as fraction of sample (0 to 1)</td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Break type (<code>:constant</code>, <code>:trend</code>, <code>:both</code>)</td></tr><tr><td style="text-align: right"><code>critical_values</code></td><td style="text-align: right"><code>Dict{Int,T}</code></td><td style="text-align: right">Critical values at 1%, 5%, 10%</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of augmenting lags</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr></table><hr/><h3 id="Ng-Perron-Tests"><a class="docs-heading-anchor" href="#Ng-Perron-Tests">Ng-Perron Tests</a><a id="Ng-Perron-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Ng-Perron-Tests" title="Permalink"></a></h3><h4 id="Theory-5"><a class="docs-heading-anchor" href="#Theory-5">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-5" title="Permalink"></a></h4><p>The Ng-Perron tests (2001) are modified unit root tests with improved size and power properties, especially in small samples. They use GLS detrending and report four test statistics:</p><ol><li><strong>MZα</strong>: Modified Phillips Zα statistic</li><li><strong>MZt</strong>: Modified Phillips Zt statistic (most commonly used)</li><li><strong>MSB</strong>: Modified Sargan-Bhargava statistic</li><li><strong>MPT</strong>: Modified Point-optimal statistic</li></ol><p>The GLS detrending uses the quasi-difference:</p><p class="math-container">\[\tilde{y}_t = y_t - \bar{c}/T \cdot y_{t-1}\]</p><p>where <span>$\bar{c} = -7$</span> (constant) or <span>$\bar{c} = -13.5$</span> (trend).</p><p><strong>Advantage</strong>: Better size properties than ADF when the initial condition is far from zero.</p><p><strong>Reference</strong>: Ng &amp; Perron (2001)</p><h4 id="Julia-Implementation-5"><a class="docs-heading-anchor" href="#Julia-Implementation-5">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-5" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# CPI price level — GLS-detrended unit root tests
fred = load_example(:fred_md)
cpi = filter(isfinite, to_vector(fred[:, &quot;CPIAUCSL&quot;]))
result = ngperron_test(cpi; regression=:constant)

# All four statistics are reported
println(&quot;MZα: &quot;, result.MZa)
println(&quot;MZt: &quot;, result.MZt)
println(&quot;MSB: &quot;, result.MSB)
println(&quot;MPT: &quot;, result.MPT)</code></pre><h4 id="Function-Signature-5"><a class="docs-heading-anchor" href="#Function-Signature-5">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-5" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ngperron_test"><a class="docstring-binding" href="#MacroEconometricModels.ngperron_test"><code>MacroEconometricModels.ngperron_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ngperron_test(y; regression=:constant) -&gt; NgPerronResult</code></pre><p>Ng-Perron unit root tests with GLS detrending (MZα, MZt, MSB, MPT).</p><p>Tests H₀: y has a unit root against H₁: y is stationary. These tests have better size properties than ADF/PP in small samples.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :constant (default) or :trend</li></ul><p><strong>Returns</strong></p><p><code>NgPerronResult</code> containing MZα, MZt, MSB, MPT statistics and critical values.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(100))
result = ngperron_test(y)
# Check if MZt rejects at 5%
result.MZt &lt; result.critical_values[:MZt][5]</code></pre><p><strong>References</strong></p><ul><li>Ng, S., &amp; Perron, P. (2001). Lag length selection and the construction of unit root tests with good size and power. Econometrica, 69(6), 1519-1554.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/ngperron.jl#L25-L51">source</a></section></details></article><h4 id="NgPerronResult-Return-Values"><a class="docs-heading-anchor" href="#NgPerronResult-Return-Values">NgPerronResult Return Values</a><a id="NgPerronResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#NgPerronResult-Return-Values" title="Permalink"></a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>MZa</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Modified Phillips <span>$Z_\alpha$</span> statistic</td></tr><tr><td style="text-align: right"><code>MZt</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Modified Phillips <span>$Z_t$</span> statistic (most commonly reported)</td></tr><tr><td style="text-align: right"><code>MSB</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Modified Sargan-Bhargava statistic</td></tr><tr><td style="text-align: right"><code>MPT</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Modified Point-optimal statistic</td></tr><tr><td style="text-align: right"><code>regression</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Deterministic specification</td></tr><tr><td style="text-align: right"><code>critical_values</code></td><td style="text-align: right"><code>Dict{Symbol,Dict{Int,T}}</code></td><td style="text-align: right">Critical values keyed by statistic name (<code>:MZa</code>, <code>:MZt</code>, <code>:MSB</code>, <code>:MPT</code>)</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr></table><div class="admonition is-info" id="Technical-Note-c61c7b648d3e0b14"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-c61c7b648d3e0b14" title="Permalink"></a></header><div class="admonition-body"><p>The Ng-Perron tests use GLS detrending which provides substantially better size properties than the standard ADF test in small samples (<span>$T &lt; 100$</span>). When the ADF test has borderline results, the Ng-Perron MZt statistic is a more reliable indicator. However, ADF remains preferable when the data-generating process has a large negative MA root, as GLS-based tests can be oversized in that case (Perron &amp; Ng, 1996).</p></div></div><div class="admonition is-info" id="Implementation-Detail-f41f6b7cb30dfa85"><header class="admonition-header">Implementation Detail<a class="admonition-anchor" href="#Implementation-Detail-f41f6b7cb30dfa85" title="Permalink"></a></header><div class="admonition-body"><p>The autoregressive spectral density estimator <span>$s^2_{AR}$</span> is computed by fitting an AR model to the <em>differenced</em> GLS-detrended series <span>$\Delta \tilde{y}_t$</span>, following Ng &amp; Perron (2001, equation 11). This ensures the spectral density estimate is consistent under the unit root null.</p></div></div><hr/><h3 id="Convenience-Functions"><a class="docs-heading-anchor" href="#Convenience-Functions">Convenience Functions</a><a id="Convenience-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Convenience-Functions" title="Permalink"></a></h3><h4 id="Summary-of-Multiple-Tests"><a class="docs-heading-anchor" href="#Summary-of-Multiple-Tests">Summary of Multiple Tests</a><a id="Summary-of-Multiple-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-of-Multiple-Tests" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# CPI price level — comprehensive unit root summary
fred = load_example(:fred_md)
cpi = filter(isfinite, to_vector(fred[:, &quot;CPIAUCSL&quot;]))

# Run multiple tests and get summary
summary = unit_root_summary(cpi; tests=[:adf, :kpss, :pp])

# Access individual results
summary.results[:adf]
summary.results[:kpss]

# Overall conclusion
println(summary.conclusion)</code></pre><h4 id="Test-All-Variables"><a class="docs-heading-anchor" href="#Test-All-Variables">Test All Variables</a><a id="Test-All-Variables-1"></a><a class="docs-heading-anchor-permalink" href="#Test-All-Variables" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# Test all FRED-MD variables in a subset for unit roots
fred = load_example(:fred_md)
vars = fred[:, [&quot;INDPRO&quot;, &quot;CPIAUCSL&quot;, &quot;FEDFUNDS&quot;, &quot;UNRATE&quot;, &quot;M2SL&quot;]]
Y = to_matrix(vars)
Y = Y[all.(isfinite, eachrow(Y)), :]

# Apply ADF test to all columns
results = test_all_variables(Y; test=:adf)

# Check which variables have unit roots
varnames = [&quot;INDPRO&quot;, &quot;CPIAUCSL&quot;, &quot;FEDFUNDS&quot;, &quot;UNRATE&quot;, &quot;M2SL&quot;]
for (i, r) in enumerate(results)
    status = r.pvalue &gt; 0.05 ? &quot;I(1)&quot; : &quot;I(0)&quot;
    println(&quot;$(varnames[i]): p=$(round(r.pvalue, digits=3)) → $status&quot;)
end</code></pre><h4 id="Function-Signatures"><a class="docs-heading-anchor" href="#Function-Signatures">Function Signatures</a><a id="Function-Signatures-1"></a><a class="docs-heading-anchor-permalink" href="#Function-Signatures" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="MacroEconometricModels.unit_root_summary"><a class="docstring-binding" href="#MacroEconometricModels.unit_root_summary"><code>MacroEconometricModels.unit_root_summary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">unit_root_summary(y; tests=[:adf, :kpss, :pp], kwargs...) -&gt; NamedTuple</code></pre><p>Run multiple unit root tests and return summary with PrettyTables output.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>tests</code>: Vector of test symbols to run (default: [:adf, :kpss, :pp])</li><li><code>kwargs...</code>: Additional arguments passed to individual tests</li></ul><p><strong>Returns</strong></p><p>NamedTuple with test results, conclusion, and summary table.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))
summary = unit_root_summary(y)
summary.conclusion  # Overall conclusion</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/convenience.jl#L25-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_all_variables"><a class="docstring-binding" href="#MacroEconometricModels.test_all_variables"><code>MacroEconometricModels.test_all_variables</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_all_variables(Y; test=:adf, kwargs...) -&gt; Vector</code></pre><p>Apply unit root test to each column of Y.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n)</li><li><code>test</code>: Test to apply (:adf, :kpss, :pp, :za, :ngperron)</li><li><code>kwargs...</code>: Additional arguments passed to the test</li></ul><p><strong>Returns</strong></p><p>Vector of test results, one per variable.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Y = randn(200, 3)
Y[:, 1] = cumsum(Y[:, 1])  # Make first column non-stationary
results = test_all_variables(Y; test=:adf)
[r.pvalue for r in results]  # P-values for each variable</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/convenience.jl#L88-L108">source</a></section></details></article><hr/><h2 id="Cointegration-Tests"><a class="docs-heading-anchor" href="#Cointegration-Tests">Cointegration Tests</a><a id="Cointegration-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Cointegration-Tests" title="Permalink"></a></h2><h3 id="Johansen-Cointegration-Test"><a class="docs-heading-anchor" href="#Johansen-Cointegration-Test">Johansen Cointegration Test</a><a id="Johansen-Cointegration-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Johansen-Cointegration-Test" title="Permalink"></a></h3><h4 id="Theory-6"><a class="docs-heading-anchor" href="#Theory-6">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-6" title="Permalink"></a></h4><p>The Johansen test examines whether multiple I(1) series share common stochastic trends, i.e., are <strong>cointegrated</strong>. Consider a VAR(p) in levels:</p><p class="math-container">\[y_t = A_1 y_{t-1} + \cdots + A_p y_{t-p} + u_t\]</p><p>This can be rewritten in Vector Error Correction Model (VECM) form:</p><p class="math-container">\[\Delta y_t = \Pi y_{t-1} + \sum_{i=1}^{p-1} \Gamma_i \Delta y_{t-i} + u_t\]</p><p>where <span>$\Pi = \alpha \beta&#39;$</span> is the long-run matrix:</p><ul><li><span>$\beta$</span>: Cointegrating vectors (equilibrium relationships)</li><li><span>$\alpha$</span>: Adjustment coefficients (speed of adjustment to equilibrium)</li><li><span>$\text{rank}(\Pi) = r$</span>: Number of cointegrating relationships</li></ul><p>Two test statistics are computed:</p><p><strong>Trace Test</strong>: Tests <span>$H_0: \text{rank} \leq r$</span> against <span>$H_1: \text{rank} &gt; r$</span></p><p class="math-container">\[\lambda_{trace}(r) = -T \sum_{i=r+1}^{n} \ln(1 - \hat{\lambda}_i)\]</p><p><strong>Maximum Eigenvalue Test</strong>: Tests <span>$H_0: \text{rank} = r$</span> against <span>$H_1: \text{rank} = r+1$</span></p><p class="math-container">\[\lambda_{max}(r) = -T \ln(1 - \hat{\lambda}_{r+1})\]</p><p><strong>Reference</strong>: Johansen (1991), Osterwald-Lenum (1992)</p><h4 id="Julia-Implementation-6"><a class="docs-heading-anchor" href="#Julia-Implementation-6">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-6" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# Test cointegration between log real GDP and log real consumption (FRED-QD)
qd = load_example(:fred_qd)
Y = log.(to_matrix(qd[:, [&quot;GDPC1&quot;, &quot;PCECC96&quot;]]))
Y = Y[all.(isfinite, eachrow(Y)), :]

# Johansen test with 2 lags in VECM
result = johansen_test(Y, 2; deterministic=:constant)

# Access results
println(&quot;Estimated cointegration rank: &quot;, result.rank)
println(&quot;Cointegrating vectors:\n&quot;, result.eigenvectors[:, 1:result.rank])
println(&quot;Adjustment coefficients:\n&quot;, result.adjustment)</code></pre><h4 id="Function-Signature-6"><a class="docs-heading-anchor" href="#Function-Signature-6">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-6" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="MacroEconometricModels.johansen_test"><a class="docstring-binding" href="#MacroEconometricModels.johansen_test"><code>MacroEconometricModels.johansen_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">johansen_test(Y, p; deterministic=:constant) -&gt; JohansenResult</code></pre><p>Johansen cointegration test for VAR system.</p><p>Tests for the number of cointegrating relationships among variables using trace and maximum eigenvalue tests.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n)</li><li><code>p</code>: Number of lags in the VECM representation</li><li><code>deterministic</code>: Specification for deterministic terms<ul><li>:none - No deterministic terms</li><li>:constant - Constant in cointegrating relation (default)</li><li>:trend - Linear trend in levels</li></ul></li></ul><p><strong>Returns</strong></p><p><code>JohansenResult</code> containing trace and max-eigenvalue statistics, cointegrating vectors, adjustment coefficients, and estimated rank.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Generate cointegrated system
n, T = 3, 200
Y = randn(T, n)
Y[:, 2] = Y[:, 1] + 0.1 * randn(T)  # Y2 cointegrated with Y1

result = johansen_test(Y, 2)
result.rank  # Should detect 1 or 2 cointegrating relations</code></pre><p><strong>References</strong></p><ul><li>Johansen, S. (1991). Estimation and hypothesis testing of cointegration vectors in Gaussian vector autoregressive models. Econometrica, 59(6), 1551-1580.</li><li>Osterwald-Lenum, M. (1992). A note with quantiles of the asymptotic distribution of the ML cointegration rank test statistics. Oxford BEJM.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/johansen.jl#L25-L61">source</a></section></details></article><h4 id="Options-5"><a class="docs-heading-anchor" href="#Options-5">Options</a><a class="docs-heading-anchor-permalink" href="#Options-5" title="Permalink"></a></h4><table><tr><th style="text-align: right">Argument</th><th style="text-align: right">Description</th><th style="text-align: right">Default</th></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right">Lags in VECM representation</td><td style="text-align: right">Required</td></tr><tr><td style="text-align: right"><code>deterministic</code></td><td style="text-align: right"><code>:none</code>, <code>:constant</code>, or <code>:trend</code></td><td style="text-align: right"><code>:constant</code></td></tr></table><div class="admonition is-info" id="Deterministic-Term-Placement-4f2f859f695f6328"><header class="admonition-header">Deterministic Term Placement<a class="admonition-anchor" href="#Deterministic-Term-Placement-4f2f859f695f6328" title="Permalink"></a></header><div class="admonition-body"><p>The <code>deterministic</code> keyword controls the placement of deterministic terms following Johansen&#39;s (1995) five cases. With <code>:constant</code> (Case 2), the intercept is restricted to the cointegrating space — it enters the error correction term <span>$\Pi y_{t-1}$</span> but not the short-run dynamics, preventing linear trends in levels. With <code>:trend</code> (Case 4), a linear trend is restricted to the cointegrating space, allowing quadratic trends in levels. Critical values are tabulated separately for each case.</p></div></div><h4 id="JohansenResult-Return-Values"><a class="docs-heading-anchor" href="#JohansenResult-Return-Values">JohansenResult Return Values</a><a id="JohansenResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#JohansenResult-Return-Values" title="Permalink"></a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>trace_stats</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Trace test statistics for each rank hypothesis</td></tr><tr><td style="text-align: right"><code>trace_pvalues</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">P-values for trace statistics</td></tr><tr><td style="text-align: right"><code>max_eigen_stats</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Maximum eigenvalue test statistics</td></tr><tr><td style="text-align: right"><code>max_eigen_pvalues</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">P-values for max eigenvalue statistics</td></tr><tr><td style="text-align: right"><code>rank</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Estimated cointegration rank</td></tr><tr><td style="text-align: right"><code>eigenvectors</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n$</span> matrix of cointegrating vectors (columns)</td></tr><tr><td style="text-align: right"><code>adjustment</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times n$</span> adjustment (loading) matrix <span>$\alpha$</span></td></tr><tr><td style="text-align: right"><code>eigenvalues</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Ordered eigenvalues from reduced-rank regression</td></tr><tr><td style="text-align: right"><code>critical_values_trace</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times 3$</span> critical values for trace test (1%, 5%, 10%)</td></tr><tr><td style="text-align: right"><code>critical_values_max</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$n \times 3$</span> critical values for max eigenvalue test</td></tr><tr><td style="text-align: right"><code>deterministic</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Deterministic specification (<code>:none</code>, <code>:constant</code>, <code>:trend</code>)</td></tr><tr><td style="text-align: right"><code>lags</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of VECM lags</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr></table><h4 id="Interpreting-Results-3"><a class="docs-heading-anchor" href="#Interpreting-Results-3">Interpreting Results</a><a class="docs-heading-anchor-permalink" href="#Interpreting-Results-3" title="Permalink"></a></h4><p>The test sequentially tests:</p><ol><li><span>$H_0: r = 0$</span> (no cointegration)</li><li><span>$H_0: r \leq 1$</span></li><li><span>$H_0: r \leq 2$</span>, etc.</li></ol><p>Stop at the first non-rejected hypothesis; that gives the cointegration rank.</p><hr/><h2 id="VAR"><a class="docs-heading-anchor" href="#VAR">VAR</a><a id="VAR-1"></a><a class="docs-heading-anchor-permalink" href="#VAR" title="Permalink"></a></h2><h3 id="Stationarity-Check"><a class="docs-heading-anchor" href="#Stationarity-Check">Stationarity Check</a><a id="Stationarity-Check-1"></a><a class="docs-heading-anchor-permalink" href="#Stationarity-Check" title="Permalink"></a></h3><h4 id="Theory-7"><a class="docs-heading-anchor" href="#Theory-7">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-7" title="Permalink"></a></h4><p>A VAR(p) model is <strong>stable</strong> (stationary) if and only if all eigenvalues of the companion matrix lie strictly inside the unit circle:</p><p class="math-container">\[F = \begin{bmatrix}
A_1 &amp; A_2 &amp; \cdots &amp; A_{p-1} &amp; A_p \\
I_n &amp; 0 &amp; \cdots &amp; 0 &amp; 0 \\
0 &amp; I_n &amp; \cdots &amp; 0 &amp; 0 \\
\vdots &amp; &amp; \ddots &amp; &amp; \vdots \\
0 &amp; 0 &amp; \cdots &amp; I_n &amp; 0
\end{bmatrix}\]</p><p><strong>Stability Condition</strong>: <span>$|\lambda_i| &lt; 1$</span> for all eigenvalues <span>$\lambda_i$</span> of <span>$F$</span>.</p><p>If violated, the VAR is explosive or contains unit roots, and standard asymptotic theory does not apply.</p><h4 id="Julia-Implementation-7"><a class="docs-heading-anchor" href="#Julia-Implementation-7">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-7" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# Estimate VAR on stationary-transformed FRED-MD data
fred = load_example(:fred_md)
Y = to_matrix(apply_tcode(fred[:, [&quot;INDPRO&quot;, &quot;CPIAUCSL&quot;, &quot;FEDFUNDS&quot;]]))
Y = Y[all.(isfinite, eachrow(Y)), :]
model = estimate_var(Y, 2)

# Check stationarity
result = is_stationary(model)

if result.is_stationary
    println(&quot;VAR is stationary&quot;)
    println(&quot;Maximum eigenvalue modulus: &quot;, result.max_modulus)
else
    println(&quot;WARNING: VAR is non-stationary!&quot;)
    println(&quot;Maximum eigenvalue modulus: &quot;, result.max_modulus)
    println(&quot;Consider differencing or VECM specification&quot;)
end</code></pre><h4 id="Function-Signature-7"><a class="docs-heading-anchor" href="#Function-Signature-7">Function Signature</a><a class="docs-heading-anchor-permalink" href="#Function-Signature-7" title="Permalink"></a></h4><article><details class="docstring" open="true"><summary id="MacroEconometricModels.is_stationary"><a class="docstring-binding" href="#MacroEconometricModels.is_stationary"><code>MacroEconometricModels.is_stationary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">is_stationary(model::VARModel) -&gt; VARStationarityResult</code></pre><p>Check if estimated VAR model is stationary.</p><p>A VAR(p) is stationary if and only if all eigenvalues of the companion matrix have modulus strictly less than 1.</p><p><strong>Returns</strong></p><p><code>VARStationarityResult</code> with:</p><ul><li><code>is_stationary</code>: Boolean indicating stationarity</li><li><code>eigenvalues</code>: Complex eigenvalues of companion matrix</li><li><code>max_modulus</code>: Maximum eigenvalue modulus</li><li><code>companion_matrix</code>: The (np × np) companion form matrix</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = estimate_var(Y, 2)
result = is_stationary(model)
if !result.is_stationary
    println(&quot;Warning: VAR is non-stationary, max modulus = &quot;, result.max_modulus)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/stationarity.jl#L25-L48">source</a></section><section><div><pre><code class="language-julia hljs">is_stationary(model::DynamicFactorModel) -&gt; Bool</code></pre><p>Check if factor dynamics are stationary (max |eigenvalue| &lt; 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L533-L537">source</a></section></details></article><h4 id="VARStationarityResult-Return-Values"><a class="docs-heading-anchor" href="#VARStationarityResult-Return-Values">VARStationarityResult Return Values</a><a id="VARStationarityResult-Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#VARStationarityResult-Return-Values" title="Permalink"></a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>is_stationary</code></td><td style="text-align: right"><code>Bool</code></td><td style="text-align: right"><code>true</code> if all eigenvalues lie inside unit circle</td></tr><tr><td style="text-align: right"><code>eigenvalues</code></td><td style="text-align: right"><code>Vector{E}</code></td><td style="text-align: right">Eigenvalues of the companion matrix (may be complex)</td></tr><tr><td style="text-align: right"><code>max_modulus</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Maximum eigenvalue modulus (should be <span>$&lt; 1$</span> for stability)</td></tr><tr><td style="text-align: right"><code>companion_matrix</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right"><span>$np \times np$</span> companion matrix</td></tr></table><hr/><h3 id="Granger-Causality-Tests"><a class="docs-heading-anchor" href="#Granger-Causality-Tests">Granger Causality Tests</a><a id="Granger-Causality-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Granger-Causality-Tests" title="Permalink"></a></h3><p>The Granger causality test (Granger 1969) examines whether lagged values of one variable help predict another variable in a VAR system.</p><h4 id="Theory-8"><a class="docs-heading-anchor" href="#Theory-8">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-8" title="Permalink"></a></h4><p>Given a VAR(p) model with n variables, the <strong>pairwise</strong> test examines whether variable j Granger-causes variable i:</p><p class="math-container">\[H_0: A_1[i,j] = A_2[i,j] = \cdots = A_p[i,j] = 0\]</p><p>Under <span>$H_0$</span>, the Wald statistic <span>$W = \boldsymbol{\theta}&#39;\mathbf{V}^{-1}\boldsymbol{\theta} \sim \chi^2(p)$</span>, where <span>$\boldsymbol{\theta}$</span> collects the lag coefficients and <span>$\mathbf{V} = \sigma_{ii} (\mathbf{X}&#39;\mathbf{X})^{-1}$</span> is the coefficient covariance.</p><p>The <strong>block</strong> (multivariate) test generalizes to groups of cause variables, with <span>$\text{df} = p \times |\text{cause group}|$</span>.</p><div class="admonition is-info" id="Technical-Note-9ff0f94309be6ce4"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-9ff0f94309be6ce4" title="Permalink"></a></header><div class="admonition-body"><p>Granger causality is a statistical concept based on predictability, not true causation. Variable j &quot;Granger-causes&quot; variable i if past values of j contain information useful for predicting i beyond what is contained in past values of i and other variables. The test is valid under the assumption that the VAR model is correctly specified and the error terms are white noise.</p></div></div><h4 id="Quick-Start-2"><a class="docs-heading-anchor" href="#Quick-Start-2">Quick Start</a><a class="docs-heading-anchor-permalink" href="#Quick-Start-2" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# FRED-MD monetary policy VAR: INDPRO, CPIAUCSL, FEDFUNDS
fred = load_example(:fred_md)
Y = to_matrix(apply_tcode(fred[:, [&quot;INDPRO&quot;, &quot;CPIAUCSL&quot;, &quot;FEDFUNDS&quot;]]))
Y = Y[all.(isfinite, eachrow(Y)), :]
m = estimate_var(Y, 2)

# Pairwise: does the federal funds rate Granger-cause industrial production?
g = granger_test(m, 3, 1)

# Block: do CPIAUCSL and FEDFUNDS jointly Granger-cause INDPRO?
g_block = granger_test(m, [2, 3], 1)

# All pairwise tests at once
results = granger_test_all(m)</code></pre><p><strong>Interpretation.</strong> If the p-value is below your significance level (e.g., 0.05), reject <span>$H_0$</span> and conclude the cause variable(s) Granger-cause the effect variable. The <code>granger_test_all</code> function returns an n×n matrix where entry [i,j] tests whether variable j Granger-causes variable i.</p><h4 id="Function-Signatures-2"><a class="docs-heading-anchor" href="#Function-Signatures-2">Function Signatures</a><a class="docs-heading-anchor-permalink" href="#Function-Signatures-2" title="Permalink"></a></h4><ul><li><a href="../api_functions/#MacroEconometricModels.granger_test"><code>granger_test(model, cause, effect)</code></a> — Pairwise or block Granger causality test</li><li><a href="../api_functions/#MacroEconometricModels.granger_test_all"><code>granger_test_all(model)</code></a> — All-pairs pairwise Granger causality matrix</li></ul><h4 id="Return-Values"><a class="docs-heading-anchor" href="#Return-Values">Return Values</a><a id="Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Values" title="Permalink"></a></h4><p><strong><code>GrangerCausalityResult</code></strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Wald χ² statistic</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">p-value from χ²(df)</td></tr><tr><td style="text-align: right"><code>df</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Degrees of freedom (p for pairwise, p×|cause| for block)</td></tr><tr><td style="text-align: right"><code>cause</code></td><td style="text-align: right"><code>Vector{Int}</code></td><td style="text-align: right">Indices of causing variable(s)</td></tr><tr><td style="text-align: right"><code>effect</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Index of effect variable</td></tr><tr><td style="text-align: right"><code>n</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of variables in VAR</td></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Lag order</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Effective number of observations</td></tr><tr><td style="text-align: right"><code>test_type</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right"><code>:pairwise</code> or <code>:block</code></td></tr></table><h4 id="Complete-Example"><a class="docs-heading-anchor" href="#Complete-Example">Complete Example</a><a id="Complete-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# FRED-MD monetary policy VAR: INDPRO (1), CPIAUCSL (2), FEDFUNDS (3)
fred = load_example(:fred_md)
Y = to_matrix(apply_tcode(fred[:, [&quot;INDPRO&quot;, &quot;CPIAUCSL&quot;, &quot;FEDFUNDS&quot;]]))
Y = Y[all.(isfinite, eachrow(Y)), :]
m = estimate_var(Y, 2)

# Test all pairs
results = granger_test_all(m)

# Does FFR Granger-cause industrial production?
println(&quot;FEDFUNDS → INDPRO:   p = &quot;, round(results[1, 3].pvalue, digits=4))

# Does industrial production Granger-cause CPI?
println(&quot;INDPRO → CPIAUCSL:   p = &quot;, round(results[2, 1].pvalue, digits=4))

# Does CPI Granger-cause the federal funds rate?
println(&quot;CPIAUCSL → FEDFUNDS: p = &quot;, round(results[3, 2].pvalue, digits=4))

# Block test: do INDPRO and CPIAUCSL jointly Granger-cause FEDFUNDS?
g_block = granger_test(m, [1, 2], 3)
println(&quot;Block [INDPRO,CPIAUCSL] → FEDFUNDS: p = &quot;, round(g_block.pvalue, digits=4))</code></pre><hr/><h2 id="Panel-VAR"><a class="docs-heading-anchor" href="#Panel-VAR">Panel VAR</a><a id="Panel-VAR-1"></a><a class="docs-heading-anchor-permalink" href="#Panel-VAR" title="Permalink"></a></h2><h3 id="Hansen-J-Test"><a class="docs-heading-anchor" href="#Hansen-J-Test">Hansen J-Test</a><a id="Hansen-J-Test-1"></a><a class="docs-heading-anchor-permalink" href="#Hansen-J-Test" title="Permalink"></a></h3><p>The Hansen (1982) J-test evaluates whether the overidentifying restrictions (moment conditions) in GMM estimation are valid.</p><h4 id="Theory-9"><a class="docs-heading-anchor" href="#Theory-9">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-9" title="Permalink"></a></h4><p class="math-container">\[J = N \bar{g}&#39; W_{opt} \bar{g} \sim \chi^2(q - k)\]</p><p>where <span>$\bar{g} = N^{-1} \sum_i Z_i&#39; e_i$</span> is the average moment condition, <span>$W_{opt}$</span> is the optimal weighting matrix, <span>$q$</span> is the number of instruments, and <span>$k$</span> is the number of parameters per equation.</p><ul><li><span>$H_0$</span>: All moment conditions are valid</li><li><span>$H_1$</span>: Some moment conditions are invalid</li></ul><h4 id="Julia-Implementation-8"><a class="docs-heading-anchor" href="#Julia-Implementation-8">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-8" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels, DataFrames, Random
Random.seed!(42)

# Set up panel data (see Panel VAR page for full example)
N, T_total, m = 50, 20, 3
data = zeros(N * T_total, m)
for i in 1:N
    mu = randn(m) * 0.5
    for t in 2:T_total
        idx = (i-1)*T_total + t
        data[idx, :] = mu + 0.5 * data[(i-1)*T_total + t - 1, :] + 0.2 * randn(m)
    end
end
df = DataFrame(data, [&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;])
df.id = repeat(1:N, inner=T_total)
df.time = repeat(1:T_total, outer=N)
pd = xtset(df, :id, :time)

model = estimate_pvar(pd, 2; steps=:twostep)

# Hansen J-test
j = pvar_hansen_j(model)
j.statistic     # J-statistic
j.pvalue        # p-value (χ² distribution)
j.df            # degrees of freedom = instruments - parameters</code></pre><p><strong>Interpretation.</strong> Failure to reject <span>$H_0$</span> (p-value &gt; 0.05) supports the validity of the instruments. Rejection suggests instrument invalidity or model misspecification.</p><div class="admonition is-warning" id="J-Test-and-Instrument-Count-70fdf11805d3a8a4"><header class="admonition-header">J-Test and Instrument Count<a class="admonition-anchor" href="#J-Test-and-Instrument-Count-70fdf11805d3a8a4" title="Permalink"></a></header><div class="admonition-body"><p>The J-test has low power when the number of instruments is large relative to <span>$N$</span>. A non-rejection does not necessarily validate the instruments.</p></div></div><h4 id="Return-Values-2"><a class="docs-heading-anchor" href="#Return-Values-2">Return Values</a><a class="docs-heading-anchor-permalink" href="#Return-Values-2" title="Permalink"></a></h4><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">J-statistic</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">p-value from χ²(df)</td></tr><tr><td style="text-align: right"><code>df</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Degrees of freedom (instruments − parameters)</td></tr><tr><td style="text-align: right"><code>n_instruments</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of moment conditions</td></tr><tr><td style="text-align: right"><code>n_params</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of estimated parameters</td></tr></table><hr/><h3 id="Andrews-Lu-MMSC"><a class="docs-heading-anchor" href="#Andrews-Lu-MMSC">Andrews-Lu MMSC</a><a id="Andrews-Lu-MMSC-1"></a><a class="docs-heading-anchor-permalink" href="#Andrews-Lu-MMSC" title="Permalink"></a></h3><p>Andrews-Lu (2001) Model and Moment Selection Criteria extend information criteria to GMM settings, enabling comparison of PVAR models with different lag orders or instrument sets.</p><h4 id="Theory-10"><a class="docs-heading-anchor" href="#Theory-10">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-10" title="Permalink"></a></h4><p class="math-container">\[\text{MMSC-BIC} = J - (c - b) \ln(n), \quad
\text{MMSC-AIC} = J - 2(c - b), \quad
\text{MMSC-HQIC} = J - Q(c - b) \ln(\ln(n))\]</p><p>where <span>$J$</span> is the Hansen J-statistic, <span>$c$</span> = number of instruments, <span>$b$</span> = number of parameters, and <span>$n$</span> = observations. Lower values are preferred.</p><h4 id="Julia-Implementation-9"><a class="docs-heading-anchor" href="#Julia-Implementation-9">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-9" title="Permalink"></a></h4><pre><code class="language-julia hljs">mmsc = pvar_mmsc(model)
mmsc.bic     # MMSC-BIC
mmsc.aic     # MMSC-AIC
mmsc.hqic    # MMSC-HQIC</code></pre><p>See <a href="../api_functions/#MacroEconometricModels.pvar_mmsc"><code>pvar_mmsc</code></a> in the <a href="../api/#API-Reference">API Reference</a>.</p><hr/><h3 id="Lag-Selection"><a class="docs-heading-anchor" href="#Lag-Selection">Lag Selection</a><a id="Lag-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Lag-Selection" title="Permalink"></a></h3><p>Select the optimal PVAR lag order by estimating models for <span>$p = 1, \ldots, p_{\max}$</span> and comparing Andrews-Lu MMSC criteria.</p><h4 id="Julia-Implementation-10"><a class="docs-heading-anchor" href="#Julia-Implementation-10">Julia Implementation</a><a class="docs-heading-anchor-permalink" href="#Julia-Implementation-10" title="Permalink"></a></h4><pre><code class="language-julia hljs">sel = pvar_lag_selection(pd, 4)
sel.best_bic    # optimal lag by BIC
sel.best_aic    # optimal lag by AIC
sel.best_hqic   # optimal lag by HQIC
sel.table       # comparison table (p × 4: lag, BIC, AIC, HQIC)</code></pre><p>See <a href="../api_functions/#MacroEconometricModels.pvar_lag_selection"><code>pvar_lag_selection</code></a> in the <a href="../api/#API-Reference">API Reference</a>.</p><hr/><h2 id="Model-Comparison-Tests"><a class="docs-heading-anchor" href="#Model-Comparison-Tests">Model Comparison Tests</a><a id="Model-Comparison-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Comparison-Tests" title="Permalink"></a></h2><p>The <strong>likelihood ratio (LR) test</strong> and <strong>Lagrange multiplier (LM) test</strong> form two legs of the classical &quot;trinity&quot; of specification tests (alongside the Wald test). Both test whether a restricted (simpler) model is adequate relative to an unrestricted (more general) model. These tests are generic and work across model families.</p><h3 id="Theory-11"><a class="docs-heading-anchor" href="#Theory-11">Theory</a><a class="docs-heading-anchor-permalink" href="#Theory-11" title="Permalink"></a></h3><p>Given nested models <span>$\mathcal{M}_R \subset \mathcal{M}_U$</span> with log-likelihoods <span>$\ell_R$</span> and <span>$\ell_U$</span>:</p><p><strong>LR test</strong> (Wilks 1938): Evaluate both models at their respective MLEs.</p><p class="math-container">\[\text{LR} = -2(\ell_R - \ell_U) \xrightarrow{d} \chi^2(\text{df})\]</p><p><strong>LM test</strong> (Rao 1948, Silvey 1959): Evaluate the score of the unrestricted model at the restricted estimates.</p><p class="math-container">\[\text{LM} = \mathbf{s}&#39;(-\mathbf{H})^{-1}\mathbf{s} \xrightarrow{d} \chi^2(\text{df})\]</p><p>where <span>$\text{df} = k_U - k_R$</span> is the difference in the number of parameters, <span>$\mathbf{s}$</span> is the score vector (gradient of the log-likelihood), and <span>$\mathbf{H}$</span> is the Hessian of the log-likelihood, all evaluated at the restricted estimates.</p><div class="admonition is-info" id="Technical-Note-83888cbc7de5b215"><header class="admonition-header">Technical Note<a class="admonition-anchor" href="#Technical-Note-83888cbc7de5b215" title="Permalink"></a></header><div class="admonition-body"><p>The LR test requires estimating both models, while the LM test only requires the restricted model (plus the unrestricted likelihood function). Under the null, LR, LM, and Wald statistics are asymptotically equivalent. In finite samples, the ordering <span>$\text{Wald} \geq \text{LR} \geq \text{LM}$</span> typically holds.</p></div></div><h3 id="Quick-Start-3"><a class="docs-heading-anchor" href="#Quick-Start-3">Quick Start</a><a class="docs-heading-anchor-permalink" href="#Quick-Start-3" title="Permalink"></a></h3><pre><code class="language-julia hljs">using MacroEconometricModels

# --- ARIMA: Is AR(2) adequate vs AR(4) for CPI inflation? ---
fred = load_example(:fred_md)
cpi_growth = diff(log.(filter(isfinite, to_vector(fred[:, &quot;CPIAUCSL&quot;]))))
ar2 = estimate_ar(cpi_growth, 2; method=:mle)
ar4 = estimate_ar(cpi_growth, 4; method=:mle)

lr_result = lr_test(ar2, ar4)   # generic: any model with loglikelihood
lm_result = lm_test(ar2, ar4)   # score-based: model-family specific

# --- VAR: VAR(1) vs VAR(2) for monetary policy model ---
Y = to_matrix(apply_tcode(fred[:, [&quot;INDPRO&quot;, &quot;CPIAUCSL&quot;, &quot;FEDFUNDS&quot;]]))
Y = Y[all.(isfinite, eachrow(Y)), :]
var1 = estimate_var(Y, 1)
var2 = estimate_var(Y, 2)
lr_test(var1, var2)

# --- Volatility: ARCH(1) vs GARCH(1,1) for INDPRO growth ---
indpro_growth = diff(log.(filter(isfinite, to_vector(fred[:, &quot;INDPRO&quot;]))))
arch1 = estimate_arch(indpro_growth, 1)
garch11 = estimate_garch(indpro_growth, 1, 1)
lr_test(arch1, garch11)     # LR works across ARCH/GARCH
lm_test(arch1, garch11)     # LM supports ARCH→GARCH nesting</code></pre><p><strong>Interpretation.</strong> If the p-value is below your significance level (e.g., 0.05), reject H₀ and conclude the unrestricted model provides a significantly better fit. If the p-value is large, the restricted model is adequate.</p><h3 id="Supported-Model-Families"><a class="docs-heading-anchor" href="#Supported-Model-Families">Supported Model Families</a><a id="Supported-Model-Families-1"></a><a class="docs-heading-anchor-permalink" href="#Supported-Model-Families" title="Permalink"></a></h3><table><tr><th style="text-align: right">Test</th><th style="text-align: right">Supported pairs</th><th style="text-align: right">Notes</th></tr><tr><td style="text-align: right"><code>lr_test</code></td><td style="text-align: right">Any pair with <code>loglikelihood</code>, <code>dof</code>, <code>nobs</code></td><td style="text-align: right">Generic — works for VAR, VECM, ARIMA, ARCH, GARCH, EGARCH, GJR-GARCH, DFM</td></tr><tr><td style="text-align: right"><code>lm_test</code></td><td style="text-align: right"><code>AbstractARIMAModel</code> × <code>AbstractARIMAModel</code></td><td style="text-align: right">Same differencing order <code>d</code> required</td></tr><tr><td style="text-align: right"><code>lm_test</code></td><td style="text-align: right"><code>VARModel</code> × <code>VARModel</code></td><td style="text-align: right">Different lag orders, same data</td></tr><tr><td style="text-align: right"><code>lm_test</code></td><td style="text-align: right"><code>ARCHModel</code> × <code>ARCHModel</code></td><td style="text-align: right">Different ARCH orders</td></tr><tr><td style="text-align: right"><code>lm_test</code></td><td style="text-align: right"><code>GARCHModel</code> × <code>GARCHModel</code></td><td style="text-align: right">Different <code>p</code> or <code>q</code></td></tr><tr><td style="text-align: right"><code>lm_test</code></td><td style="text-align: right"><code>ARCHModel</code> × <code>GARCHModel</code></td><td style="text-align: right">Cross-type nesting (ARCH ⊂ GARCH)</td></tr><tr><td style="text-align: right"><code>lm_test</code></td><td style="text-align: right"><code>EGARCHModel</code> × <code>EGARCHModel</code></td><td style="text-align: right">Different <code>p</code> or <code>q</code></td></tr><tr><td style="text-align: right"><code>lm_test</code></td><td style="text-align: right"><code>GJRGARCHModel</code> × <code>GJRGARCHModel</code></td><td style="text-align: right">Different <code>p</code> or <code>q</code></td></tr></table><h3 id="Function-Signatures-3"><a class="docs-heading-anchor" href="#Function-Signatures-3">Function Signatures</a><a class="docs-heading-anchor-permalink" href="#Function-Signatures-3" title="Permalink"></a></h3><ul><li><a href="../api_functions/#MacroEconometricModels.lr_test"><code>lr_test(m1, m2)</code></a> — Likelihood ratio test</li><li><a href="../api_functions/#MacroEconometricModels.lm_test"><code>lm_test(m1, m2)</code></a> — Lagrange multiplier (score) test</li></ul><h3 id="Return-Values-3"><a class="docs-heading-anchor" href="#Return-Values-3">Return Values</a><a class="docs-heading-anchor-permalink" href="#Return-Values-3" title="Permalink"></a></h3><p><strong><code>LRTestResult</code></strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">LR = −2(ℓ<em>R − ℓ</em>U)</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">p-value from χ²(df)</td></tr><tr><td style="text-align: right"><code>df</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Degrees of freedom</td></tr><tr><td style="text-align: right"><code>loglik_restricted</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood of restricted model</td></tr><tr><td style="text-align: right"><code>loglik_unrestricted</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood of unrestricted model</td></tr><tr><td style="text-align: right"><code>dof_restricted</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Parameters in restricted model</td></tr><tr><td style="text-align: right"><code>dof_unrestricted</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Parameters in unrestricted model</td></tr><tr><td style="text-align: right"><code>nobs_restricted</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Observations in restricted model</td></tr><tr><td style="text-align: right"><code>nobs_unrestricted</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Observations in unrestricted model</td></tr></table><p><strong><code>LMTestResult</code></strong></p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>statistic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">LM = s&#39;(−H)⁻¹s</td></tr><tr><td style="text-align: right"><code>pvalue</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">p-value from χ²(df)</td></tr><tr><td style="text-align: right"><code>df</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Degrees of freedom</td></tr><tr><td style="text-align: right"><code>nobs</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Number of observations</td></tr><tr><td style="text-align: right"><code>score_norm</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">‖s‖₂ diagnostic</td></tr></table><hr/><h3 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h3><ul><li><a href="../manual/">VAR Estimation</a> – Pre-estimation diagnostics and lag selection</li><li><a href="../vecm/">VECM Analysis</a> – Johansen cointegration testing in the VECM context</li><li><a href="../volatility/">Volatility Models</a> – ARCH-LM test applications for volatility modeling</li><li><a href="../api_functions/">API Reference</a> – Complete function signatures</li></ul><h2 id="Reference"><a class="docs-heading-anchor" href="#Reference">Reference</a><a id="Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Reference" title="Permalink"></a></h2><h3 id="Result-Types"><a class="docs-heading-anchor" href="#Result-Types">Result Types</a><a id="Result-Types-1"></a><a class="docs-heading-anchor-permalink" href="#Result-Types" title="Permalink"></a></h3><p>All test results implement the StatsAPI interface:</p><pre><code class="language-julia hljs">using StatsAPI

result = adf_test(y)

# StatsAPI interface
nobs(result)    # Number of observations
dof(result)     # Degrees of freedom
pvalue(result)  # P-value</code></pre><h4 id="Type-Hierarchy"><a class="docs-heading-anchor" href="#Type-Hierarchy">Type Hierarchy</a><a id="Type-Hierarchy-1"></a><a class="docs-heading-anchor-permalink" href="#Type-Hierarchy" title="Permalink"></a></h4><p>See the <a href="../api/#API-Reference">API Reference</a> for detailed type documentation.</p><p><strong>Unit Root Tests</strong> — inherit from <code>AbstractUnitRootTest &lt;: StatsAPI.HypothesisTest</code>:</p><ul><li><code>ADFResult</code> - Augmented Dickey-Fuller test result</li><li><code>KPSSResult</code> - KPSS stationarity test result</li><li><code>PPResult</code> - Phillips-Perron test result</li><li><code>ZAResult</code> - Zivot-Andrews structural break test result</li><li><code>NgPerronResult</code> - Ng-Perron test result (MZα, MZt, MSB, MPT)</li><li><code>JohansenResult</code> - Johansen cointegration test result</li><li><code>VARStationarityResult</code> - VAR model stationarity check result</li></ul><p><strong>Specification Tests</strong> — inherit from <code>StatsAPI.HypothesisTest</code>:</p><ul><li><code>GrangerCausalityResult</code> - Granger causality test result (pairwise or block)</li><li><code>PVARTestResult</code> - Panel VAR specification test result (Hansen J, etc.)</li><li><code>LRTestResult</code> - Likelihood ratio test result</li><li><code>LMTestResult</code> - Lagrange multiplier (score) test result</li></ul><hr/><h3 id="Practical-Workflow"><a class="docs-heading-anchor" href="#Practical-Workflow">Practical Workflow</a><a id="Practical-Workflow-1"></a><a class="docs-heading-anchor-permalink" href="#Practical-Workflow" title="Permalink"></a></h3><h4 id="Step-by-Step-Unit-Root-Analysis"><a class="docs-heading-anchor" href="#Step-by-Step-Unit-Root-Analysis">Step-by-Step Unit Root Analysis</a><a id="Step-by-Step-Unit-Root-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Step-by-Step-Unit-Root-Analysis" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# 1. Load/generate data
y = your_time_series

# 2. Visual inspection (plot the series)
# Look for trends, structural breaks, etc.

# 3. Test for unit root with ADF
adf_result = adf_test(y; regression=:constant)

# 4. Confirm with KPSS (opposite null)
kpss_result = kpss_test(y; regression=:constant)

# 5. If structural break suspected, use Zivot-Andrews
za_result = za_test(y; regression=:both)

# 6. For small samples, use Ng-Perron
np_result = ngperron_test(y; regression=:constant)

# 7. Decision matrix
if pvalue(adf_result) &lt; 0.05 &amp;&amp; pvalue(kpss_result) &gt; 0.05
    println(&quot;Series is stationary - proceed with VAR in levels&quot;)
elseif pvalue(adf_result) &gt; 0.05 &amp;&amp; pvalue(kpss_result) &lt; 0.05
    println(&quot;Series has unit root - consider differencing or VECM&quot;)
else
    println(&quot;Inconclusive - examine further or use robust methods&quot;)
end</code></pre><h4 id="Pre-VAR-Analysis"><a class="docs-heading-anchor" href="#Pre-VAR-Analysis">Pre-VAR Analysis</a><a id="Pre-VAR-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Pre-VAR-Analysis" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# Multi-variable dataset
Y = your_data_matrix

# 1. Test each variable for unit root
results = test_all_variables(Y; test=:adf)
n_nonstationary = sum(r.pvalue &gt; 0.05 for r in results)
println(&quot;Variables with unit roots: $n_nonstationary / $(size(Y, 2))&quot;)

# 2. If all I(1), test for cointegration
if n_nonstationary == size(Y, 2)
    johansen_result = johansen_test(Y, 2)

    if johansen_result.rank &gt; 0
        println(&quot;Cointegration detected! Use VECM with rank=$(johansen_result.rank)&quot;)
    else
        println(&quot;No cointegration - use VAR in first differences&quot;)
    end
end

# 3. If mixed I(0)/I(1), be cautious
# Consider ARDL bounds test or transform I(1) variables</code></pre><h4 id="Post-Estimation-Diagnostics"><a class="docs-heading-anchor" href="#Post-Estimation-Diagnostics">Post-Estimation Diagnostics</a><a id="Post-Estimation-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#Post-Estimation-Diagnostics" title="Permalink"></a></h4><pre><code class="language-julia hljs">using MacroEconometricModels

# After estimating VAR on FRED-MD data
fred = load_example(:fred_md)
Y = to_matrix(apply_tcode(fred[:, [&quot;INDPRO&quot;, &quot;CPIAUCSL&quot;, &quot;FEDFUNDS&quot;]]))
Y = Y[all.(isfinite, eachrow(Y)), :]
m = estimate_var(Y, 2)

# 1. Check stability
stat = is_stationary(m)
println(&quot;Stable: &quot;, stat.is_stationary, &quot; (max modulus: &quot;, round(stat.max_modulus, digits=3), &quot;)&quot;)

# 2. Granger causality
results = granger_test_all(m)

# 3. Compare lag specifications
m1 = estimate_var(Y, 1)
m3 = estimate_var(Y, 3)
println(&quot;VAR(1) vs VAR(2): &quot;, lr_test(m1, m))
println(&quot;VAR(2) vs VAR(3): &quot;, lr_test(m, m3))</code></pre><hr/><h3 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h3><h4 id="Unit-Root-Tests-2"><a class="docs-heading-anchor" href="#Unit-Root-Tests-2">Unit Root Tests</a><a class="docs-heading-anchor-permalink" href="#Unit-Root-Tests-2" title="Permalink"></a></h4><ul><li>Dickey, David A., and Wayne A. Fuller. 1979. &quot;Distribution of the Estimators for Autoregressive Time Series with a Unit Root.&quot; <em>Journal of the American Statistical Association</em> 74 (366): 427–431. <a href="https://doi.org/10.1080/01621459.1979.10482531">https://doi.org/10.1080/01621459.1979.10482531</a></li><li>Kwiatkowski, Denis, Peter C. B. Phillips, Peter Schmidt, and Yongcheol Shin. 1992. &quot;Testing the Null Hypothesis of Stationarity Against the Alternative of a Unit Root.&quot; <em>Journal of Econometrics</em> 54 (1–3): 159–178. <a href="https://doi.org/10.1016/0304-4076(92)90104-Y">https://doi.org/10.1016/0304-4076(92)90104-Y</a></li><li>MacKinnon, James G. 2010. &quot;Critical Values for Cointegration Tests.&quot; Queen&#39;s Economics Department Working Paper No. 1227.</li><li>Ng, Serena, and Pierre Perron. 2001. &quot;Lag Length Selection and the Construction of Unit Root Tests with Good Size and Power.&quot; <em>Econometrica</em> 69 (6): 1519–1554. <a href="https://doi.org/10.1111/1468-0262.00256">https://doi.org/10.1111/1468-0262.00256</a></li><li>Phillips, Peter C. B., and Pierre Perron. 1988. &quot;Testing for a Unit Root in Time Series Regression.&quot; <em>Biometrika</em> 75 (2): 335–346. <a href="https://doi.org/10.1093/biomet/75.2.335">https://doi.org/10.1093/biomet/75.2.335</a></li><li>Zivot, Eric, and Donald W. K. Andrews. 1992. &quot;Further Evidence on the Great Crash, the Oil-Price Shock, and the Unit-Root Hypothesis.&quot; <em>Journal of Business &amp; Economic Statistics</em> 10 (3): 251–270. <a href="https://doi.org/10.1080/07350015.1992.10509904">https://doi.org/10.1080/07350015.1992.10509904</a></li></ul><h4 id="Cointegration"><a class="docs-heading-anchor" href="#Cointegration">Cointegration</a><a id="Cointegration-1"></a><a class="docs-heading-anchor-permalink" href="#Cointegration" title="Permalink"></a></h4><ul><li>Johansen, Soren. 1991. &quot;Estimation and Hypothesis Testing of Cointegration Vectors in Gaussian Vector Autoregressive Models.&quot; <em>Econometrica</em> 59 (6): 1551–1580. <a href="https://doi.org/10.2307/2938278">https://doi.org/10.2307/2938278</a></li><li>Johansen, Soren. 1995. <em>Likelihood-Based Inference in Cointegrated Vector Autoregressive Models</em>. Oxford: Oxford University Press. ISBN 978-0-19-877450-5.</li><li>Osterwald-Lenum, Michael. 1992. &quot;A Note with Quantiles of the Asymptotic Distribution of the Maximum Likelihood Cointegration Rank Test Statistics.&quot; <em>Oxford Bulletin of Economics and Statistics</em> 54 (3): 461–472. <a href="https://doi.org/10.1111/j.1468-0084.1992.tb00013.x">https://doi.org/10.1111/j.1468-0084.1992.tb00013.x</a></li></ul><h4 id="VAR-2"><a class="docs-heading-anchor" href="#VAR-2">VAR</a><a class="docs-heading-anchor-permalink" href="#VAR-2" title="Permalink"></a></h4><ul><li>Granger, C. W. J. 1969. &quot;Investigating Causal Relations by Econometric Models and Cross-spectral Methods.&quot; <em>Econometrica</em> 37 (3): 424–438. <a href="https://doi.org/10.2307/1912791">https://doi.org/10.2307/1912791</a></li></ul><h4 id="Panel-VAR-2"><a class="docs-heading-anchor" href="#Panel-VAR-2">Panel VAR</a><a class="docs-heading-anchor-permalink" href="#Panel-VAR-2" title="Permalink"></a></h4><ul><li>Hansen, Lars Peter. 1982. &quot;Large Sample Properties of Generalized Method of Moments Estimators.&quot; <em>Econometrica</em> 50 (4): 1029–1054. <a href="https://doi.org/10.2307/1912775">https://doi.org/10.2307/1912775</a></li><li>Andrews, Donald W. K., and Biao Lu. 2001. &quot;Consistent Model and Moment Selection Procedures for GMM Estimation.&quot; <em>Journal of Econometrics</em> 101 (1): 123–164. <a href="https://doi.org/10.1016/S0304-4076(00)00077-4">https://doi.org/10.1016/S0304-4076(00)00077-4</a></li></ul><h4 id="Model-Comparison"><a class="docs-heading-anchor" href="#Model-Comparison">Model Comparison</a><a id="Model-Comparison-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Comparison" title="Permalink"></a></h4><ul><li>Wilks, Samuel S. 1938. &quot;The Large-Sample Distribution of the Likelihood Ratio for Testing Composite Hypotheses.&quot; <em>Annals of Mathematical Statistics</em> 9 (1): 60–62. <a href="https://doi.org/10.1214/aoms/1177732360">https://doi.org/10.1214/aoms/1177732360</a></li><li>Neyman, Jerzy, and Egon S. Pearson. 1933. &quot;On the Problem of the Most Efficient Tests of Statistical Hypotheses.&quot; <em>Philosophical Transactions of the Royal Society A</em> 231 (694–706): 289–337. <a href="https://doi.org/10.1098/rsta.1933.0009">https://doi.org/10.1098/rsta.1933.0009</a></li><li>Rao, C. Radhakrishna. 1948. &quot;Large Sample Tests of Statistical Hypotheses Concerning Several Parameters with Applications to Problems of Estimation.&quot; <em>Mathematical Proceedings of the Cambridge Philosophical Society</em> 44 (1): 50–57. <a href="https://doi.org/10.1017/S0305004100023987">https://doi.org/10.1017/S0305004100023987</a></li><li>Silvey, S. D. 1959. &quot;The Lagrangian Multiplier Test.&quot; <em>Annals of Mathematical Statistics</em> 30 (2): 389–407. <a href="https://doi.org/10.1214/aoms/1177706259">https://doi.org/10.1214/aoms/1177706259</a></li></ul><h4 id="Textbooks"><a class="docs-heading-anchor" href="#Textbooks">Textbooks</a><a id="Textbooks-1"></a><a class="docs-heading-anchor-permalink" href="#Textbooks" title="Permalink"></a></h4><ul><li>Hamilton, James D. 1994. <em>Time Series Analysis</em>. Princeton, NJ: Princeton University Press. ISBN 978-0-691-04289-3.</li><li>Lutkepohl, Helmut. 2005. <em>New Introduction to Multiple Time Series Analysis</em>. Berlin: Springer. ISBN 978-3-540-40172-8.</li><li>Enders, Walter. 2014. <em>Applied Econometric Time Series</em>. 4th ed. Hoboken, NJ: Wiley. ISBN 978-1-118-80856-6.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../nongaussian/">« Statistical Identification</a><a class="docs-footer-nextpage" href="../plotting/">Visualization »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 20 February 2026 19:11">Friday 20 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
