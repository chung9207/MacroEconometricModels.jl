<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>VECM · MacroEconometricModels.jl</title><meta name="title" content="VECM · MacroEconometricModels.jl"/><meta property="og:title" content="VECM · MacroEconometricModels.jl"/><meta property="twitter:title" content="VECM · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://FriedmanJP.github.io/MacroEconometricModels.jl/vecm/"/><meta property="twitter:url" content="https://FriedmanJP.github.io/MacroEconometricModels.jl/vecm/"/><link rel="canonical" href="https://FriedmanJP.github.io/MacroEconometricModels.jl/vecm/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/theme-toggle.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../data/">Data Management</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../filters/">Time Series Filters</a></li><li><a class="tocitem" href="../arima/">ARIMA</a></li><li><a class="tocitem" href="../volatility/">Volatility Models</a></li></ul></li><li><span class="tocitem">Multivariate Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li><li class="is-active"><a class="tocitem" href>VECM</a><ul class="internal"><li><a class="tocitem" href="#Quick-Start"><span>Quick Start</span></a></li><li><a class="tocitem" href="#Model-Specification"><span>Model Specification</span></a></li><li><a class="tocitem" href="#Estimation"><span>Estimation</span></a></li><li><a class="tocitem" href="#VAR-Conversion"><span>VAR Conversion</span></a></li><li><a class="tocitem" href="#Innovation-Accounting"><span>Innovation Accounting</span></a></li><li><a class="tocitem" href="#Forecasting"><span>Forecasting</span></a></li><li><a class="tocitem" href="#Granger-Causality"><span>Granger Causality</span></a></li><li><a class="tocitem" href="#Complete-Example"><span>Complete Example</span></a></li><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Panel Models</span><ul><li><a class="tocitem" href="../pvar/">Panel VAR</a></li></ul></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><a class="tocitem" href="../nowcast/">Nowcasting</a></li><li><a class="tocitem" href="../nongaussian/">Statistical Identification</a></li><li><a class="tocitem" href="../hypothesis_tests/">Hypothesis Tests</a></li><li><a class="tocitem" href="../plotting/">Visualization</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li><a class="tocitem" href="../api_functions/">Functions</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Multivariate Models</a></li><li class="is-active"><a href>VECM</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>VECM</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FriedmanJP/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/main/docs/src/vecm.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Vector-Error-Correction-Models"><a class="docs-heading-anchor" href="#Vector-Error-Correction-Models">Vector Error Correction Models</a><a id="Vector-Error-Correction-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Vector-Error-Correction-Models" title="Permalink"></a></h1><p>This page documents the Vector Error Correction Model (VECM) implementation in <strong>MacroEconometricModels.jl</strong>, providing estimation via Johansen maximum likelihood and Engle-Granger two-step methods.</p><h2 id="Quick-Start"><a class="docs-heading-anchor" href="#Quick-Start">Quick Start</a><a id="Quick-Start-1"></a><a class="docs-heading-anchor-permalink" href="#Quick-Start" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MacroEconometricModels

# Load FRED-QD: log GDP, Consumption, Investment (I(1), cointegrated)
qd = load_example(:fred_qd)
Y = log.(to_matrix(qd[:, [&quot;GDPC1&quot;, &quot;PCECC96&quot;, &quot;GPDIC1&quot;]]))
Y = Y[all.(isfinite, eachrow(Y)), :]

# Estimate VECM with automatic rank selection
vecm = estimate_vecm(Y, 2)

# Estimate with explicit rank and deterministic specification
vecm = estimate_vecm(Y, 2; rank=1, deterministic=:constant)

# Convert to VAR for structural analysis
var_model = to_var(vecm)
irfs = irf(vecm, 20)  # IRFs via automatic VAR conversion</code></pre><hr/><h2 id="Model-Specification"><a class="docs-heading-anchor" href="#Model-Specification">Model Specification</a><a id="Model-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Specification" title="Permalink"></a></h2><h3 id="From-VAR-to-VECM"><a class="docs-heading-anchor" href="#From-VAR-to-VECM">From VAR to VECM</a><a id="From-VAR-to-VECM-1"></a><a class="docs-heading-anchor-permalink" href="#From-VAR-to-VECM" title="Permalink"></a></h3><p>Consider a VAR(p) model in levels for an <span>$n$</span>-dimensional <span>$I(1)$</span> vector <span>$y_t$</span>:</p><p class="math-container">\[y_t = c + A_1 y_{t-1} + A_2 y_{t-2} + \cdots + A_p y_{t-p} + u_t\]</p><p>When the variables are cointegrated, the Granger representation theorem (Engle &amp; Granger, 1987) implies the system can be written in <strong>Vector Error Correction</strong> form:</p><p class="math-container">\[\Delta y_t = \alpha \beta&#39; y_{t-1} + \Gamma_1 \Delta y_{t-1} + \cdots + \Gamma_{p-1} \Delta y_{t-p+1} + \mu + u_t\]</p><p>where:</p><ul><li><span>$\Pi = \alpha \beta&#39;$</span> is the <strong>long-run matrix</strong> (<span>$n \times n$</span>, rank <span>$r$</span>)</li><li><span>$\alpha$</span> is the <span>$n \times r$</span> matrix of <strong>adjustment coefficients</strong> (loading matrix)</li><li><span>$\beta$</span> is the <span>$n \times r$</span> matrix of <strong>cointegrating vectors</strong></li><li><span>$\Gamma_i = -(A_{i+1} + \cdots + A_p)$</span> are the <strong>short-run dynamics</strong> matrices</li><li><span>$\mu$</span> is the <span>$n \times 1$</span> intercept vector</li><li><span>$u_t \sim N(0, \Sigma)$</span> are i.i.d. innovations</li></ul><p>The cointegrating rank <span>$r$</span> determines the number of long-run equilibrium relationships. When <span>$r = 0$</span>, there is no cointegration and the system reduces to a VAR in first differences. When <span>$r = n$</span>, the system is stationary in levels.</p><h3 id="The-Cointegrating-Relationship"><a class="docs-heading-anchor" href="#The-Cointegrating-Relationship">The Cointegrating Relationship</a><a id="The-Cointegrating-Relationship-1"></a><a class="docs-heading-anchor-permalink" href="#The-Cointegrating-Relationship" title="Permalink"></a></h3><p>Each column <span>$\beta_j$</span> of <span>$\beta$</span> defines a stationary linear combination:</p><p class="math-container">\[z_{j,t} = \beta_j&#39; y_t \quad \sim I(0), \quad j = 1, \ldots, r\]</p><p>The corresponding column <span>$\alpha_j$</span> of <span>$\alpha$</span> governs the speed of adjustment: <span>$\alpha_{ij}$</span> measures how quickly variable <span>$i$</span> responds to deviations from the <span>$j$</span>-th equilibrium.</p><div class="admonition is-info" id="Phillips-Normalization-4fa168e434a9817f"><header class="admonition-header">Phillips Normalization<a class="admonition-anchor" href="#Phillips-Normalization-4fa168e434a9817f" title="Permalink"></a></header><div class="admonition-body"><p>The package applies Phillips normalization to <span>$\beta$</span> so that the first <span>$r$</span> rows form an identity matrix. This ensures unique identification of the cointegrating vectors.</p></div></div><hr/><h2 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h2><h3 id="Johansen-Maximum-Likelihood-(Default)"><a class="docs-heading-anchor" href="#Johansen-Maximum-Likelihood-(Default)">Johansen Maximum Likelihood (Default)</a><a id="Johansen-Maximum-Likelihood-(Default)-1"></a><a class="docs-heading-anchor-permalink" href="#Johansen-Maximum-Likelihood-(Default)" title="Permalink"></a></h3><p>The Johansen (1991) reduced-rank regression procedure estimates <span>$\alpha$</span> and <span>$\beta$</span> jointly via MLE:</p><ol><li><strong>Concentrate out short-run dynamics</strong> by regressing <span>$\Delta Y$</span> and <span>$Y_{t-1}$</span> on lagged differences <span>$Z = [\Delta Y_{t-1}, \ldots, \Delta Y_{t-p+1}, \mu]$</span></li><li><strong>Compute moment matrices</strong> <span>$S_{00}$</span>, <span>$S_{11}$</span>, <span>$S_{01}$</span> from the concentrated residuals</li><li><strong>Solve the generalized eigenvalue problem</strong> <span>$|{\lambda S_{11} - S_{10} S_{00}^{-1} S_{01}}| = 0$</span></li><li><strong>Extract</strong> <span>$\beta$</span> from the first <span>$r$</span> eigenvectors and compute <span>$\alpha = S_{01} \beta (\beta&#39; S_{11} \beta)^{-1}$</span></li></ol><pre><code class="language-julia hljs">using MacroEconometricModels

# Load FRED-QD: log GDP, Consumption, Investment
qd = load_example(:fred_qd)
Y = log.(to_matrix(qd[:, [&quot;GDPC1&quot;, &quot;PCECC96&quot;, &quot;GPDIC1&quot;]]))
Y = Y[all.(isfinite, eachrow(Y)), :]

# Automatic rank selection via Johansen trace test
vecm = estimate_vecm(Y, 2)

# Explicit rank specification
vecm = estimate_vecm(Y, 2; rank=1)

# Different deterministic specifications
vecm = estimate_vecm(Y, 2; rank=1, deterministic=:none)     # No deterministic terms
vecm = estimate_vecm(Y, 2; rank=1, deterministic=:constant)  # Constant (default)
vecm = estimate_vecm(Y, 2; rank=1, deterministic=:trend)     # Linear trend</code></pre><p>The <strong>rank</strong> can be selected automatically using the Johansen trace test, or specified explicitly. Use <code>select_vecm_rank</code> for fine-grained control:</p><pre><code class="language-julia hljs">r = select_vecm_rank(Y, 2; criterion=:trace, significance=0.05)
r_max = select_vecm_rank(Y, 2; criterion=:max_eigen)</code></pre><h3 id="Engle-Granger-Two-Step"><a class="docs-heading-anchor" href="#Engle-Granger-Two-Step">Engle-Granger Two-Step</a><a id="Engle-Granger-Two-Step-1"></a><a class="docs-heading-anchor-permalink" href="#Engle-Granger-Two-Step" title="Permalink"></a></h3><p>For bivariate systems with a single cointegrating relationship (<span>$r = 1$</span>), the Engle-Granger (1987) two-step estimator is available:</p><ol><li><strong>Step 1</strong>: Estimate the cointegrating vector via static OLS regression of <span>$y_{1,t}$</span> on <span>$y_{2,t}, \ldots, y_{n,t}$</span></li><li><strong>Step 2</strong>: Estimate the VECM equation using the OLS residuals as the error correction term</li></ol><pre><code class="language-julia hljs">vecm_eg = estimate_vecm(Y, 2; method=:engle_granger, rank=1)</code></pre><div class="admonition is-warning" id="Warning-da205858aefd90c1"><header class="admonition-header">Warning<a class="admonition-anchor" href="#Warning-da205858aefd90c1" title="Permalink"></a></header><div class="admonition-body"><p>The Engle-Granger method only supports <code>rank=1</code>. For systems with multiple cointegrating vectors, use the Johansen method.</p></div></div><h3 id="Return-Values"><a class="docs-heading-anchor" href="#Return-Values">Return Values</a><a id="Return-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Return-Values" title="Permalink"></a></h3><p><code>estimate_vecm</code> returns a <code>VECMModel{T}</code> with the following fields:</p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Type</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>Y</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Original data in levels (T_obs x n)</td></tr><tr><td style="text-align: right"><code>p</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Underlying VAR order</td></tr><tr><td style="text-align: right"><code>rank</code></td><td style="text-align: right"><code>Int</code></td><td style="text-align: right">Cointegrating rank r</td></tr><tr><td style="text-align: right"><code>alpha</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Adjustment coefficients (n x r)</td></tr><tr><td style="text-align: right"><code>beta</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Cointegrating vectors (n x r)</td></tr><tr><td style="text-align: right"><code>Pi</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Long-run matrix (n x n)</td></tr><tr><td style="text-align: right"><code>Gamma</code></td><td style="text-align: right"><code>Vector{Matrix{T}}</code></td><td style="text-align: right">Short-run dynamics matrices</td></tr><tr><td style="text-align: right"><code>mu</code></td><td style="text-align: right"><code>Vector{T}</code></td><td style="text-align: right">Intercept</td></tr><tr><td style="text-align: right"><code>U</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Residuals</td></tr><tr><td style="text-align: right"><code>Sigma</code></td><td style="text-align: right"><code>Matrix{T}</code></td><td style="text-align: right">Residual covariance</td></tr><tr><td style="text-align: right"><code>aic</code>, <code>bic</code>, <code>hqic</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Information criteria</td></tr><tr><td style="text-align: right"><code>loglik</code></td><td style="text-align: right"><code>T</code></td><td style="text-align: right">Log-likelihood</td></tr><tr><td style="text-align: right"><code>deterministic</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Deterministic specification</td></tr><tr><td style="text-align: right"><code>method</code></td><td style="text-align: right"><code>Symbol</code></td><td style="text-align: right">Estimation method</td></tr><tr><td style="text-align: right"><code>johansen_result</code></td><td style="text-align: right"><code>JohansenResult{T}</code></td><td style="text-align: right">Johansen test result</td></tr></table><hr/><h2 id="VAR-Conversion"><a class="docs-heading-anchor" href="#VAR-Conversion">VAR Conversion</a><a id="VAR-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#VAR-Conversion" title="Permalink"></a></h2><p>The <code>to_var</code> function converts a VECM back to a VAR in levels, enabling all structural analysis methods:</p><p class="math-container">\[A_1 = \Pi + I_n + \Gamma_1, \quad A_i = \Gamma_i - \Gamma_{i-1}, \quad A_p = -\Gamma_{p-1}\]</p><pre><code class="language-julia hljs">var_model = to_var(vecm)</code></pre><p>This is critical because it allows all 18+ identification methods (Cholesky, sign restrictions, ICA, etc.) to work automatically with VECM models.</p><hr/><h2 id="Innovation-Accounting"><a class="docs-heading-anchor" href="#Innovation-Accounting">Innovation Accounting</a><a id="Innovation-Accounting-1"></a><a class="docs-heading-anchor-permalink" href="#Innovation-Accounting" title="Permalink"></a></h2><p>All structural analysis functions dispatch through <code>to_var()</code>, so VECMModel objects can be passed directly:</p><pre><code class="language-julia hljs"># Impulse Response Functions
irfs = irf(vecm, 20; method=:cholesky)
irfs = irf(vecm, 20; method=:sign, check_func=f, ci_type=:bootstrap)

# Forecast Error Variance Decomposition
decomp = fevd(vecm, 20)

# Historical Decomposition
T_eff = effective_nobs(to_var(vecm))
hd = historical_decomposition(vecm, T_eff)</code></pre><hr/><h2 id="Forecasting"><a class="docs-heading-anchor" href="#Forecasting">Forecasting</a><a id="Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Forecasting" title="Permalink"></a></h2><p>VECM forecasting iterates the VECM equations directly in levels, preserving the cointegrating relationships in the forecast path. This is preferable to forecasting from the converted VAR, as it ensures the error correction mechanism operates during the forecast.</p><pre><code class="language-julia hljs"># Point forecast
fc = forecast(vecm, 10)
fc.levels       # h x n forecast in levels
fc.differences  # h x n forecast in first differences

# With bootstrap confidence intervals
fc = forecast(vecm, 10; ci_method=:bootstrap, reps=500, conf_level=0.95)

# With simulation-based CIs
fc = forecast(vecm, 10; ci_method=:simulation, reps=500)</code></pre><p>The <code>VECMForecast{T}</code> struct contains:</p><table><tr><th style="text-align: right">Field</th><th style="text-align: right">Description</th></tr><tr><td style="text-align: right"><code>levels</code></td><td style="text-align: right">Forecasts in levels (h x n)</td></tr><tr><td style="text-align: right"><code>differences</code></td><td style="text-align: right">Forecasts in first differences (h x n)</td></tr><tr><td style="text-align: right"><code>ci_lower</code>, <code>ci_upper</code></td><td style="text-align: right">Confidence interval bounds (h x n)</td></tr><tr><td style="text-align: right"><code>horizon</code></td><td style="text-align: right">Forecast horizon</td></tr><tr><td style="text-align: right"><code>ci_method</code></td><td style="text-align: right">Method used for CIs</td></tr></table><hr/><h2 id="Granger-Causality"><a class="docs-heading-anchor" href="#Granger-Causality">Granger Causality</a><a id="Granger-Causality-1"></a><a class="docs-heading-anchor-permalink" href="#Granger-Causality" title="Permalink"></a></h2><p>VECM Granger causality tests decompose causal channels into short-run and long-run components:</p><pre><code class="language-julia hljs">g = granger_causality_vecm(vecm, 1, 2)  # Test: Var 1 → Var 2</code></pre><p>Three tests are computed:</p><table><tr><th style="text-align: right">Test</th><th style="text-align: right">Hypothesis</th><th style="text-align: right">Mechanism</th></tr><tr><td style="text-align: right"><strong>Short-run</strong></td><td style="text-align: right"><span>$\Gamma_i[\text{effect}, \text{cause}] = 0$</span> for all <span>$i$</span></td><td style="text-align: right">Causality through lagged differences</td></tr><tr><td style="text-align: right"><strong>Long-run</strong></td><td style="text-align: right"><span>$\alpha[\text{effect}, :] = 0$</span></td><td style="text-align: right">Causality through error correction</td></tr><tr><td style="text-align: right"><strong>Strong</strong></td><td style="text-align: right">Joint test of both</td><td style="text-align: right">Combined short-run and long-run causality</td></tr></table><p>Each test reports a Wald <span>$\chi^2$</span> statistic, degrees of freedom, and p-value.</p><hr/><h2 id="Complete-Example"><a class="docs-heading-anchor" href="#Complete-Example">Complete Example</a><a id="Complete-Example-1"></a><a class="docs-heading-anchor-permalink" href="#Complete-Example" title="Permalink"></a></h2><pre><code class="language-julia hljs">using MacroEconometricModels

# Load FRED-QD: log GDP, Consumption, Investment (quarterly, I(1))
qd = load_example(:fred_qd)
Y = log.(to_matrix(qd[:, [&quot;GDPC1&quot;, &quot;PCECC96&quot;, &quot;GPDIC1&quot;]]))
Y = Y[all.(isfinite, eachrow(Y)), :]

# Step 1: Test for cointegration
joh = johansen_test(Y, 2)
println(&quot;Johansen rank: &quot;, joh.rank)

# Step 2: Estimate VECM
vecm = estimate_vecm(Y, 2)
report(vecm)

# Step 3: Examine cointegrating vectors
println(&quot;β (cointegrating vectors):&quot;)
println(vecm.beta)
println(&quot;α (adjustment speeds):&quot;)
println(vecm.alpha)

# Step 4: Impulse responses
irfs = irf(vecm, 20; method=:cholesky)

# Step 5: Forecast
fc = forecast(vecm, 10; ci_method=:bootstrap, reps=200)

# Step 6: Granger causality — does GDP Granger-cause Consumption?
names = [&quot;GDP&quot;, &quot;Consumption&quot;, &quot;Investment&quot;]
for i in 1:3, j in 1:3
    i == j &amp;&amp; continue
    g = granger_causality_vecm(vecm, i, j)
    println(&quot;$(names[i]) → $(names[j]): p=$(round(g.strong_pvalue, digits=4))&quot;)
end

# Step 7: Convert to VAR for further analysis
var_model = to_var(vecm)
decomp = fevd(var_model, 20)</code></pre><p><strong>Interpretation.</strong> The cointegrating vector <span>$\beta$</span> identifies the long-run equilibrium between GDP, consumption, and investment. A cointegrating relationship of the form <span>$\beta&#39; y_t \sim I(0)$</span> implies these variables share common stochastic trends, consistent with balanced growth path theory. The adjustment coefficients <span>$\alpha$</span> show how each variable responds when the system deviates from this long-run equilibrium — for instance, if consumption overshoots relative to GDP, a negative <span>$\alpha$</span> for consumption would pull it back toward the equilibrium ratio. The Granger causality test decomposes into short-run (through lagged differences <span>$\Gamma$</span>) and long-run (through the error correction term <span>$\alpha\beta&#39;y_{t-1}$</span>) channels.</p><hr/><h3 id="See-Also"><a class="docs-heading-anchor" href="#See-Also">See Also</a><a id="See-Also-1"></a><a class="docs-heading-anchor-permalink" href="#See-Also" title="Permalink"></a></h3><ul><li><a href="../manual/">VAR Estimation</a> – Reduced-form VAR and structural identification</li><li><a href="../hypothesis_tests/">Hypothesis Tests</a> – Johansen cointegration test details and unit root tests</li><li><a href="../data/">Data Management</a> – Built-in datasets and data transformations</li><li><a href="../api_functions/">API Reference</a> – Complete function signatures</li></ul><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><ul><li>Johansen, Soren. 1991. &quot;Estimation and Hypothesis Testing of Cointegration Vectors in Gaussian Vector Autoregressive Models.&quot; <em>Econometrica</em> 59 (6): 1551–1580. <a href="https://doi.org/10.2307/2938278">https://doi.org/10.2307/2938278</a></li><li>Engle, Robert F., and Clive W. J. Granger. 1987. &quot;Co-Integration and Error Correction: Representation, Estimation, and Testing.&quot; <em>Econometrica</em> 55 (2): 251–276. <a href="https://doi.org/10.2307/1913236">https://doi.org/10.2307/1913236</a></li><li>Lutkepohl, Helmut. 2005. <em>New Introduction to Multiple Time Series Analysis</em>. Berlin: Springer. ISBN 978-3-540-40172-8.</li></ul></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../bayesian/">« Bayesian VAR</a><a class="docs-footer-nextpage" href="../lp/">Local Projections »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 20 February 2026 19:11">Friday 20 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
