<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Functions · MacroEconometricModels.jl</title><meta name="title" content="Functions · MacroEconometricModels.jl"/><meta property="og:title" content="Functions · MacroEconometricModels.jl"/><meta property="twitter:title" content="Functions · MacroEconometricModels.jl"/><meta name="description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:description" content="Documentation for MacroEconometricModels.jl."/><meta property="twitter:description" content="Documentation for MacroEconometricModels.jl."/><meta property="og:url" content="https://FriedmanJP.github.io/MacroEconometricModels.jl/api_functions/"/><meta property="twitter:url" content="https://FriedmanJP.github.io/MacroEconometricModels.jl/api_functions/"/><link rel="canonical" href="https://FriedmanJP.github.io/MacroEconometricModels.jl/api_functions/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script><link href="../assets/custom.css" rel="stylesheet" type="text/css"/><script src="../assets/theme-toggle.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">MacroEconometricModels.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../data/">Data Management</a></li><li><span class="tocitem">Univariate Models</span><ul><li><a class="tocitem" href="../filters/">Time Series Filters</a></li><li><a class="tocitem" href="../arima/">ARIMA</a></li><li><a class="tocitem" href="../volatility/">Volatility Models</a></li></ul></li><li><span class="tocitem">Multivariate Models</span><ul><li><a class="tocitem" href="../manual/">VAR</a></li><li><a class="tocitem" href="../bayesian/">Bayesian VAR</a></li><li><a class="tocitem" href="../vecm/">VECM</a></li><li><a class="tocitem" href="../lp/">Local Projections</a></li><li><a class="tocitem" href="../factormodels/">Factor Models</a></li></ul></li><li><span class="tocitem">Panel Models</span><ul><li><a class="tocitem" href="../pvar/">Panel VAR</a></li></ul></li><li><a class="tocitem" href="../innovation_accounting/">Innovation Accounting</a></li><li><a class="tocitem" href="../nowcast/">Nowcasting</a></li><li><a class="tocitem" href="../nongaussian/">Statistical Identification</a></li><li><a class="tocitem" href="../hypothesis_tests/">Hypothesis Tests</a></li><li><a class="tocitem" href="../plotting/">Visualization</a></li><li><a class="tocitem" href="../examples/">Examples</a></li><li><span class="tocitem">API Reference</span><ul><li><a class="tocitem" href="../api/">Overview</a></li><li><a class="tocitem" href="../api_types/">Types</a></li><li class="is-active"><a class="tocitem" href>Functions</a><ul class="internal"><li><a class="tocitem" href="#Data-Management"><span>Data Management</span></a></li><li><a class="tocitem" href="#Time-Series-Filters"><span>Time Series Filters</span></a></li><li><a class="tocitem" href="#ARIMA-Models"><span>ARIMA Models</span></a></li><li><a class="tocitem" href="#VAR-Estimation"><span>VAR Estimation</span></a></li><li><a class="tocitem" href="#Structural-Identification"><span>Structural Identification</span></a></li><li><a class="tocitem" href="#Innovation-Accounting"><span>Innovation Accounting</span></a></li><li><a class="tocitem" href="#Local-Projections"><span>Local Projections</span></a></li><li><a class="tocitem" href="#Factor-Models"><span>Factor Models</span></a></li><li><a class="tocitem" href="#Panel-VAR"><span>Panel VAR</span></a></li><li><a class="tocitem" href="#GMM-Estimation"><span>GMM Estimation</span></a></li><li><a class="tocitem" href="#Unit-Root-and-Cointegration-Tests"><span>Unit Root and Cointegration Tests</span></a></li><li><a class="tocitem" href="#Model-Comparison-Tests"><span>Model Comparison Tests</span></a></li><li><a class="tocitem" href="#Granger-Causality-Tests"><span>Granger Causality Tests</span></a></li><li><a class="tocitem" href="#Volatility-Models"><span>Volatility Models</span></a></li><li><a class="tocitem" href="#Nowcasting"><span>Nowcasting</span></a></li><li><a class="tocitem" href="#Display-and-References"><span>Display and References</span></a></li><li><a class="tocitem" href="#Non-Gaussian-Identification"><span>Non-Gaussian Identification</span></a></li><li><a class="tocitem" href="#Covariance-Estimators"><span>Covariance Estimators</span></a></li><li><a class="tocitem" href="#Utility-Functions"><span>Utility Functions</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Reference</a></li><li class="is-active"><a href>Functions</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Functions</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/FriedmanJP/MacroEconometricModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/main/docs/src/api_functions.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="api_functions"><a class="docs-heading-anchor" href="#api_functions">API Functions</a><a id="api_functions-1"></a><a class="docs-heading-anchor-permalink" href="#api_functions" title="Permalink"></a></h1><p>This page documents all functions in <strong>MacroEconometricModels.jl</strong>, organized by module.</p><hr/><h2 id="Data-Management"><a class="docs-heading-anchor" href="#Data-Management">Data Management</a><a id="Data-Management-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Management" title="Permalink"></a></h2><h3 id="Validation-and-Cleaning"><a class="docs-heading-anchor" href="#Validation-and-Cleaning">Validation and Cleaning</a><a id="Validation-and-Cleaning-1"></a><a class="docs-heading-anchor-permalink" href="#Validation-and-Cleaning" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.diagnose"><a class="docstring-binding" href="#MacroEconometricModels.diagnose"><code>MacroEconometricModels.diagnose</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">diagnose(d::AbstractMacroData) -&gt; DataDiagnostic</code></pre><p>Scan data for NaN, Inf, constant columns, and very short series.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData(randn(100, 3))
diag = diagnose(d)
diag.is_clean  # true if no issues</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/validation.jl#L90-L101">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.fix"><a class="docstring-binding" href="#MacroEconometricModels.fix"><code>MacroEconometricModels.fix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">fix(d::TimeSeriesData; method=:listwise) -&gt; TimeSeriesData</code></pre><p>Fix data issues and return a clean copy.</p><p><strong>Methods</strong></p><ul><li><code>:listwise</code> — drop rows with any NaN or Inf (default)</li><li><code>:interpolate</code> — linear interpolation for interior NaN, forward-fill edges</li><li><code>:mean</code> — replace NaN with column mean of finite values</li></ul><p>Inf values are always replaced with NaN first (then handled by the chosen method). Constant columns are dropped with a warning.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData([1.0 NaN; 2.0 3.0; 3.0 4.0])
d_clean = fix(d; method=:listwise)  # drops row 1</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/validation.jl#L132-L150">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_for_model"><a class="docstring-binding" href="#MacroEconometricModels.validate_for_model"><code>MacroEconometricModels.validate_for_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">validate_for_model(d::AbstractMacroData, model_type::Symbol)</code></pre><p>Check that data is compatible with the specified model type. Throws <code>ArgumentError</code> on mismatch.</p><p><strong>Model types requiring multivariate data (n_vars ≥ 2)</strong></p><p><code>:var</code>, <code>:vecm</code>, <code>:bvar</code>, <code>:factors</code>, <code>:dynamic_factors</code>, <code>:gdfm</code></p><p><strong>Model types requiring univariate data (n_vars == 1)</strong></p><p><code>:arima</code>, <code>:ar</code>, <code>:ma</code>, <code>:arma</code>, <code>:arch</code>, <code>:garch</code>, <code>:egarch</code>, <code>:gjr_garch</code>, <code>:sv</code>, <code>:hp_filter</code>, <code>:hamilton_filter</code>, <code>:beveridge_nelson</code>, <code>:baxter_king</code>, <code>:boosted_hp</code>, <code>:adf</code>, <code>:kpss</code>, <code>:pp</code>, <code>:za</code>, <code>:ngperron</code></p><p><strong>Model types accepting any dimensionality</strong></p><p><code>:lp</code>, <code>:lp_iv</code>, <code>:smooth_lp</code>, <code>:state_lp</code>, <code>:propensity_lp</code>, <code>:gmm</code></p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData(randn(100, 3))
validate_for_model(d, :var)    # OK
validate_for_model(d, :arima)  # throws ArgumentError</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/validation.jl#L267-L289">source</a></section></details></article><h3 id="FRED-Transformations"><a class="docs-heading-anchor" href="#FRED-Transformations">FRED Transformations</a><a id="FRED-Transformations-1"></a><a class="docs-heading-anchor-permalink" href="#FRED-Transformations" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.apply_tcode"><a class="docstring-binding" href="#MacroEconometricModels.apply_tcode"><code>MacroEconometricModels.apply_tcode</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_tcode(y::AbstractVector{&lt;:Real}, tcode::Int) -&gt; Vector{Float64}</code></pre><p>Apply FRED transformation code to a univariate series.</p><p>Codes 4–7 require strictly positive data. The output vector is shorter than the input for difference-based codes:</p><ul><li>tcode 1: same length</li><li>tcode 2, 4, 5: length T-1</li><li>tcode 3, 6, 7: length T-2</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">y = [100.0, 102.0, 105.0, 103.0, 108.0]
apply_tcode(y, 5)  # log first differences (approx growth rates)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/transform.jl#L37-L53">source</a></section><section><div><pre><code class="language-julia hljs">apply_tcode(d::TimeSeriesData, tcodes::Vector{Int}) -&gt; TimeSeriesData</code></pre><p>Apply per-variable FRED transformation codes. Rows are trimmed consistently (to the shortest transformed series).</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData(rand(200, 3) .+ 1; varnames=[&quot;GDP&quot;,&quot;CPI&quot;,&quot;FFR&quot;])
d2 = apply_tcode(d, [5, 5, 1])  # log-diff GDP and CPI, leave FFR in levels</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/transform.jl#L86-L97">source</a></section><section><div><pre><code class="language-julia hljs">apply_tcode(d::TimeSeriesData, tcode::Int) -&gt; TimeSeriesData</code></pre><p>Apply the same FRED transformation code to all variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/transform.jl#L152-L156">source</a></section><section><div><pre><code class="language-julia hljs">apply_tcode(d::TimeSeriesData) -&gt; TimeSeriesData</code></pre><p>Convenience method: apply the transformation codes stored in <code>d.tcode</code>. Equivalent to <code>apply_tcode(d, d.tcode)</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = load_example(:fred_md)  # tcode already set
d_transformed = apply_tcode(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/transform.jl#L161-L172">source</a></section><section><div><pre><code class="language-julia hljs">apply_tcode(d::PanelData, tcodes::Vector{Int}) -&gt; PanelData</code></pre><p>Apply per-variable FRED transformation codes to a <code>PanelData</code> container, processing each group independently. Each group is trimmed to its own common length after transformation, then reassembled.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pd = xtset(df, :id, :t)
pd2 = apply_tcode(pd, [5, 5, 1])  # log-diff first two vars, leave third in levels</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/transform.jl#L179-L191">source</a></section><section><div><pre><code class="language-julia hljs">apply_tcode(d::PanelData, tcode::Int) -&gt; PanelData</code></pre><p>Apply the same FRED transformation code to all variables in a PanelData container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/transform.jl#L229-L233">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.inverse_tcode"><a class="docstring-binding" href="#MacroEconometricModels.inverse_tcode"><code>MacroEconometricModels.inverse_tcode</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">inverse_tcode(y::AbstractVector{&lt;:Real}, tcode::Int;
              x_prev::Union{AbstractVector{&lt;:Real},Nothing}=nothing) -&gt; Vector{Float64}</code></pre><p>Undo a FRED transformation to recover the original series.</p><p>For difference-based codes (2, 3, 5, 6, 7), <code>x_prev</code> must supply the initial values needed for reconstruction:</p><ul><li>tcode 2: <code>x_prev = [x₀]</code> (1 value)</li><li>tcode 3: <code>x_prev = [x₀, x₁]</code> (2 values, original levels)</li><li>tcode 5: <code>x_prev = [x₀]</code> (1 value, original level)</li><li>tcode 6: <code>x_prev = [x₀, x₁]</code> (2 values, original levels)</li><li>tcode 7: <code>x_prev = [x₀, x₁]</code> (2 values, original levels)</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">y = [100.0, 102.0, 105.0]
yd = apply_tcode(y, 2)                        # [2.0, 3.0]
inverse_tcode(yd, 2; x_prev=[100.0])          # [102.0, 105.0]</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/transform.jl#L242-L262">source</a></section></details></article><h3 id="Filtering"><a class="docs-heading-anchor" href="#Filtering">Filtering</a><a id="Filtering-1"></a><a class="docs-heading-anchor-permalink" href="#Filtering" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.apply_filter"><a class="docstring-binding" href="#MacroEconometricModels.apply_filter"><code>MacroEconometricModels.apply_filter</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">apply_filter(d::TimeSeriesData, specs::AbstractVector; component=:cycle, kwargs...)</code></pre><p>Apply per-variable filter specifications to a <code>TimeSeriesData</code> container.</p><p>Each element of <code>specs</code> can be:</p><ul><li><code>Symbol</code> — filter name (<code>:hp</code>, <code>:hamilton</code>, <code>:bn</code>, <code>:bk</code>, <code>:boosted_hp</code>)</li><li><code>AbstractFilterResult</code> — a pre-computed filter result</li><li><code>Tuple{filter, Symbol}</code> — filter with per-variable component override (e.g., <code>(:hp, :trend)</code>)</li><li><code>nothing</code> — pass-through (no filtering for this variable)</li></ul><p>The output is trimmed to the intersection of valid ranges across all variables.</p><p><strong>Arguments</strong></p><ul><li><code>d::TimeSeriesData</code> — input data</li><li><code>specs::AbstractVector</code> — per-variable filter specifications (length must equal <code>n_vars</code>)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>component::Symbol=:cycle</code> — default component to extract (<code>:cycle</code> or <code>:trend</code>)</li><li>Additional kwargs are forwarded to filter functions</li></ul><p><strong>Returns</strong></p><p>A new <code>TimeSeriesData</code> with filtered data, trimmed to the common valid range.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData(cumsum(randn(200, 3), dims=1); varnames=[&quot;GDP&quot;,&quot;CPI&quot;,&quot;FFR&quot;])

# Per-variable: HP cycle for GDP, Hamilton cycle for CPI, pass-through FFR
d2 = apply_filter(d, [:hp, :hamilton, nothing])

# Per-variable component overrides via tuples
d3 = apply_filter(d, [(:hp, :trend), (:hamilton, :cycle), nothing])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/filter.jl#L105-L139">source</a></section><section><div><pre><code class="language-julia hljs">apply_filter(d::TimeSeriesData, spec::Union{Symbol, AbstractFilterResult};
             component=:cycle, vars=nothing, kwargs...)</code></pre><p>Apply a single filter to all variables (or a subset specified by <code>vars</code>).</p><p>Variables not in <code>vars</code> are passed through unchanged.</p><p><strong>Arguments</strong></p><ul><li><code>d::TimeSeriesData</code> — input data</li><li><code>spec</code> — filter symbol (<code>:hp</code>, <code>:hamilton</code>, <code>:bn</code>, <code>:bk</code>, <code>:boosted_hp</code>) or pre-computed result</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>component::Symbol=:cycle</code> — component to extract (<code>:cycle</code> or <code>:trend</code>)</li><li><code>vars::Union{Nothing, Vector{String}, Vector{Int}}</code> — variables to filter (default: all)</li><li>Additional kwargs are forwarded to filter functions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData(cumsum(randn(200, 3), dims=1); varnames=[&quot;GDP&quot;,&quot;CPI&quot;,&quot;FFR&quot;])

# HP cycle for all variables
d_hp = apply_filter(d, :hp)

# HP trend for selected variables only
d_sel = apply_filter(d, :hp; vars=[&quot;GDP&quot;, &quot;CPI&quot;], component=:trend)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/filter.jl#L218-L245">source</a></section><section><div><pre><code class="language-julia hljs">apply_filter(d::PanelData, spec; component=:cycle, vars=nothing, kwargs...)</code></pre><p>Apply filters to a <code>PanelData</code> container group-by-group.</p><p>Each group is extracted via <code>group_data</code>, filtered, and the results are reassembled into a new <code>PanelData</code>. Each group is trimmed independently to its own common valid range (groups may have different resulting lengths if unbalanced).</p><p><strong>Arguments</strong></p><ul><li><code>d::PanelData</code> — input panel data</li><li><code>spec</code> — filter specification: a single <code>Symbol</code>, <code>AbstractFilterResult</code>, or <code>AbstractVector</code> of per-variable specs (same formats as <code>TimeSeriesData</code>)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>component::Symbol=:cycle</code> — component to extract</li><li><code>vars</code> — variables to filter (others pass-through)</li><li>Additional kwargs forwarded to filter functions</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pd = xtset(df, :id, :t)
pd_hp = apply_filter(pd, :hp; component=:cycle)
pd_sel = apply_filter(pd, :hp; vars=[&quot;GDP&quot;], component=:trend)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/filter.jl#L277-L303">source</a></section></details></article><h3 id="Summary-Statistics"><a class="docs-heading-anchor" href="#Summary-Statistics">Summary Statistics</a><a id="Summary-Statistics-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-Statistics" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.describe_data"><a class="docstring-binding" href="#MacroEconometricModels.describe_data"><code>MacroEconometricModels.describe_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">describe_data(d::AbstractMacroData) -&gt; DataSummary</code></pre><p>Compute per-variable summary statistics (N, Mean, Std, Min, P25, Median, P75, Max, Skewness, Kurtosis). NaN values are excluded from all computations.</p><p>For <code>PanelData</code>, also prints panel dimensions via <code>panel_summary</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData(randn(200, 3); varnames=[&quot;GDP&quot;,&quot;CPI&quot;,&quot;FFR&quot;], frequency=Quarterly)
describe_data(d)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/summary_stats.jl#L100-L113">source</a></section></details></article><h3 id="Panel-Data"><a class="docs-heading-anchor" href="#Panel-Data">Panel Data</a><a id="Panel-Data-1"></a><a class="docs-heading-anchor-permalink" href="#Panel-Data" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.xtset"><a class="docstring-binding" href="#MacroEconometricModels.xtset"><code>MacroEconometricModels.xtset</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">xtset(df::DataFrame, group_col::Symbol, time_col::Symbol;
      varnames=nothing, frequency=Other, tcode=nothing) -&gt; PanelData{Float64}</code></pre><p>Construct a <code>PanelData</code> container from a DataFrame, analogous to Stata&#39;s <code>xtset</code>.</p><p>Extracts all numeric columns (excluding <code>group_col</code> and <code>time_col</code>), sorts by (group, time), validates no duplicate (group, time) pairs, and detects whether the panel is balanced.</p><p><strong>Arguments</strong></p><ul><li><code>df::DataFrame</code> — input data</li><li><code>group_col::Symbol</code> — column name identifying groups (entities)</li><li><code>time_col::Symbol</code> — column name identifying time periods</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>varnames::Union{Vector{String},Nothing}</code> — override variable names (default: column names)</li><li><code>frequency::Frequency</code> — data frequency (default: <code>Other</code>)</li><li><code>tcode::Union{Vector{Int},Nothing}</code> — transformation codes per variable</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">using DataFrames
df = DataFrame(id=repeat(1:3, inner=50), t=repeat(1:50, 3),
               x=randn(150), y=randn(150))
pd = xtset(df, :id, :t)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/panel.jl#L28-L55">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.isbalanced"><a class="docstring-binding" href="#MacroEconometricModels.isbalanced"><code>MacroEconometricModels.isbalanced</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">isbalanced(d::PanelData) -&gt; Bool</code></pre><p>Return <code>true</code> if all groups have the same number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/panel.jl#L134-L138">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.groups"><a class="docstring-binding" href="#MacroEconometricModels.groups"><code>MacroEconometricModels.groups</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">groups(d::PanelData) -&gt; Vector{String}</code></pre><p>Return the group names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/panel.jl#L141-L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ngroups"><a class="docstring-binding" href="#MacroEconometricModels.ngroups"><code>MacroEconometricModels.ngroups</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ngroups(d::PanelData) -&gt; Int</code></pre><p>Return the number of groups.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/panel.jl#L148-L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.group_data"><a class="docstring-binding" href="#MacroEconometricModels.group_data"><code>MacroEconometricModels.group_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">group_data(d::PanelData, g) -&gt; TimeSeriesData</code></pre><p>Extract data for a single group as a <code>TimeSeriesData</code> container.</p><p><code>g</code> can be an integer group index or a string group name.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pd = xtset(df, :id, :t)
g1 = group_data(pd, 1)       # by index
g1 = group_data(pd, &quot;1&quot;)     # by name</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/panel.jl#L155-L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.panel_summary"><a class="docstring-binding" href="#MacroEconometricModels.panel_summary"><code>MacroEconometricModels.panel_summary</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">panel_summary(d::PanelData)</code></pre><p>Display a summary table of the panel structure: number of groups, observations per group (min, mean, max), and balance status.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pd = xtset(df, :id, :t)
panel_summary(pd)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/panel.jl#L193-L204">source</a></section></details></article><h3 id="Data-Accessors-and-Conversion"><a class="docs-heading-anchor" href="#Data-Accessors-and-Conversion">Data Accessors and Conversion</a><a id="Data-Accessors-and-Conversion-1"></a><a class="docs-heading-anchor-permalink" href="#Data-Accessors-and-Conversion" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{TimeSeriesData}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{TimeSeriesData}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">StatsAPI.nobs(d::AbstractMacroData)</code></pre><p>Return the number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L286-L290">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.nvars"><a class="docstring-binding" href="#MacroEconometricModels.nvars"><code>MacroEconometricModels.nvars</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nvars(d::AbstractMacroData)</code></pre><p>Return the number of variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L295-L299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.varnames"><a class="docstring-binding" href="#MacroEconometricModels.varnames"><code>MacroEconometricModels.varnames</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">varnames(d::AbstractMacroData)</code></pre><p>Return variable names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L304-L308">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.frequency"><a class="docstring-binding" href="#MacroEconometricModels.frequency"><code>MacroEconometricModels.frequency</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">frequency(d::TimeSeriesData)
frequency(d::PanelData)</code></pre><p>Return the data frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L311-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.time_index"><a class="docstring-binding" href="#MacroEconometricModels.time_index"><code>MacroEconometricModels.time_index</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">time_index(d::TimeSeriesData)</code></pre><p>Return the integer time index vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L320-L324">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.obs_id"><a class="docstring-binding" href="#MacroEconometricModels.obs_id"><code>MacroEconometricModels.obs_id</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">obs_id(d::CrossSectionData)</code></pre><p>Return the observation identifier vector.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L334-L338">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.desc"><a class="docstring-binding" href="#MacroEconometricModels.desc"><code>MacroEconometricModels.desc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">desc(d::AbstractMacroData) -&gt; String</code></pre><p>Return the dataset description. Returns <code>&quot;&quot;</code> if no description has been set.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData(randn(100, 3); desc=&quot;US macro quarterly data&quot;)
desc(d)  # &quot;US macro quarterly data&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L341-L351">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.vardesc"><a class="docstring-binding" href="#MacroEconometricModels.vardesc"><code>MacroEconometricModels.vardesc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">vardesc(d::AbstractMacroData) -&gt; Dict{String,String}</code></pre><p>Return the dictionary of per-variable descriptions.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData(randn(100, 2); varnames=[&quot;GDP&quot;,&quot;CPI&quot;],
    vardesc=Dict(&quot;GDP&quot; =&gt; &quot;Real GDP growth&quot;, &quot;CPI&quot; =&gt; &quot;Consumer prices&quot;))
vardesc(d)  # Dict(&quot;GDP&quot; =&gt; &quot;Real GDP growth&quot;, &quot;CPI&quot; =&gt; &quot;Consumer prices&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L354-L365">source</a></section><section><div><pre><code class="language-julia hljs">vardesc(d::AbstractMacroData, name::String) -&gt; String</code></pre><p>Return the description for variable <code>name</code>. Throws <code>ArgumentError</code> if no description exists for that variable.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">vardesc(d, &quot;GDP&quot;)  # &quot;Real GDP growth&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L368-L378">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.rename_vars!"><a class="docstring-binding" href="#MacroEconometricModels.rename_vars!"><code>MacroEconometricModels.rename_vars!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">rename_vars!(d::AbstractMacroData, old =&gt; new)
rename_vars!(d::AbstractMacroData, names::Vector{String})</code></pre><p>Rename variables in a data container. With a <code>Pair</code>, renames a single variable. With a <code>Vector{String}</code>, replaces all variable names. Also updates <code>vardesc</code> keys.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L458-L464">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.set_time_index!"><a class="docstring-binding" href="#MacroEconometricModels.set_time_index!"><code>MacroEconometricModels.set_time_index!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_time_index!(d::TimeSeriesData, idx::Vector{Int})</code></pre><p>Set the time index for a TimeSeriesData container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L532-L536">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.set_obs_id!"><a class="docstring-binding" href="#MacroEconometricModels.set_obs_id!"><code>MacroEconometricModels.set_obs_id!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_obs_id!(d::CrossSectionData, ids::Vector{Int})</code></pre><p>Set observation identifiers for a CrossSectionData container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L543-L547">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.set_desc!"><a class="docstring-binding" href="#MacroEconometricModels.set_desc!"><code>MacroEconometricModels.set_desc!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_desc!(d::AbstractMacroData, text::String)</code></pre><p>Set the dataset description.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData(randn(100, 3))
set_desc!(d, &quot;US macroeconomic quarterly data 1959-2024&quot;)
desc(d)  # &quot;US macroeconomic quarterly data 1959-2024&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L580-L591">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.set_vardesc!"><a class="docstring-binding" href="#MacroEconometricModels.set_vardesc!"><code>MacroEconometricModels.set_vardesc!</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">set_vardesc!(d::AbstractMacroData, name::String, text::String)</code></pre><p>Set the description for a single variable. The variable must exist in the data.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">d = TimeSeriesData(randn(100, 2); varnames=[&quot;GDP&quot;, &quot;CPI&quot;])
set_vardesc!(d, &quot;GDP&quot;, &quot;Real Gross Domestic Product, seasonally adjusted&quot;)
set_vardesc!(d, &quot;CPI&quot;, &quot;Consumer Price Index for All Urban Consumers&quot;)
vardesc(d, &quot;GDP&quot;)  # &quot;Real Gross Domestic Product, seasonally adjusted&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L597-L609">source</a></section><section><div><pre><code class="language-julia hljs">set_vardesc!(d::AbstractMacroData, descriptions::Dict{String,String})</code></pre><p>Set descriptions for multiple variables at once. All keys must be valid variable names.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">set_vardesc!(d, Dict(&quot;GDP&quot; =&gt; &quot;Real GDP&quot;, &quot;CPI&quot; =&gt; &quot;Consumer prices&quot;))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/types.jl#L617-L626">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.to_matrix"><a class="docstring-binding" href="#MacroEconometricModels.to_matrix"><code>MacroEconometricModels.to_matrix</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_matrix(d::TimeSeriesData) -&gt; Matrix</code></pre><p>Return the raw data matrix from a TimeSeriesData container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/convert.jl#L30-L34">source</a></section><section><div><pre><code class="language-julia hljs">to_matrix(d::PanelData) -&gt; Matrix</code></pre><p>Return the raw stacked data matrix from a PanelData container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/convert.jl#L37-L41">source</a></section><section><div><pre><code class="language-julia hljs">to_matrix(d::CrossSectionData) -&gt; Matrix</code></pre><p>Return the raw data matrix from a CrossSectionData container.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/convert.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.to_vector"><a class="docstring-binding" href="#MacroEconometricModels.to_vector"><code>MacroEconometricModels.to_vector</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_vector(d::TimeSeriesData) -&gt; Vector</code></pre><p>Return the data as a vector (requires exactly 1 variable).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/convert.jl#L51-L55">source</a></section><section><div><pre><code class="language-julia hljs">to_vector(d::TimeSeriesData, var::Int) -&gt; Vector</code></pre><p>Return a single column by index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/convert.jl#L62-L66">source</a></section><section><div><pre><code class="language-julia hljs">to_vector(d::TimeSeriesData, var::String) -&gt; Vector</code></pre><p>Return a single column by name.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/convert.jl#L72-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.load_example"><a class="docstring-binding" href="#MacroEconometricModels.load_example"><code>MacroEconometricModels.load_example</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">load_example(name::Symbol) -&gt; AbstractMacroData</code></pre><p>Load a built-in example dataset.</p><p><strong>Available Datasets</strong></p><ul><li><code>:fred_md</code> — FRED-MD Monthly Database, January 2026 vintage (126 variables × 804 months) → <code>TimeSeriesData</code></li><li><code>:fred_qd</code> — FRED-QD Quarterly Database, January 2026 vintage (245 variables × 268 quarters) → <code>TimeSeriesData</code></li><li><code>:pwt</code> — Penn World Table 10.01, 38 OECD countries (42 variables × 74 years, 1950–2023) → <code>PanelData</code></li></ul><p>For time series datasets, the returned <code>TimeSeriesData</code> includes variable names, transformation codes, frequency, per-variable descriptions (via <code>vardesc</code>), dataset description (via <code>desc</code>), and bibliographic references (via <code>refs</code>).</p><p>For panel datasets, the returned <code>PanelData</code> includes country identifiers as groups, year identifiers as time index, variable descriptions, and references.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Load FRED-MD
md = load_example(:fred_md)
nobs(md)       # 804
nvars(md)      # 126
desc(md)       # &quot;FRED-MD Monthly Database, January 2026 Vintage (McCracken &amp; Ng 2016)&quot;
vardesc(md, &quot;INDPRO&quot;)  # &quot;IP Index&quot;
refs(md)       # McCracken &amp; Ng (2016)

# Apply recommended transformations
md_transformed = apply_tcode(md, md.tcode)

# Load FRED-QD
qd = load_example(:fred_qd)

# Load Penn World Table (panel data)
pwt = load_example(:pwt)
nobs(pwt)         # 2812 (38 countries × 74 years)
nvars(pwt)        # 42
ngroups(pwt)      # 38
groups(pwt)       # [&quot;AUS&quot;, &quot;AUT&quot;, ..., &quot;USA&quot;]
isbalanced(pwt)   # true
g = group_data(pwt, &quot;USA&quot;)  # extract single country as TimeSeriesData
refs(pwt)         # Feenstra, Inklaar &amp; Timmer (2015)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/examples.jl#L46-L89">source</a></section></details></article><hr/><h2 id="Time-Series-Filters"><a class="docs-heading-anchor" href="#Time-Series-Filters">Time Series Filters</a><a id="Time-Series-Filters-1"></a><a class="docs-heading-anchor-permalink" href="#Time-Series-Filters" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels.hp_filter"><a class="docstring-binding" href="#MacroEconometricModels.hp_filter"><code>MacroEconometricModels.hp_filter</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hp_filter(y::AbstractVector; lambda=1600.0) -&gt; HPFilterResult</code></pre><p>Apply the Hodrick-Prescott filter to decompose time series <code>y</code> into trend and cycle.</p><p>Solves the optimization problem:</p><p class="math-container">\[\min_\tau \sum_{t=1}^T (y_t - \tau_t)^2 + \lambda \sum_{t=2}^{T-1} (\tau_{t+1} - 2\tau_t + \tau_{t-1})^2\]</p><p>Implementation uses a sparse pentadiagonal Cholesky factorization for O(T) cost.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Time series data (length ≥ 3)</li></ul><p><strong>Keywords</strong></p><ul><li><code>lambda::Real=1600.0</code>: Smoothing parameter. Common values: 6.25 (annual), 1600 (quarterly, default), 129600 (monthly)</li></ul><p><strong>Returns</strong></p><ul><li><code>HPFilterResult{T}</code> with fields <code>trend</code>, <code>cycle</code>, <code>lambda</code>, <code>T_obs</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))
result = hp_filter(y)
result = hp_filter(y; lambda=6.25)  # annual data</code></pre><p><strong>References</strong></p><ul><li>Hodrick, R. J., &amp; Prescott, E. C. (1997). <em>JMCB</em> 29(1): 1–16.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/filters/hp.jl#L84-L115">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.hamilton_filter"><a class="docstring-binding" href="#MacroEconometricModels.hamilton_filter"><code>MacroEconometricModels.hamilton_filter</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">hamilton_filter(y::AbstractVector; h=8, p=4) -&gt; HamiltonFilterResult</code></pre><p>Apply the Hamilton (2018) regression filter for trend-cycle decomposition.</p><p>Regresses <span>$y_{t+h}$</span> on <span>$[1, y_t, y_{t-1}, \ldots, y_{t-p+1}]$</span> by OLS. The residuals form the cyclical component and the fitted values form the trend.</p><p>The filter loses <code>h + p - 1</code> observations at the start of the sample.</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Time series data</li></ul><p><strong>Keywords</strong></p><ul><li><code>h::Int=8</code>: Forecast horizon (default 8 for quarterly data = 2 years)</li><li><code>p::Int=4</code>: Number of lags in the regression (default 4 for quarterly data)</li></ul><p><strong>Returns</strong></p><ul><li><code>HamiltonFilterResult{T}</code> with fields <code>trend</code>, <code>cycle</code>, <code>beta</code>, <code>h</code>, <code>p</code>, <code>T_obs</code>, <code>valid_range</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))
result = hamilton_filter(y)                 # quarterly defaults
result = hamilton_filter(y; h=24, p=12)     # monthly data (2-year horizon)</code></pre><p><strong>References</strong></p><ul><li>Hamilton, J. D. (2018). <em>REStat</em> 100(5): 831–843.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/filters/hamilton.jl#L34-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.beveridge_nelson"><a class="docstring-binding" href="#MacroEconometricModels.beveridge_nelson"><code>MacroEconometricModels.beveridge_nelson</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">beveridge_nelson(y::AbstractVector; method=:arima, p=:auto, q=:auto, max_terms=500, cycle_order=2) -&gt; BeveridgeNelsonResult</code></pre><p>Compute the Beveridge-Nelson decomposition of time series <code>y</code>.</p><p>Assumes <code>y</code> is I(1) and decomposes it into:</p><p class="math-container">\[y_t = \tau_t + c_t\]</p><p>where <span>$\tau_t$</span> is a random walk with drift (permanent component) and <span>$c_t$</span> is a stationary transitory component.</p><p><strong>Methods</strong></p><ul><li><code>:arima</code> (default): Classic BN via ARIMA representation (Beveridge &amp; Nelson, 1981)</li><li><code>:statespace</code>: Correlated UC model via MLE + Kalman smoother (Morley, Nelson &amp; Zivot, 2003)</li></ul><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Time series data (assumed I(1), length ≥ 10)</li></ul><p><strong>Keywords</strong></p><ul><li><code>method::Symbol=:arima</code>: Decomposition method</li><li><code>p</code>: AR order for ARMA model of Δy (method=:arima). <code>:auto</code> uses <code>auto_arima</code></li><li><code>q</code>: MA order for ARMA model of Δy (method=:arima). <code>:auto</code> uses <code>auto_arima</code></li><li><code>max_terms::Int=500</code>: Maximum ψ-weights for MA(∞) truncation (method=:arima)</li><li><code>cycle_order::Int=2</code>: AR order for cyclical component (method=:statespace, 1 or 2)</li></ul><p><strong>Returns</strong></p><ul><li><code>BeveridgeNelsonResult{T}</code> with fields <code>permanent</code>, <code>transitory</code>, <code>drift</code>, <code>long_run_multiplier</code>, <code>arima_order</code>, <code>T_obs</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs"># Classic ARIMA-based BN decomposition
y = cumsum(randn(200)) + 0.3 * sin.(2π * (1:200) / 20)
result = beveridge_nelson(y)
result = beveridge_nelson(y; p=2, q=1)  # manual ARMA order

# Morley (2002) correlated UC model
result = beveridge_nelson(y; method=:statespace)
result = beveridge_nelson(y; method=:statespace, cycle_order=1)</code></pre><p><strong>References</strong></p><ul><li>Beveridge, S., &amp; Nelson, C. R. (1981). <em>JME</em> 7(2): 151–174.</li><li>Morley, J. C., Nelson, C. R., &amp; Zivot, E. (2003). <em>REStat</em> 85(2): 235–243.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/filters/beveridge_nelson.jl#L35-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.baxter_king"><a class="docstring-binding" href="#MacroEconometricModels.baxter_king"><code>MacroEconometricModels.baxter_king</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">baxter_king(y::AbstractVector; pl=6, pu=32, K=12) -&gt; BaxterKingResult</code></pre><p>Apply the Baxter-King band-pass filter to isolate business cycle frequencies.</p><p>Computes symmetric moving average weights that approximate the ideal band-pass filter for periods between <code>pl</code> and <code>pu</code>. The filter is constrained to sum to zero (removing stochastic trends).</p><p>Loses <code>K</code> observations at each end of the sample (2K total).</p><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Time series data (length &gt; 2K)</li></ul><p><strong>Keywords</strong></p><ul><li><code>pl::Int=6</code>: Minimum period of oscillation to pass (quarterly: 6 = 1.5 years)</li><li><code>pu::Int=32</code>: Maximum period of oscillation to pass (quarterly: 32 = 8 years)</li><li><code>K::Int=12</code>: Truncation length (number of leads/lags in the moving average)</li></ul><p><strong>Returns</strong></p><ul><li><code>BaxterKingResult{T}</code> with fields <code>cycle</code>, <code>trend</code>, <code>weights</code>, <code>pl</code>, <code>pu</code>, <code>K</code>, <code>T_obs</code>, <code>valid_range</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))
result = baxter_king(y)                    # quarterly defaults (6-32 quarters)
result = baxter_king(y; pl=2, pu=8, K=6)  # annual data (2-8 years)</code></pre><p><strong>References</strong></p><ul><li>Baxter, M., &amp; King, R. G. (1999). <em>REStat</em> 81(4): 575–593.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/filters/baxter_king.jl#L34-L66">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.boosted_hp"><a class="docstring-binding" href="#MacroEconometricModels.boosted_hp"><code>MacroEconometricModels.boosted_hp</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">boosted_hp(y::AbstractVector; lambda=1600.0, stopping=:BIC, max_iter=100, sig_p=0.05) -&gt; BoostedHPResult</code></pre><p>Apply the boosted HP filter (Phillips &amp; Shi 2021) for improved trend estimation.</p><p>Iteratively re-filters the cyclical component of the standard HP filter. At each iteration, the cycle is decomposed again and the newly estimated &quot;trend of the cycle&quot; is added back to the overall trend.</p><p><strong>Stopping criteria</strong></p><ul><li><code>:ADF</code> — Stop when the ADF test rejects the null of a unit root in the cycle at significance level <code>sig_p</code> (recommended for detecting stationarity)</li><li><code>:BIC</code> — Stop when the Phillips-Shi information criterion increases (balances variance reduction against effective degrees of freedom)</li><li><code>:fixed</code> — Run all <code>max_iter</code> iterations</li></ul><p><strong>Arguments</strong></p><ul><li><code>y::AbstractVector</code>: Time series data (length ≥ 3)</li></ul><p><strong>Keywords</strong></p><ul><li><code>lambda::Real=1600.0</code>: HP smoothing parameter</li><li><code>stopping::Symbol=:BIC</code>: Stopping criterion (<code>:ADF</code>, <code>:BIC</code>, or <code>:fixed</code>)</li><li><code>max_iter::Int=100</code>: Maximum number of boosting iterations</li><li><code>sig_p::Real=0.05</code>: Significance level for ADF stopping criterion</li></ul><p><strong>Returns</strong></p><ul><li><code>BoostedHPResult{T}</code> with fields <code>trend</code>, <code>cycle</code>, <code>lambda</code>, <code>iterations</code>, <code>stopping</code>, <code>bic_path</code>, <code>adf_pvalues</code>, <code>T_obs</code></li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))
result = boosted_hp(y)                              # BIC stopping (default)
result = boosted_hp(y; stopping=:ADF, sig_p=0.05)   # ADF stopping
result = boosted_hp(y; stopping=:fixed, max_iter=5)  # fixed iterations</code></pre><p><strong>References</strong></p><ul><li>Phillips, P. C. B., &amp; Shi, Z. (2021). <em>IER</em> 62(2): 521–570.</li><li>Mei, Z., Phillips, P. C. B., &amp; Shi, Z. (2024). <em>JAE</em> 39(7): 1260–1281.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/filters/boosted_hp.jl#L39-L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.trend"><a class="docstring-binding" href="#MacroEconometricModels.trend"><code>MacroEconometricModels.trend</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">trend(result::AbstractFilterResult) -&gt; Vector</code></pre><p>Return the trend component from a filter result. For <code>BeveridgeNelsonResult</code>, returns the permanent component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/filters/types.jl#L178-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.cycle"><a class="docstring-binding" href="#MacroEconometricModels.cycle"><code>MacroEconometricModels.cycle</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cycle(result::AbstractFilterResult) -&gt; Vector</code></pre><p>Return the cyclical component from a filter result. For <code>BeveridgeNelsonResult</code>, returns the transitory component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/filters/types.jl#L190-L195">source</a></section></details></article><hr/><h2 id="ARIMA-Models"><a class="docs-heading-anchor" href="#ARIMA-Models">ARIMA Models</a><a id="ARIMA-Models-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMA-Models" title="Permalink"></a></h2><h3 id="Estimation"><a class="docs-heading-anchor" href="#Estimation">Estimation</a><a id="Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Estimation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_ar"><a class="docstring-binding" href="#MacroEconometricModels.estimate_ar"><code>MacroEconometricModels.estimate_ar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_ar(y, p; method=:ols, include_intercept=true) -&gt; ARModel</code></pre><p>Estimate AR(p) model: yₜ = c + φ₁yₜ₋₁ + ... + φₚyₜ₋ₚ + εₜ</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: AR order (must be ≥ 1)</li><li><code>method</code>: Estimation method (:ols or :mle)</li><li><code>include_intercept</code>: Whether to include constant term</li></ul><p><strong>Returns</strong></p><p><code>ARModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
model = estimate_ar(y, 2)
println(model.phi)  # AR coefficients</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/estimation.jl#L372-L392">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_ma"><a class="docstring-binding" href="#MacroEconometricModels.estimate_ma"><code>MacroEconometricModels.estimate_ma</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_ma(y, q; method=:css_mle, include_intercept=true, max_iter=500) -&gt; MAModel</code></pre><p>Estimate MA(q) model: yₜ = c + εₜ + θ₁εₜ₋₁ + ... + θqεₜ₋q</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>q</code>: MA order (must be ≥ 1)</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term</li><li><code>max_iter</code>: Maximum optimization iterations</li></ul><p><strong>Returns</strong></p><p><code>MAModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
model = estimate_ma(y, 1)
println(model.theta)  # MA coefficient</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/estimation.jl#L463-L484">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_arma"><a class="docstring-binding" href="#MacroEconometricModels.estimate_arma"><code>MacroEconometricModels.estimate_arma</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_arma(y, p, q; method=:css_mle, include_intercept=true, max_iter=500) -&gt; ARMAModel</code></pre><p>Estimate ARMA(p,q) model: yₜ = c + φ₁yₜ₋₁ + ... + φₚyₜ₋ₚ + εₜ + θ₁εₜ₋₁ + ... + θqεₜ₋q</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: AR order</li><li><code>q</code>: MA order</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term</li><li><code>max_iter</code>: Maximum optimization iterations</li></ul><p><strong>Returns</strong></p><p><code>ARMAModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
model = estimate_arma(y, 1, 1)
println(&quot;AR: &quot;, model.phi, &quot; MA: &quot;, model.theta)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/estimation.jl#L502-L525">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_arima"><a class="docstring-binding" href="#MacroEconometricModels.estimate_arima"><code>MacroEconometricModels.estimate_arima</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_arima(y, p, d, q; method=:css_mle, include_intercept=true, max_iter=500) -&gt; ARIMAModel</code></pre><p>Estimate ARIMA(p,d,q) model by differencing d times and fitting ARMA(p,q).</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: AR order</li><li><code>d</code>: Integration order (number of differences)</li><li><code>q</code>: MA order</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term (on differenced series)</li><li><code>max_iter</code>: Maximum optimization iterations</li></ul><p><strong>Returns</strong></p><p><code>ARIMAModel</code> with estimated coefficients and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk
model = estimate_arima(y, 1, 1, 0)  # ARIMA(1,1,0)
println(model.phi)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/estimation.jl#L543-L566">source</a></section></details></article><h3 id="Forecasting"><a class="docs-heading-anchor" href="#Forecasting">Forecasting</a><a id="Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Forecasting" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_psi_weights-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_psi_weights-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_psi_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_compute_psi_weights(phi, theta, h) -&gt; Vector{T}</code></pre><p>Compute ψ-weights for the MA(∞) representation of an ARMA process.</p><p>The ARMA(p,q) process can be written as: yₜ = μ + Σⱼ₌₀^∞ ψⱼ εₜ₋ⱼ</p><p>where ψ₀ = 1 and ψⱼ follows the recursion: ψⱼ = φ₁ψⱼ₋₁ + ... + φₚψⱼ₋ₚ + θⱼ</p><p>Returns <a href="excludes ψ₀ = 1">ψ₁, ψ₂, ..., ψₕ</a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L49-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._confidence_band-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T"><a class="docstring-binding" href="#MacroEconometricModels._confidence_band-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T}} where T"><code>MacroEconometricModels._confidence_band</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_confidence_band(forecasts, se, conf_level)</code></pre><p>Compute symmetric confidence interval bounds from forecasts, standard errors, and a confidence level.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L34-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._forecast_arma-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T, Vector{T}, Vector{T}, T, Int64, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._forecast_arma-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, T, Vector{T}, Vector{T}, T, Int64, T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._forecast_arma</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_forecast_arma(y, resid, c, phi, theta, sigma2, h, conf_level) -&gt; ARIMAForecast</code></pre><p>Unified point forecast + CI computation for any ARMA(p,q) model. AR models pass <code>theta=T[]</code>, MA models pass <code>phi=T[]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L111-L116">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._forecast_variance-Union{Tuple{T}, Tuple{T, Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._forecast_variance-Union{Tuple{T}, Tuple{T, Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._forecast_variance</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_forecast_variance(sigma2, psi, h) -&gt; Vector{T}</code></pre><p>Compute h-step ahead forecast variance.</p><p>Var(eₜ₊ₕ) = σ² (1 + ψ₁² + ψ₂² + ... + ψₕ₋₁²)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L87-L93">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._integrate_forecasts-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._integrate_forecasts-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._integrate_forecasts</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_integrate_forecasts(y, fc_diff, d) -&gt; Vector{T}</code></pre><p>Integrate d-differenced forecasts back to original scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L208-L212">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._integrate_se-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._integrate_se-Union{Tuple{T}, Tuple{Vector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._integrate_se</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_integrate_se(se_diff, d) -&gt; Vector{T}</code></pre><p>Approximate standard errors after integration.</p><p>For d-fold integration, the variance grows roughly as h^d. This is a conservative approximation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L247-L254">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARIMAModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARIMAModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::ARIMAModel, h; conf_level=0.95) -&gt; ARIMAForecast</code></pre><p>Compute h-step ahead forecasts with confidence intervals for ARIMA model. Forecasts are computed on the differenced series and then integrated back to the original scale.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L186-L192">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARMAModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARMAModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::ARMAModel, h; conf_level=0.95) -&gt; ARIMAForecast</code></pre><p>Compute h-step ahead forecasts with confidence intervals for ARMA model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L176-L180">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::ARModel, h; conf_level=0.95) -&gt; ARIMAForecast</code></pre><p>Compute h-step ahead forecasts with confidence intervals for AR model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L156-L160">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{MAModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{MAModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::MAModel, h; conf_level=0.95) -&gt; ARIMAForecast</code></pre><p>Compute h-step ahead forecasts with confidence intervals for MA model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L166-L170">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict-Tuple{AbstractARIMAModel, Int64}"><a class="docstring-binding" href="#StatsAPI.predict-Tuple{AbstractARIMAModel, Int64}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">predict(model::AbstractARIMAModel, h::Int) -&gt; Vector{T}</code></pre><p>Return h-step ahead point forecasts (without confidence intervals).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L275-L279">source</a></section></details></article><h3 id="Order-Selection"><a class="docs-heading-anchor" href="#Order-Selection">Order Selection</a><a id="Order-Selection-1"></a><a class="docs-heading-anchor-permalink" href="#Order-Selection" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.select_arima_order"><a class="docstring-binding" href="#MacroEconometricModels.select_arima_order"><code>MacroEconometricModels.select_arima_order</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">select_arima_order(y, max_p, max_q; criterion=:bic, d=0, method=:css_mle, include_intercept=true)</code></pre><p>Automatically select ARMA/ARIMA order via grid search over information criteria.</p><p>Searches over p ∈ 0:max<em>p and q ∈ 0:max</em>q, fits each model, and selects the order that minimizes the specified information criterion.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>max_p</code>: Maximum AR order to consider</li><li><code>max_q</code>: Maximum MA order to consider</li><li><code>criterion</code>: Selection criterion (:aic or :bic, default :bic)</li><li><code>d</code>: Integration order for ARIMA (default 0 = ARMA)</li><li><code>method</code>: Estimation method (:css, :mle, or :css_mle)</li><li><code>include_intercept</code>: Whether to include constant term</li></ul><p><strong>Returns</strong></p><p><code>ARIMAOrderSelection</code> with best orders, IC matrices, and fitted models.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)
result = select_arima_order(y, 3, 3; criterion=:bic)
println(&quot;Best order: p=$(result.best_p_bic), q=$(result.best_q_bic)&quot;)
best_model = result.best_model_bic</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/selection.jl#L29-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.auto_arima"><a class="docstring-binding" href="#MacroEconometricModels.auto_arima"><code>MacroEconometricModels.auto_arima</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">auto_arima(y; max_p=5, max_q=5, max_d=2, criterion=:bic, method=:css_mle)</code></pre><p>Automatically select and fit the best ARIMA model.</p><p>Performs order selection over p, d, and q using the specified criterion. For integration order d, uses unit root test heuristics.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>max_p</code>: Maximum AR order (default 5)</li><li><code>max_q</code>: Maximum MA order (default 5)</li><li><code>max_d</code>: Maximum integration order (default 2)</li><li><code>criterion</code>: Selection criterion (:aic or :bic)</li><li><code>method</code>: Estimation method</li></ul><p><strong>Returns</strong></p><p>Best fitted ARIMAModel or ARMAModel.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))
model = auto_arima(y)
println(model)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/selection.jl#L134-L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ic_table"><a class="docstring-binding" href="#MacroEconometricModels.ic_table"><code>MacroEconometricModels.ic_table</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ic_table(result::ARIMAOrderSelection; criterion=:bic)</code></pre><p>Return a formatted table of IC values for printing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/selection.jl#L209-L213">source</a></section></details></article><h3 id="ARIMA-Accessors"><a class="docs-heading-anchor" href="#ARIMA-Accessors">ARIMA Accessors</a><a id="ARIMA-Accessors-1"></a><a class="docs-heading-anchor-permalink" href="#ARIMA-Accessors" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ar_order"><a class="docstring-binding" href="#MacroEconometricModels.ar_order"><code>MacroEconometricModels.ar_order</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return AR order p.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/types.jl#L271">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ma_order"><a class="docstring-binding" href="#MacroEconometricModels.ma_order"><code>MacroEconometricModels.ma_order</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return MA order q.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/types.jl#L277">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.diff_order"><a class="docstring-binding" href="#MacroEconometricModels.diff_order"><code>MacroEconometricModels.diff_order</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return integration order d.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/types.jl#L283">source</a></section></details></article><hr/><h2 id="VAR-Estimation"><a class="docs-heading-anchor" href="#VAR-Estimation">VAR Estimation</a><a id="VAR-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#VAR-Estimation" title="Permalink"></a></h2><h3 id="Frequentist-Estimation"><a class="docs-heading-anchor" href="#Frequentist-Estimation">Frequentist Estimation</a><a id="Frequentist-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Frequentist-Estimation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_var"><a class="docstring-binding" href="#MacroEconometricModels.estimate_var"><code>MacroEconometricModels.estimate_var</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_var(Y::AbstractMatrix{T}, p::Int; check_stability::Bool=true) -&gt; VARModel{T}</code></pre><p>Estimate VAR(p) via OLS: Yₜ = c + A₁Yₜ₋₁ + ... + AₚYₜ₋ₚ + uₜ.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n)</li><li><code>p</code>: Number of lags</li><li><code>check_stability</code>: If true (default), warns if estimated VAR is non-stationary</li></ul><p><strong>Returns</strong></p><p><code>VARModel</code> with estimated coefficients, residuals, covariance matrix, and information criteria.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/estimation.jl#L29-L41">source</a></section><section><div><p>Estimate VAR from DataFrame. Use <code>vars</code> to select columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/estimation.jl#L84">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.select_lag_order"><a class="docstring-binding" href="#MacroEconometricModels.select_lag_order"><code>MacroEconometricModels.select_lag_order</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Select optimal lag order via information criterion (:aic, :bic, :hqic).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/estimation.jl#L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.vcov-Tuple{VARModel}"><a class="docstring-binding" href="#StatsAPI.vcov-Tuple{VARModel}"><code>StatsAPI.vcov</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Covariance of vectorized coefficients: Σ ⊗ (X&#39;X)⁻¹.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/estimation.jl#L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict"><a class="docstring-binding" href="#StatsAPI.predict"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>In-sample fitted values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/estimation.jl#L113">source</a></section><section><div><p>Out-of-sample forecasts for <code>steps</code> periods.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/estimation.jl#L116">source</a></section><section><div><p>Predicted values: F * Λ&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L158">source</a></section><section><div><p>Predicted values: F * Λ&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L313">source</a></section><section><div><p>Predicted values (common component).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L293">source</a></section><section><div><pre><code class="language-julia hljs">predict(model::AbstractARIMAModel, h::Int) -&gt; Vector{T}</code></pre><p>Return h-step ahead point forecasts (without confidence intervals).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arima/forecast.jl#L275-L279">source</a></section><section><div><p>Conditional variance series <span>$\hat{\sigma}^2_t$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L133">source</a></section><section><div><p>Conditional variance series <span>$\hat{\sigma}^2_t$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L207">source</a></section><section><div><p>Conditional variance series <span>$\hat{\sigma}^2_t$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L209">source</a></section><section><div><p>Conditional variance series <span>$\hat{\sigma}^2_t$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L211">source</a></section><section><div><p>Posterior mean volatility series <span>$\hat{\sigma}^2_t$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/sv/types.jl#L85">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.r2-Tuple{VARModel}"><a class="docstring-binding" href="#StatsAPI.r2-Tuple{VARModel}"><code>StatsAPI.r2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>R² for each equation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/estimation.jl#L137">source</a></section><section><div><p>R² for each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L167">source</a></section><section><div><p>R² for each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L322">source</a></section><section><div><p>R² for each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.loglikelihood"><a class="docstring-binding" href="#StatsAPI.loglikelihood"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Gaussian log-likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/estimation.jl#L143">source</a></section><section><div><p>Log-likelihood of the fitted model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L333">source</a></section><section><div><p>Maximized log-likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L136">source</a></section><section><div><p>Maximized log-likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L214">source</a></section><section><div><p>Maximized log-likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L216">source</a></section><section><div><p>Maximized log-likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.confint-Tuple{VARModel}"><a class="docstring-binding" href="#StatsAPI.confint-Tuple{VARModel}"><code>StatsAPI.confint</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Confidence intervals at given level (default 95%).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/estimation.jl#L151">source</a></section></details></article><h3 id="Bayesian-Estimation"><a class="docs-heading-anchor" href="#Bayesian-Estimation">Bayesian Estimation</a><a id="Bayesian-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#Bayesian-Estimation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_bvar"><a class="docstring-binding" href="#MacroEconometricModels.estimate_bvar"><code>MacroEconometricModels.estimate_bvar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_bvar(Y, p; n_draws=1000, sampler=:direct, burnin=0, thin=1,
              prior=:normal, hyper=nothing) -&gt; BVARPosterior</code></pre><p>Estimate Bayesian VAR via conjugate Normal-Inverse-Wishart posterior.</p><p><strong>Model</strong></p><pre><code class="nohighlight hljs">Y = X B + E,    E ~ MN(0, Σ, I_T)
Prior: Σ ~ IW(ν₀, S₀),  vec(B)|Σ ~ N(b₀, Σ ⊗ V₀)</code></pre><p><strong>Samplers</strong></p><ul><li><code>:direct</code> (default) — i.i.d. draws from analytical posterior. <code>burnin</code> and <code>thin</code> are ignored.</li><li><code>:gibbs</code> — Standard two-block Gibbs sampler. <code>burnin</code> defaults to 200 if not specified.</li></ul><p><strong>Arguments</strong></p><ul><li><code>Y::AbstractMatrix</code>: T × n data matrix</li><li><code>p::Int</code>: Number of lags</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>n_draws::Int=1000</code>: Number of posterior draws to keep</li><li><code>sampler::Symbol=:direct</code>: Sampling algorithm (<code>:direct</code> or <code>:gibbs</code>)</li><li><code>burnin::Int=0</code>: Burnin period (only for <code>:gibbs</code>; defaults to 200 when sampler=:gibbs and burnin=0)</li><li><code>thin::Int=1</code>: Thinning interval (only for <code>:gibbs</code>)</li><li><code>prior::Symbol=:normal</code>: Prior type (<code>:normal</code> or <code>:minnesota</code>)</li><li><code>hyper::Union{Nothing,MinnesotaHyperparameters}=nothing</code>: Minnesota hyperparameters. When <code>prior=:minnesota</code> and <code>hyper=nothing</code>, tau is automatically optimized via marginal likelihood maximization (Giannone, Lenza &amp; Primiceri 2015). Pass an explicit <code>MinnesotaHyperparameters(...)</code> to use fixed values instead.</li></ul><p><strong>Returns</strong></p><p><code>BVARPosterior{T}</code> containing coefficient and covariance draws.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Y = randn(200, 3)
post = estimate_bvar(Y, 2; n_draws=1000)
post_mn = estimate_bvar(Y, 2; prior=:minnesota, n_draws=500)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/bvar/estimation.jl#L31-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.posterior_mean_model"><a class="docstring-binding" href="#MacroEconometricModels.posterior_mean_model"><code>MacroEconometricModels.posterior_mean_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>VARModel with posterior mean parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/bvar/estimation.jl#L312">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.posterior_median_model"><a class="docstring-binding" href="#MacroEconometricModels.posterior_median_model"><code>MacroEconometricModels.posterior_median_model</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>VARModel with posterior median parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/bvar/estimation.jl#L320">source</a></section></details></article><h3 id="Prior-Specification"><a class="docs-heading-anchor" href="#Prior-Specification">Prior Specification</a><a id="Prior-Specification-1"></a><a class="docs-heading-anchor-permalink" href="#Prior-Specification" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.gen_dummy_obs-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, MinnesotaHyperparameters}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.gen_dummy_obs-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, MinnesotaHyperparameters}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.gen_dummy_obs</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gen_dummy_obs(Y, p, hyper) -&gt; (Y_dummy, X_dummy)</code></pre><p>Generate Minnesota prior dummy observations. Hyperparameters: tau (tightness), decay, lambda (sum-of-coef), mu (co-persistence), omega.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/bvar/priors.jl#L29-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.log_marginal_likelihood-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, MinnesotaHyperparameters}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.log_marginal_likelihood-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, MinnesotaHyperparameters}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.log_marginal_likelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">log_marginal_likelihood(Y, p, hyper) -&gt; T</code></pre><p>Closed-form log marginal likelihood for BVAR with Minnesota prior.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/bvar/priors.jl#L113-L117">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.optimize_hyperparameters-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.optimize_hyperparameters-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.optimize_hyperparameters</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Optimize tau via grid search on marginal likelihood.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/bvar/priors.jl#L152">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.optimize_hyperparameters_full-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.optimize_hyperparameters_full-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.optimize_hyperparameters_full</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Full grid search over tau, lambda, mu.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/bvar/priors.jl#L168">source</a></section></details></article><h3 id="VECM-Estimation"><a class="docs-heading-anchor" href="#VECM-Estimation">VECM Estimation</a><a id="VECM-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#VECM-Estimation" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_vecm"><a class="docstring-binding" href="#MacroEconometricModels.estimate_vecm"><code>MacroEconometricModels.estimate_vecm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_vecm(Y, p; rank=:auto, deterministic=:constant, method=:johansen, significance=0.05)</code></pre><p>Estimate a Vector Error Correction Model.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n) in levels</li><li><code>p</code>: Underlying VAR order (VECM has p-1 lagged differences)</li><li><code>rank</code>: Cointegrating rank; <code>:auto</code> (default) selects via Johansen trace test, or specify an integer</li><li><code>deterministic</code>: <code>:none</code>, <code>:constant</code> (default), or <code>:trend</code></li><li><code>method</code>: <code>:johansen</code> (default) or <code>:engle_granger</code> (bivariate, rank=1 only)</li><li><code>significance</code>: Significance level for automatic rank selection (default 0.05)</li></ul><p><strong>Returns</strong></p><p><code>VECMModel</code> with estimated α, β, Γ matrices, residuals, and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Y = cumsum(randn(200, 3), dims=1)
Y[:, 2] = Y[:, 1] + 0.1 * randn(200)
m = estimate_vecm(Y, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/vecm/estimation.jl#L29-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.to_var"><a class="docstring-binding" href="#MacroEconometricModels.to_var"><code>MacroEconometricModels.to_var</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">to_var(vecm::VECMModel) -&gt; VARModel</code></pre><p>Convert VECM to VAR in levels representation.</p><p>The VECM: ΔYₜ = ΠYₜ₋₁ + Σᵢ ΓᵢΔYₜ₋ᵢ + μ + uₜ maps to VAR: Yₜ = c + A₁Yₜ₋₁ + ... + AₚYₜ₋ₚ + uₜ</p><p>with:</p><ul><li>A₁ = Π + Iₙ + Γ₁</li><li>Aᵢ = Γᵢ - Γᵢ₋₁  for i = 2, ..., p-1</li><li>Aₚ = -Γₚ₋₁</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/vecm/estimation.jl#L234-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.select_vecm_rank"><a class="docstring-binding" href="#MacroEconometricModels.select_vecm_rank"><code>MacroEconometricModels.select_vecm_rank</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">select_vecm_rank(Y, p; criterion=:trace, significance=0.05) -&gt; Int</code></pre><p>Select cointegrating rank using the Johansen trace or max-eigenvalue test.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/vecm/estimation.jl#L207-L211">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.cointegrating_rank"><a class="docstring-binding" href="#MacroEconometricModels.cointegrating_rank"><code>MacroEconometricModels.cointegrating_rank</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">cointegrating_rank(m::VECMModel) -&gt; Int</code></pre><p>Return the cointegrating rank r of the VECM.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/vecm/types.jl#L85-L89">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.granger_causality_vecm"><a class="docstring-binding" href="#MacroEconometricModels.granger_causality_vecm"><code>MacroEconometricModels.granger_causality_vecm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">granger_causality_vecm(vecm, cause, effect) -&gt; VECMGrangerResult</code></pre><p>Test Granger causality from variable <code>cause</code> to variable <code>effect</code> in a VECM.</p><p>Three tests are computed:</p><ol><li><strong>Short-run</strong>: Wald test on Γ coefficients of the <code>cause</code> variable in the <code>effect</code> equation</li><li><strong>Long-run</strong>: Wald test on α coefficients in the <code>effect</code> equation (error correction channel)</li><li><strong>Strong</strong>: Joint test of both short-run and long-run</li></ol><p><strong>Arguments</strong></p><ul><li><code>vecm</code>: Estimated <code>VECMModel</code></li><li><code>cause</code>: Index of the causing variable</li><li><code>effect</code>: Index of the effect variable</li></ul><p><strong>Returns</strong></p><p><code>VECMGrangerResult</code> with test statistics, p-values, and degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/vecm/granger.jl#L25-L42">source</a></section></details></article><h3 id="VECM-Analysis-and-Forecasting"><a class="docs-heading-anchor" href="#VECM-Analysis-and-Forecasting">VECM Analysis and Forecasting</a><a id="VECM-Analysis-and-Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#VECM-Analysis-and-Forecasting" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.fevd-Union{Tuple{T}, Tuple{VECMModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.fevd-Union{Tuple{T}, Tuple{VECMModel{T}, Int64}} where T"><code>MacroEconometricModels.fevd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fevd(vecm::VECMModel, horizon; kwargs...) -&gt; FEVD</code></pre><p>Compute FEVD for a VECM by converting to VAR representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/vecm/analysis.jl#L35-L39">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.historical_decomposition-Union{Tuple{VECMModel{T}}, Tuple{T}, Tuple{VECMModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.historical_decomposition-Union{Tuple{VECMModel{T}}, Tuple{T}, Tuple{VECMModel{T}, Int64}} where T"><code>MacroEconometricModels.historical_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">historical_decomposition(vecm::VECMModel, horizon; kwargs...) -&gt; HistoricalDecomposition</code></pre><p>Compute historical decomposition for a VECM by converting to VAR representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/vecm/analysis.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.irf-Union{Tuple{T}, Tuple{VECMModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.irf-Union{Tuple{T}, Tuple{VECMModel{T}, Int64}} where T"><code>MacroEconometricModels.irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">irf(vecm::VECMModel, horizon; kwargs...) -&gt; ImpulseResponse</code></pre><p>Compute IRFs for a VECM by converting to VAR representation. All identification methods (Cholesky, sign, narrative, etc.) are supported.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/vecm/analysis.jl#L25-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{VECMModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{VECMModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(vecm::VECMModel, h; ci_method=:none, reps=500, conf_level=0.95) -&gt; VECMForecast</code></pre><p>Forecast from a VECM by iterating the VECM equations in levels.</p><p>Unlike VAR forecasting, this preserves the cointegrating relationships in the forecast path.</p><p><strong>Arguments</strong></p><ul><li><code>vecm</code>: Estimated VECM</li><li><code>h</code>: Forecast horizon</li><li><code>ci_method</code>: <code>:none</code> (default), <code>:bootstrap</code>, or <code>:simulation</code></li><li><code>reps</code>: Number of bootstrap/simulation replications (default 500)</li><li><code>conf_level</code>: Confidence level (default 0.95)</li></ul><p><strong>Returns</strong></p><p><code>VECMForecast</code> with level and difference forecasts, plus CIs if requested.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/vecm/forecast.jl#L25-L42">source</a></section></details></article><hr/><h2 id="Structural-Identification"><a class="docs-heading-anchor" href="#Structural-Identification">Structural Identification</a><a id="Structural-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Identification" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_Q-Union{Tuple{T}, Tuple{VARModel{T}, Symbol, Int64, Any, Any}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_Q-Union{Tuple{T}, Tuple{VARModel{T}, Symbol, Int64, Any, Any}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_Q</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_Q(model, method, horizon, check_func, narrative_check;
          max_draws=100, transition_var=nothing, regime_indicator=nothing)</code></pre><p>Compute identification matrix Q for structural VAR analysis.</p><p><strong>Methods</strong></p><ul><li><code>:cholesky</code> — Cholesky decomposition (recursive ordering)</li><li><code>:sign</code> — Sign restrictions (requires <code>check_func</code>)</li><li><code>:narrative</code> — Narrative restrictions (requires <code>check_func</code> and <code>narrative_check</code>)</li><li><code>:long_run</code> — Long-run restrictions (Blanchard-Quah)</li><li><code>:fastica</code> — FastICA (Hyvärinen 1999)</li><li><code>:jade</code> — JADE (Cardoso 1999)</li><li><code>:sobi</code> — SOBI (Belouchrani et al. 1997)</li><li><code>:dcov</code> — Distance covariance ICA (Matteson &amp; Tsay 2017)</li><li><code>:hsic</code> — HSIC independence ICA (Gretton et al. 2005)</li><li><code>:student_t</code> — Student-t ML (Lanne et al. 2017)</li><li><code>:mixture_normal</code> — Mixture of normals ML (Lanne et al. 2017)</li><li><code>:pml</code> — Pseudo-ML (Gouriéroux et al. 2017)</li><li><code>:skew_normal</code> — Skew-normal ML (Lanne &amp; Luoto 2020)</li><li><code>:nongaussian_ml</code> — Unified non-Gaussian ML dispatcher (default: Student-t)</li><li><code>:markov_switching</code> — Markov-switching heteroskedasticity (Lütkepohl &amp; Netšunajev 2017)</li><li><code>:garch</code> — GARCH-based heteroskedasticity (Normandin &amp; Phaneuf 2004)</li><li><code>:smooth_transition</code> — Smooth-transition heteroskedasticity (requires <code>transition_var</code>)</li><li><code>:external_volatility</code> — External volatility regimes (requires <code>regime_indicator</code>)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>max_draws::Int=100</code>: Maximum draws for sign/narrative identification</li><li><code>transition_var::Union{Nothing,AbstractVector}=nothing</code>: Transition variable for <code>:smooth_transition</code></li><li><code>regime_indicator::Union{Nothing,AbstractVector{Int}}=nothing</code>: Regime indicator for <code>:external_volatility</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/identification.jl#L208-L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_irf-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_irf-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_irf(model, Q, horizon) -&gt; Array{T,3}</code></pre><p>Compute IRFs for rotation matrix Q. Returns (horizon × n × n) array. IRF[h, i, j] = response of variable i to shock j at horizon h-1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/identification.jl#L48-L53">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_structural_shocks-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_structural_shocks-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_structural_shocks</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute structural shocks: εₜ = Q&#39;L⁻¹uₜ.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/identification.jl#L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.generate_Q-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.generate_Q-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.generate_Q</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Generate random orthogonal matrix via QR decomposition (Haar measure).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/identification.jl#L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_cholesky-Union{Tuple{VARModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identify_cholesky-Union{Tuple{VARModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identify_cholesky</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Identify via Cholesky decomposition (recursive ordering). Returns L where Σ = LL&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/identification.jl#L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_long_run-Union{Tuple{VARModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identify_long_run-Union{Tuple{VARModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identify_long_run</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Identify via long-run restrictions: long-run cumulative impact matrix is lower triangular.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/identification.jl#L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_narrative-Union{Tuple{T}, Tuple{VARModel{T}, Int64, Function, Function}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identify_narrative-Union{Tuple{T}, Tuple{VARModel{T}, Int64, Function, Function}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identify_narrative</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identify_narrative(model, horizon, sign_check, narrative_check; max_draws=1000)</code></pre><p>Combine sign and narrative restrictions. Returns (Q, irf, shocks).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/identification.jl#L170-L174">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_sign-Union{Tuple{T}, Tuple{VARModel{T}, Int64, Function}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identify_sign-Union{Tuple{T}, Tuple{VARModel{T}, Int64, Function}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identify_sign</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identify_sign(model, horizon, check_func; max_draws=1000, store_all=false)</code></pre><p>Find Q satisfying sign restrictions via random draws.</p><p>With <code>store_all=false</code> (default), returns <code>(Q, irf)</code> — the first valid rotation. With <code>store_all=true</code>, returns a <code>SignIdentifiedSet</code> containing ALL accepted rotations and their IRFs (Baumeister &amp; Hamilton, 2015).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/identification.jl#L82-L90">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.irf_bounds-Union{Tuple{SignIdentifiedSet{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.irf_bounds-Union{Tuple{SignIdentifiedSet{T}}, Tuple{T}} where T"><code>MacroEconometricModels.irf_bounds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">irf_bounds(s::SignIdentifiedSet{T}; quantiles=[0.16, 0.84]) -&gt; (lower, upper)</code></pre><p>Compute pointwise bounds (or quantile bands) over the identified set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/identification.jl#L133-L137">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.irf_median-Union{Tuple{SignIdentifiedSet{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.irf_median-Union{Tuple{SignIdentifiedSet{T}}, Tuple{T}} where T"><code>MacroEconometricModels.irf_median</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">irf_median(s::SignIdentifiedSet{T}) -&gt; Array{T,3}</code></pre><p>Compute pointwise median IRF over the identified set.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/identification.jl#L151-L155">source</a></section></details></article><h3 id="Mountford-Uhlig-(2009)-Penalty-Function"><a class="docs-heading-anchor" href="#Mountford-Uhlig-(2009)-Penalty-Function">Mountford-Uhlig (2009) Penalty Function</a><a id="Mountford-Uhlig-(2009)-Penalty-Function-1"></a><a class="docs-heading-anchor-permalink" href="#Mountford-Uhlig-(2009)-Penalty-Function" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.UhligSVARResult"><a class="docstring-binding" href="#MacroEconometricModels.UhligSVARResult"><code>MacroEconometricModels.UhligSVARResult</code></a> — <span class="docstring-category">Type</span></summary><section><div><pre><code class="language-julia hljs">UhligSVARResult{T&lt;:AbstractFloat}</code></pre><p>Result from Mountford-Uhlig (2009) penalty function identification.</p><p><strong>Fields</strong></p><ul><li><code>Q::Matrix{T}</code>: Optimal rotation matrix</li><li><code>irf::Array{T,3}</code>: Impulse responses (horizon × n × n)</li><li><code>penalty::T</code>: Total penalty at optimum (negative = better)</li><li><code>shock_penalties::Vector{T}</code>: Per-shock penalty values</li><li><code>restrictions::SVARRestrictions</code>: The imposed restrictions</li><li><code>converged::Bool</code>: Whether all sign restrictions are satisfied</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/uhlig.jl#L37-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_uhlig"><a class="docstring-binding" href="#MacroEconometricModels.identify_uhlig"><code>MacroEconometricModels.identify_uhlig</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_uhlig(model::VARModel{T}, restrictions::SVARRestrictions, horizon::Int;
    n_starts=50, n_refine=10, max_iter_coarse=500, max_iter_fine=2000,
    tol_coarse=1e-4, tol_fine=1e-8) -&gt; UhligSVARResult{T}</code></pre><p>Identify SVAR using Mountford &amp; Uhlig (2009) penalty function approach.</p><p>Uses Nelder-Mead optimization over spherical coordinates to find the rotation matrix <span>$Q$</span> that best satisfies sign restrictions, with zero restrictions enforced as hard constraints via null-space projection.</p><p><strong>Algorithm</strong></p><ol><li>Precompute MA coefficients and Cholesky factor <span>$L$</span></li><li><strong>Phase 1</strong> (coarse): <code>n_starts</code> Nelder-Mead runs from random <span>$\theta_0 \in [0, 2\pi]$</span></li><li><strong>Phase 2</strong> (refinement): <code>n_refine</code> local re-optimizations from best solution</li><li>Build final <span>$Q$</span>, compute IRFs, check convergence</li></ol><p><strong>Keywords</strong></p><ul><li><code>n_starts::Int=50</code>: Number of random starting points (Phase 1)</li><li><code>n_refine::Int=10</code>: Number of local refinements (Phase 2)</li><li><code>max_iter_coarse::Int=500</code>: Max iterations per Phase 1 run</li><li><code>max_iter_fine::Int=2000</code>: Max iterations per Phase 2 run</li><li><code>tol_coarse::T=1e-4</code>: Convergence tolerance for Phase 1</li><li><code>tol_fine::T=1e-8</code>: Convergence tolerance for Phase 2</li></ul><p><strong>Returns</strong></p><p><code>UhligSVARResult{T}</code> with optimal rotation matrix, IRFs, penalty values, and convergence indicator.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = estimate_var(Y, 2)
restrictions = SVARRestrictions(3;
    zeros = [zero_restriction(3, 1)],
    signs = [sign_restriction(1, 1, :positive),
             sign_restriction(2, 1, :positive)]
)
result = identify_uhlig(model, restrictions, 20)</code></pre><p><strong>Reference</strong>: Mountford &amp; Uhlig (2009)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/uhlig.jl#L273-L314">source</a></section></details></article><hr/><h2 id="Innovation-Accounting"><a class="docs-heading-anchor" href="#Innovation-Accounting">Innovation Accounting</a><a id="Innovation-Accounting-1"></a><a class="docs-heading-anchor-permalink" href="#Innovation-Accounting" title="Permalink"></a></h2><h3 id="Impulse-Response-Functions"><a class="docs-heading-anchor" href="#Impulse-Response-Functions">Impulse Response Functions</a><a id="Impulse-Response-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Impulse-Response-Functions" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._simulate_irfs-Union{Tuple{T}, Tuple{VARModel{T}, Symbol, Int64, Any, Any, Symbol, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._simulate_irfs-Union{Tuple{T}, Tuple{VARModel{T}, Symbol, Int64, Any, Any, Symbol, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._simulate_irfs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Simulate IRFs for confidence intervals (bootstrap or asymptotic).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/irf.jl#L77">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._simulate_var-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._simulate_var-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._simulate_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Simulate VAR data from initial conditions and innovations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/irf.jl#L179">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.cumulative_irf-Union{Tuple{BayesianImpulseResponse{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.cumulative_irf-Union{Tuple{BayesianImpulseResponse{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.cumulative_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cumulative_irf(irf_result::BayesianImpulseResponse{T}) -&gt; BayesianImpulseResponse{T}</code></pre><p>Compute cumulative Bayesian impulse response: Σₛ₌₀ʰ IRF_s.</p><p>When raw posterior draws are available, cumulates each draw first then extracts quantiles — the statistically correct approach.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/irf.jl#L354-L361">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.cumulative_irf-Union{Tuple{ImpulseResponse{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.cumulative_irf-Union{Tuple{ImpulseResponse{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.cumulative_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cumulative_irf(irf_result::ImpulseResponse{T}) -&gt; ImpulseResponse{T}</code></pre><p>Compute cumulative impulse response for VAR models: Σₛ₌₀ʰ IRF_s.</p><p>When raw bootstrap/simulation draws are available, cumulates each draw first then extracts quantiles — the statistically correct approach since quantiles are NOT additive: Q<em>α(A+B) ≠ Q</em>α(A) + Q_α(B).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/irf.jl#L320-L328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.cumulative_irf-Union{Tuple{LPImpulseResponse{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.cumulative_irf-Union{Tuple{LPImpulseResponse{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.cumulative_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cumulative_irf(irf::LPImpulseResponse{T}) -&gt; LPImpulseResponse{T}</code></pre><p>Compute cumulative impulse response: Σₛ₌₀ʰ β_s.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/irf.jl#L303-L307">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.irf-Tuple{BVARPosterior, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.irf-Tuple{BVARPosterior, Int64}"><code>MacroEconometricModels.irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">irf(post::BVARPosterior, horizon; method=:cholesky, quantiles=[0.16, 0.5, 0.84], ...)</code></pre><p>Compute Bayesian IRFs from posterior draws with posterior quantiles.</p><p><strong>Methods</strong></p><p><code>:cholesky</code>, <code>:sign</code>, <code>:narrative</code>, <code>:long_run</code>, <code>:fastica</code>, <code>:jade</code>, <code>:sobi</code>, <code>:dcov</code>, <code>:hsic</code>, <code>:student_t</code>, <code>:mixture_normal</code>, <code>:pml</code>, <code>:skew_normal</code>, <code>:nongaussian_ml</code>, <code>:markov_switching</code>, <code>:garch</code>, <code>:smooth_transition</code>, <code>:external_volatility</code></p><p>Note: <code>:smooth_transition</code> requires <code>transition_var</code> kwarg.       <code>:external_volatility</code> requires <code>regime_indicator</code> kwarg.</p><p>Uses <code>process_posterior_samples</code> and <code>compute_posterior_quantiles</code> from bayesian_utils.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/irf.jl#L203-L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.irf-Tuple{StructuralLP}"><a class="docstring-binding" href="#MacroEconometricModels.irf-Tuple{StructuralLP}"><code>MacroEconometricModels.irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">irf(slp::StructuralLP) -&gt; ImpulseResponse</code></pre><p>Extract the impulse response object from a structural LP result.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/irf.jl#L260-L264">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.irf-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.irf-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">irf(model, horizon; method=:cholesky, ci_type=:none, reps=200, conf_level=0.95, ...)</code></pre><p>Compute IRFs with optional confidence intervals.</p><p><strong>Methods</strong></p><p><code>:cholesky</code>, <code>:sign</code>, <code>:narrative</code>, <code>:long_run</code>, <code>:fastica</code>, <code>:jade</code>, <code>:sobi</code>, <code>:dcov</code>, <code>:hsic</code>, <code>:student_t</code>, <code>:mixture_normal</code>, <code>:pml</code>, <code>:skew_normal</code>, <code>:nongaussian_ml</code>, <code>:markov_switching</code>, <code>:garch</code>, <code>:smooth_transition</code>, <code>:external_volatility</code></p><p>Note: <code>:smooth_transition</code> requires <code>transition_var</code> kwarg.       <code>:external_volatility</code> requires <code>regime_indicator</code> kwarg.</p><p><strong>CI types</strong></p><p><code>:none</code>, <code>:bootstrap</code>, <code>:theoretical</code></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/irf.jl#L29-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lp_irf-Tuple{AbstractMatrix, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.lp_irf-Tuple{AbstractMatrix, Int64, Int64}"><code>MacroEconometricModels.lp_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lp_irf(Y::AbstractMatrix, shock_var::Int, horizon::Int; kwargs...) -&gt; LPImpulseResponse</code></pre><p>Convenience function: estimate LP and extract IRF in one call.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/irf.jl#L289-L293">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lp_irf-Union{Tuple{LPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.lp_irf-Union{Tuple{LPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.lp_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lp_irf(model::LPModel{T}; conf_level::Real=0.95) -&gt; LPImpulseResponse{T}</code></pre><p>Extract impulse response function with confidence intervals from LP model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/irf.jl#L271-L275">source</a></section></details></article><h3 id="Forecast-Error-Variance-Decomposition"><a class="docs-heading-anchor" href="#Forecast-Error-Variance-Decomposition">Forecast Error Variance Decomposition</a><a id="Forecast-Error-Variance-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Forecast-Error-Variance-Decomposition" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_fevd-Union{Tuple{T}, Tuple{Array{T, 3}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_fevd-Union{Tuple{T}, Tuple{Array{T, 3}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_fevd</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute FEVD from IRF array: decomposition[i,j,h] = cumulative MSE contribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/fevd.jl#L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.fevd-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.fevd-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.fevd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fevd(model, horizon; method=:cholesky, ...) -&gt; FEVD</code></pre><p>Compute FEVD showing proportion of h-step forecast error variance attributable to each shock.</p><p><strong>Methods</strong></p><p><code>:cholesky</code>, <code>:sign</code>, <code>:narrative</code>, <code>:long_run</code>, <code>:fastica</code>, <code>:jade</code>, <code>:sobi</code>, <code>:dcov</code>, <code>:hsic</code>, <code>:student_t</code>, <code>:mixture_normal</code>, <code>:pml</code>, <code>:skew_normal</code>, <code>:nongaussian_ml</code>, <code>:markov_switching</code>, <code>:garch</code>, <code>:smooth_transition</code>, <code>:external_volatility</code></p><p>Note: <code>:smooth_transition</code> requires <code>transition_var</code> kwarg.       <code>:external_volatility</code> requires <code>regime_indicator</code> kwarg.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/fevd.jl#L29-L42">source</a></section></details></article><h3 id="Historical-Decomposition"><a class="docs-heading-anchor" href="#Historical-Decomposition">Historical Decomposition</a><a id="Historical-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#Historical-Decomposition" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_hd_contributions-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Array{Matrix{T}, 1}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_hd_contributions-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Array{Matrix{T}, 1}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_hd_contributions</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute historical decomposition contributions from structural shocks and MA coefficients. HD[t, i, j] = Σ<em>{s=0}^{t-1} Θ</em>s[i, j] * ε_j(t-s)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L120-L123">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_initial_conditions-Union{Tuple{T}, Tuple{Matrix{T}, Array{T, 3}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_initial_conditions-Union{Tuple{T}, Tuple{Matrix{T}, Array{T, 3}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_initial_conditions</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute initial conditions as residual: actual - total shock contributions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L147-L149">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_structural_ma_coefficients-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_structural_ma_coefficients-Union{Tuple{T}, Tuple{VARModel{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_structural_ma_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute structural MA coefficients Θ<em>s = Φ</em>s * P for s = 0, ..., horizon-1. Returns Vector{Matrix{T}} of length horizon.</p><p>Uses <code>_compute_ma_coefficients</code> from identification.jl to avoid code duplication.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L102-L107">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.contribution-Union{Tuple{T}, Tuple{BayesianHistoricalDecomposition{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.contribution-Union{Tuple{T}, Tuple{BayesianHistoricalDecomposition{T}, Int64, Int64}} where T"><code>MacroEconometricModels.contribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">contribution(hd::BayesianHistoricalDecomposition, var, shock; stat=:mean) -&gt; Vector</code></pre><p>Get contribution time series for specific variable and shock (Bayesian).</p><p><strong>Arguments</strong></p><ul><li><code>hd</code>: Bayesian historical decomposition result</li><li><code>var</code>: Variable index (Int) or name (String)</li><li><code>shock</code>: Shock index (Int) or name (String)</li><li><code>stat</code>: <code>:mean</code> or quantile index (Int)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L558-L568">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.contribution-Union{Tuple{T}, Tuple{HistoricalDecomposition{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.contribution-Union{Tuple{T}, Tuple{HistoricalDecomposition{T}, Int64, Int64}} where T"><code>MacroEconometricModels.contribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">contribution(hd::HistoricalDecomposition, var, shock) -&gt; Vector</code></pre><p>Get contribution time series for specific variable and shock.</p><p><strong>Arguments</strong></p><ul><li><code>hd</code>: Historical decomposition result</li><li><code>var</code>: Variable index (Int) or name (String)</li><li><code>shock</code>: Shock index (Int) or name (String)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">contrib_y1_s1 = contribution(hd, 1, 1)  # Contribution of shock 1 to variable 1
contrib_y1_s1 = contribution(hd, &quot;Var 1&quot;, &quot;Shock 1&quot;)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L528-L543">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.historical_decomposition"><a class="docstring-binding" href="#MacroEconometricModels.historical_decomposition"><code>MacroEconometricModels.historical_decomposition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">historical_decomposition(post::BVARPosterior, horizon; data=..., ...) -&gt; BayesianHistoricalDecomposition</code></pre><p>Compute Bayesian historical decomposition from posterior draws with posterior quantiles.</p><p><strong>Arguments</strong></p><ul><li><code>post::BVARPosterior</code>: Posterior draws from <code>estimate_bvar</code></li><li><code>horizon::Int</code>: Maximum horizon for MA coefficients</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>data::AbstractMatrix</code>: Override data matrix (defaults to <code>post.data</code>)</li><li><code>method::Symbol=:cholesky</code>: Identification method</li><li><code>quantiles::Vector{&lt;:Real}=[0.16, 0.5, 0.84]</code>: Posterior quantile levels</li><li><code>check_func=nothing</code>: Sign restriction check function</li><li><code>narrative_check=nothing</code>: Narrative restriction check function</li><li><code>transition_var=nothing</code>: Transition variable (for method=:smooth_transition)</li><li><code>regime_indicator=nothing</code>: Regime indicator (for method=:external_volatility)</li></ul><p><strong>Methods</strong></p><p><code>:cholesky</code>, <code>:sign</code>, <code>:narrative</code>, <code>:long_run</code>, <code>:fastica</code>, <code>:jade</code>, <code>:sobi</code>, <code>:dcov</code>, <code>:hsic</code>, <code>:student_t</code>, <code>:mixture_normal</code>, <code>:pml</code>, <code>:skew_normal</code>, <code>:nongaussian_ml</code>, <code>:markov_switching</code>, <code>:garch</code>, <code>:smooth_transition</code>, <code>:external_volatility</code></p><p>Note: <code>:smooth_transition</code> requires <code>transition_var</code> kwarg.       <code>:external_volatility</code> requires <code>regime_indicator</code> kwarg.</p><p><strong>Returns</strong></p><p><code>BayesianHistoricalDecomposition</code> with posterior quantiles and means.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">post = estimate_bvar(Y, 2; n_draws=500)
hd = historical_decomposition(post, 198)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L299-L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.historical_decomposition-Union{Tuple{StructuralLP{T}}, Tuple{T}, Tuple{StructuralLP{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.historical_decomposition-Union{Tuple{StructuralLP{T}}, Tuple{T}, Tuple{StructuralLP{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.historical_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">historical_decomposition(slp::StructuralLP{T}, T_hd::Int) -&gt; HistoricalDecomposition{T}</code></pre><p>Compute historical decomposition from structural LP.</p><p>Uses LP-estimated IRFs as the structural MA coefficients Θ_h and the structural shocks from the underlying VAR identification.</p><p><strong>Arguments</strong></p><ul><li><code>slp</code>: Structural LP result</li><li><code>T_hd</code>: Number of time periods for decomposition (≤ T_eff of underlying VAR)</li></ul><p><strong>Returns</strong></p><p><code>HistoricalDecomposition{T}</code> with contributions, initial conditions, and actual data.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L253-L267">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.historical_decomposition-Union{Tuple{T}, Tuple{VARModel{T}, SVARRestrictions}, Tuple{VARModel{T}, SVARRestrictions, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.historical_decomposition-Union{Tuple{T}, Tuple{VARModel{T}, SVARRestrictions}, Tuple{VARModel{T}, SVARRestrictions, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.historical_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">historical_decomposition(model::VARModel, restrictions::SVARRestrictions, horizon; ...) -&gt; BayesianHistoricalDecomposition</code></pre><p>Compute historical decomposition using Arias et al. (2018) identification with importance weights.</p><p><strong>Arguments</strong></p><ul><li><code>model::VARModel</code>: Estimated VAR model</li><li><code>restrictions::SVARRestrictions</code>: Zero and sign restrictions</li><li><code>horizon::Int</code>: Maximum horizon for MA coefficients</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>n_draws::Int=1000</code>: Number of accepted draws</li><li><code>n_rotations::Int=1000</code>: Maximum rotation attempts per draw</li><li><code>quantiles::Vector{&lt;:Real}=[0.16, 0.5, 0.84]</code>: Quantile levels for weighted quantiles</li></ul><p><strong>Returns</strong></p><p><code>BayesianHistoricalDecomposition</code> with weighted posterior quantiles and means.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">r = SVARRestrictions(3; signs=[sign_restriction(1, 1, :positive)])
hd = historical_decomposition(model, r, 198; n_draws=500)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L427-L450">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.historical_decomposition-Union{Tuple{VARModel{T}}, Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.historical_decomposition-Union{Tuple{VARModel{T}}, Tuple{T}, Tuple{VARModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.historical_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">historical_decomposition(model::VARModel, horizon; method=:cholesky, ...) -&gt; HistoricalDecomposition</code></pre><p>Compute historical decomposition for a VAR model.</p><p>Decomposes observed data into contributions from each structural shock plus initial conditions.</p><p><strong>Arguments</strong></p><ul><li><code>model::VARModel</code>: Estimated VAR model</li><li><code>horizon::Int</code>: Maximum horizon for MA coefficient computation (typically T_eff)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method::Symbol=:cholesky</code>: Identification method</li><li><code>check_func=nothing</code>: Sign restriction check function (for method=:sign or :narrative)</li><li><code>narrative_check=nothing</code>: Narrative restriction check function (for method=:narrative)</li><li><code>max_draws::Int=1000</code>: Maximum draws for sign/narrative identification</li><li><code>transition_var=nothing</code>: Transition variable (for method=:smooth_transition)</li><li><code>regime_indicator=nothing</code>: Regime indicator (for method=:external_volatility)</li></ul><p><strong>Methods</strong></p><p><code>:cholesky</code>, <code>:sign</code>, <code>:narrative</code>, <code>:long_run</code>, <code>:fastica</code>, <code>:jade</code>, <code>:sobi</code>, <code>:dcov</code>, <code>:hsic</code>, <code>:student_t</code>, <code>:mixture_normal</code>, <code>:pml</code>, <code>:skew_normal</code>, <code>:nongaussian_ml</code>, <code>:markov_switching</code>, <code>:garch</code>, <code>:smooth_transition</code>, <code>:external_volatility</code></p><p>Note: <code>:smooth_transition</code> requires <code>transition_var</code> kwarg.       <code>:external_volatility</code> requires <code>regime_indicator</code> kwarg.</p><p><strong>Returns</strong></p><p><code>HistoricalDecomposition</code> containing:</p><ul><li><code>contributions</code>: Shock contributions (T<em>eff × n</em>vars × n_shocks)</li><li><code>initial_conditions</code>: Initial condition effects (T<em>eff × n</em>vars)</li><li><code>actual</code>: Actual data values</li><li><code>shocks</code>: Structural shocks</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = estimate_var(Y, 2)
hd = historical_decomposition(model, size(Y, 1) - 2)
verify_decomposition(hd)  # Check decomposition identity</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L169-L210">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.total_shock_contribution-Union{Tuple{T}, Tuple{HistoricalDecomposition{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.total_shock_contribution-Union{Tuple{T}, Tuple{HistoricalDecomposition{T}, Int64}} where T"><code>MacroEconometricModels.total_shock_contribution</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">total_shock_contribution(hd::AbstractHistoricalDecomposition, var) -&gt; Vector</code></pre><p>Get total contribution from all shocks to a variable over time.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L592-L596">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.verify_decomposition-Union{Tuple{BayesianHistoricalDecomposition{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.verify_decomposition-Union{Tuple{BayesianHistoricalDecomposition{T}}, Tuple{T}} where T"><code>MacroEconometricModels.verify_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">verify_decomposition(hd::BayesianHistoricalDecomposition; tol=1e-6) -&gt; Bool</code></pre><p>Verify that mean contributions + mean initial_conditions ≈ actual (approximately, due to averaging).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L641-L645">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.verify_decomposition-Union{Tuple{HistoricalDecomposition{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.verify_decomposition-Union{Tuple{HistoricalDecomposition{T}}, Tuple{T}} where T"><code>MacroEconometricModels.verify_decomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">verify_decomposition(hd::HistoricalDecomposition; tol=1e-10) -&gt; Bool</code></pre><p>Verify that contributions + initial_conditions ≈ actual.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">hd = historical_decomposition(model, horizon)
@assert verify_decomposition(hd) &quot;Decomposition identity failed&quot;</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/var/hd.jl#L619-L629">source</a></section></details></article><h3 id="Summary-Tables"><a class="docs-heading-anchor" href="#Summary-Tables">Summary Tables</a><a id="Summary-Tables-1"></a><a class="docs-heading-anchor-permalink" href="#Summary-Tables" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.has_uncertainty-Tuple{AbstractAnalysisResult}"><a class="docstring-binding" href="#MacroEconometricModels.has_uncertainty-Tuple{AbstractAnalysisResult}"><code>MacroEconometricModels.has_uncertainty</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">has_uncertainty(result::AbstractAnalysisResult) -&gt; Bool</code></pre><p>Check if the result includes uncertainty quantification (confidence intervals or posterior quantiles).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L48-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.point_estimate-Tuple{AbstractAnalysisResult}"><a class="docstring-binding" href="#MacroEconometricModels.point_estimate-Tuple{AbstractAnalysisResult}"><code>MacroEconometricModels.point_estimate</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">point_estimate(result::AbstractAnalysisResult)</code></pre><p>Get the point estimate from an analysis result.</p><p>Returns the main values/estimates (IRF values, FEVD proportions, HD contributions).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L39-L45">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{BVARPosterior}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{BVARPosterior}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(post::BVARPosterior)</code></pre><p>Print comprehensive Bayesian VAR posterior summary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L224-L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{BaxterKingResult}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{BaxterKingResult}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(r::BaxterKingResult)</code></pre><p>Print Baxter-King band-pass filter summary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L362-L366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{BeveridgeNelsonResult}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{BeveridgeNelsonResult}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(r::BeveridgeNelsonResult)</code></pre><p>Print Beveridge-Nelson decomposition summary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L355-L359">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{BoostedHPResult}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{BoostedHPResult}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(r::BoostedHPResult)</code></pre><p>Print boosted HP filter summary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L369-L373">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{FEVD}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{FEVD}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(f::FEVD)
report(f::BayesianFEVD)</code></pre><p>Print FEVD summary with decomposition at selected horizons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L385-L390">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{HPFilterResult}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{HPFilterResult}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(r::HPFilterResult)</code></pre><p>Print HP filter summary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L341-L345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{HamiltonFilterResult}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{HamiltonFilterResult}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(r::HamiltonFilterResult)</code></pre><p>Print Hamilton filter summary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L348-L352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{HistoricalDecomposition}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{HistoricalDecomposition}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(hd::HistoricalDecomposition)
report(hd::BayesianHistoricalDecomposition)</code></pre><p>Print HD summary with contribution statistics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L394-L399">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{ImpulseResponse}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{ImpulseResponse}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(irf::ImpulseResponse)
report(irf::BayesianImpulseResponse)</code></pre><p>Print IRF summary with values at selected horizons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L376-L381">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{VECMForecast}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{VECMForecast}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(f::VECMForecast)</code></pre><p>Print VECM forecast summary.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L323-L327">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Tuple{VECMGrangerResult}"><a class="docstring-binding" href="#MacroEconometricModels.report-Tuple{VECMGrangerResult}"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(g::VECMGrangerResult)</code></pre><p>Print VECM Granger causality test results.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L330-L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.report-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(model::VARModel)</code></pre><p>Print comprehensive VAR model summary including specification, per-equation coefficient estimates with standard errors and significance, information criteria, residual covariance, and stationarity check.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L114-L120">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.report-Union{Tuple{VECMModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.report-Union{Tuple{VECMModel{T}}, Tuple{T}} where T"><code>MacroEconometricModels.report</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">report(vecm::VECMModel)</code></pre><p>Print comprehensive VECM summary including cointegrating vectors, adjustment coefficients, short-run dynamics, and diagnostics.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L231-L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.uncertainty_bounds-Tuple{AbstractAnalysisResult}"><a class="docstring-binding" href="#MacroEconometricModels.uncertainty_bounds-Tuple{AbstractAnalysisResult}"><code>MacroEconometricModels.uncertainty_bounds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">uncertainty_bounds(result::AbstractAnalysisResult) -&gt; Union{Nothing, Tuple}</code></pre><p>Get uncertainty bounds (lower, upper) if available, otherwise nothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary.jl#L55-L59">source</a></section></details></article><hr/><h2 id="Local-Projections"><a class="docs-heading-anchor" href="#Local-Projections">Local Projections</a><a id="Local-Projections-1"></a><a class="docs-heading-anchor-permalink" href="#Local-Projections" title="Permalink"></a></h2><h3 id="Core-LP-Estimation-and-Covariance"><a class="docs-heading-anchor" href="#Core-LP-Estimation-and-Covariance">Core LP Estimation and Covariance</a><a id="Core-LP-Estimation-and-Covariance-1"></a><a class="docs-heading-anchor-permalink" href="#Core-LP-Estimation-and-Covariance" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._block_bootstrap-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._block_bootstrap-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._block_bootstrap</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Generate a block bootstrap sample from matrix Y.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L543">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._build_structural_lp_arrays-Union{Tuple{T}, Tuple{Array{LPModel{T}, 1}, Int64, Int64, Type{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._build_structural_lp_arrays-Union{Tuple{T}, Tuple{Array{LPModel{T}, 1}, Int64, Int64, Type{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._build_structural_lp_arrays</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Extract 3D IRF and SE arrays from per-shock LP models.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L473">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._lp_predict_at_horizon-Union{Tuple{T}, Tuple{Matrix{T}, Vector{Int64}, Matrix{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._lp_predict_at_horizon-Union{Tuple{T}, Tuple{Matrix{T}, Vector{Int64}, Matrix{T}, Int64, Int64}} where T"><code>MacroEconometricModels._lp_predict_at_horizon</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_lp_predict_at_horizon(Y, response_vars, residuals_h, T_eff_h, h)</code></pre><p>Reconstruct fitted values at horizon h via Y<em>h − residuals</em>h identity.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L595-L599">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._lp_robust_vcov-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, NeweyWestEstimator{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._lp_robust_vcov-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, NeweyWestEstimator{T}, Int64}} where T"><code>MacroEconometricModels._lp_robust_vcov</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_lp_robust_vcov(X_h, U_h, cov_estimator, h)</code></pre><p>Horizon-aware robust variance-covariance for LP regressions.</p><p>LP residuals at horizon h have MA(h-1) serial correlation (Jordà 2005), so the Newey-West bandwidth must be at least h+1. When automatic bandwidth selection (<code>bandwidth == 0</code>) yields a smaller value, this function enforces the floor <code>max(m̂_NW, h+1)</code>.</p><p>For non-NW estimators (White, Driscoll-Kraay), falls through to the standard <code>compute_block_robust_vcov</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L132-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._structural_lp_bootstrap-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Int64, Symbol, Int64, Symbol, Int64, T, Any, Any, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._structural_lp_bootstrap-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Int64, Symbol, Int64, Symbol, Int64, T, Any, Any, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._structural_lp_bootstrap</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Block bootstrap for structural LP confidence intervals.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L493">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.build_control_columns!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Vararg{Int64, 4}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.build_control_columns!-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, Vararg{Int64, 4}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.build_control_columns!</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_control_columns!(X_h::AbstractMatrix{T}, Y::AbstractMatrix{T},
                       t_start::Int, t_end::Int, lags::Int, start_col::Int) where T</code></pre><p>Fill control (lagged Y) columns into regressor matrix X_h. Returns the next available column index.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L90-L96">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.build_response_matrix-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Int64, Vector{Int64}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.build_response_matrix-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Int64, Vector{Int64}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.build_response_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">build_response_matrix(Y::AbstractMatrix{T}, h::Int, t_start::Int, t_end::Int,
                      response_vars::Vector{Int}) where T</code></pre><p>Build response matrix Y_h at horizon h.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L71-L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compare_var_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compare_var_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compare_var_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_var_lp(Y::AbstractMatrix{T}, horizon::Int; lags::Int=4) where T</code></pre><p>Compare VAR-based and LP-based impulse responses.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L563-L567">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_block_robust_vcov-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractCovarianceEstimator}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compute_block_robust_vcov-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractCovarianceEstimator}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compute_block_robust_vcov</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_block_robust_vcov(X::AbstractMatrix{T}, U::AbstractMatrix{T},
                          cov_estimator::AbstractCovarianceEstimator) where T</code></pre><p>Compute block-diagonal robust covariance for multi-equation system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L113-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compute_horizon_bounds-Tuple{Int64, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.compute_horizon_bounds-Tuple{Int64, Int64, Int64}"><code>MacroEconometricModels.compute_horizon_bounds</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compute_horizon_bounds(T_obs::Int, h::Int, lags::Int) -&gt; (t_start, t_end)</code></pre><p>Compute valid observation bounds for horizon h.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L57-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.construct_lp_matrices-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.construct_lp_matrices-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.construct_lp_matrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">construct_lp_matrices(Y::AbstractMatrix{T}, shock_var::Int, h::Int, lags::Int;
                      response_vars::Vector{Int}=collect(1:size(Y,2))) where T</code></pre><p>Construct regressor and response matrices for LP regression at horizon h.</p><p>Returns: (Y<em>h, X</em>h, valid_idx)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L211-L218">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.create_cov_estimator-Union{Tuple{T}, Tuple{Symbol, Type{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.create_cov_estimator-Union{Tuple{T}, Tuple{Symbol, Type{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.create_cov_estimator</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">create_cov_estimator(cov_type::Symbol, ::Type{T}; bandwidth::Int=0) where T</code></pre><p>Create covariance estimator from symbol specification. Eliminates repeated if/else patterns across LP variants.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L39-L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_lp(Y::AbstractMatrix{T}, shock_var::Int, horizon::Int;
            lags::Int=4, response_vars::Vector{Int}=collect(1:size(Y,2)),
            cov_type::Symbol=:newey_west, bandwidth::Int=0,
            conf_level::Real=0.95) -&gt; LPModel{T}</code></pre><p>Estimate Local Projection impulse response functions (Jordà 2005).</p><p>The LP regression for horizon h:     y<em>{t+h} = α</em>h + β<em>h * shock</em>t + Γ<em>h * controls</em>t + ε_{t+h}</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L246-L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_lp_cholesky-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_lp_cholesky-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_lp_cholesky</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_lp_cholesky(Y::AbstractMatrix{T}, horizon::Int;
                     lags::Int=4, cov_type::Symbol=:newey_west, kwargs...) -&gt; Vector{LPModel{T}}</code></pre><p>Estimate LP with Cholesky-orthogonalized shocks.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L320-L325">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_lp_multi-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Vector{Int64}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_lp_multi-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Vector{Int64}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_lp_multi</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_lp_multi(Y::AbstractMatrix{T}, shock_vars::Vector{Int}, horizon::Int;
                  kwargs...) -&gt; Vector{LPModel{T}}</code></pre><p>Estimate LP for multiple shock variables.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L305-L310">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.extract_shock_irf-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, Vector{Int64}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.extract_shock_irf-Union{Tuple{T}, Tuple{Array{Matrix{T}, 1}, Array{Matrix{T}, 1}, Vector{Int64}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.extract_shock_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">extract_shock_irf(B::Vector{Matrix{T}}, vcov::Vector{Matrix{T}},
                  response_vars::Vector{Int}, shock_coef_idx::Int;
                  conf_level::Real=0.95) where T</code></pre><p>Generic IRF extraction from coefficient and covariance vectors. Works for LPModel, LPIVModel, PropensityLPModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L169-L176">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.structural_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.structural_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.structural_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">structural_lp(Y::AbstractMatrix{T}, horizon::Int;
              method=:cholesky, lags=4, var_lags=nothing,
              cov_type=:newey_west, conf_level=0.95,
              ci_type=:none, reps=200,
              check_func=nothing, narrative_check=nothing,
              max_draws=1000,
              transition_var=nothing, regime_indicator=nothing) -&gt; StructuralLP{T}</code></pre><p>Estimate structural LP impulse responses using VAR-based identification with LP estimation.</p><p>Algorithm:</p><ol><li>Estimate VAR(p) → obtain Σ and residuals</li><li>Compute rotation matrix Q via chosen identification method</li><li>Compute structural shocks ε<em>t = Q&#39;L⁻¹u</em>t</li><li>For each shock j, run LP with ε<em>j as regressor and Y</em>eff as responses</li><li>Stack into 3D IRF array: irfs[h, i, j]</li></ol><p><strong>Arguments</strong></p><ul><li><code>Y</code>: T × n data matrix</li><li><code>horizon</code>: Maximum IRF horizon H</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method</code>: Identification method</li><li><code>lags</code>: Number of LP control lags (default: 4)</li><li><code>var_lags</code>: VAR lag order for identification (default: same as <code>lags</code>)</li><li><code>cov_type</code>: HAC estimator (:newey_west, :white)</li><li><code>conf_level</code>: Confidence level for CIs (default: 0.95)</li><li><code>ci_type</code>: CI method (:none, :bootstrap)</li><li><code>reps</code>: Number of bootstrap replications</li><li><code>check_func</code>: Sign restriction check function (for :sign/:narrative)</li><li><code>narrative_check</code>: Narrative check function (for :narrative)</li><li><code>max_draws</code>: Maximum draws for sign/narrative identification</li><li><code>transition_var</code>: Transition variable (for :smooth_transition)</li><li><code>regime_indicator</code>: Regime indicator (for :external_volatility)</li></ul><p><strong>Methods</strong></p><p><code>:cholesky</code>, <code>:sign</code>, <code>:narrative</code>, <code>:long_run</code>, <code>:fastica</code>, <code>:jade</code>, <code>:sobi</code>, <code>:dcov</code>, <code>:hsic</code>, <code>:student_t</code>, <code>:mixture_normal</code>, <code>:pml</code>, <code>:skew_normal</code>, <code>:nongaussian_ml</code>, <code>:markov_switching</code>, <code>:garch</code>, <code>:smooth_transition</code>, <code>:external_volatility</code></p><p>Note: <code>:smooth_transition</code> requires <code>transition_var</code> kwarg.       <code>:external_volatility</code> requires <code>regime_indicator</code> kwarg.</p><p><strong>Returns</strong></p><p><code>StructuralLP{T}</code> with 3D IRFs, structural shocks, VAR model, and individual LP models.</p><p><strong>References</strong></p><p>Plagborg-Møller, M. &amp; Wolf, C. K. (2021). &quot;Local Projections and VARs Estimate the Same Impulse Responses.&quot; <em>Econometrica</em>, 89(2), 955–980.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/core.jl#L353-L404">source</a></section></details></article><h3 id="LP-IV-(Stock-and-Watson-2018)"><a class="docs-heading-anchor" href="#LP-IV-(Stock-and-Watson-2018)">LP-IV (Stock &amp; Watson 2018)</a><a id="LP-IV-(Stock-and-Watson-2018)-1"></a><a class="docs-heading-anchor-permalink" href="#LP-IV-(Stock-and-Watson-2018)" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_lp_iv-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_lp_iv-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_lp_iv</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_lp_iv(Y::AbstractMatrix{T}, shock_var::Int, instruments::AbstractMatrix{T},
               horizon::Int; lags::Int=4, response_vars::Vector{Int}=collect(1:size(Y,2)),
               cov_type::Symbol=:newey_west, bandwidth::Int=0) -&gt; LPIVModel{T}</code></pre><p>Estimate LP with Instrumental Variables (Stock &amp; Watson 2018) using 2SLS.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/iv.jl#L91-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.first_stage_regression-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.first_stage_regression-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.first_stage_regression</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">first_stage_regression(endog::AbstractVector{T}, instruments::AbstractMatrix{T},
                       controls::AbstractMatrix{T}; h::Int=0) -&gt; NamedTuple</code></pre><p>First-stage regression for 2SLS with HAC-robust F-statistic for instrument relevance.</p><p>At LP horizon h &gt; 0, residuals have MA(h-1) autocorrelation by construction (Jordà 2005), so the F-statistic uses Newey-West HAC variance with bandwidth ≥ h+1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/iv.jl#L25-L33">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lp_iv_irf-Union{Tuple{LPIVModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.lp_iv_irf-Union{Tuple{LPIVModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.lp_iv_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lp_iv_irf(model::LPIVModel{T}; conf_level::Real=0.95) -&gt; LPImpulseResponse{T}</code></pre><p>Extract IRF from LP-IV model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/iv.jl#L179-L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.sargan_test-Union{Tuple{T}, Tuple{LPIVModel{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.sargan_test-Union{Tuple{T}, Tuple{LPIVModel{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.sargan_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">sargan_test(model::LPIVModel{T}, h::Int) -&gt; NamedTuple</code></pre><p>Sargan-Hansen J-test for overidentification at horizon h.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/iv.jl#L197-L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.tsls_regression-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.tsls_regression-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{T}, AbstractVector{T}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.tsls_regression</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">tsls_regression(Y::AbstractMatrix{T}, endog::AbstractVector{T},
                endog_fitted::AbstractVector{T}, controls::AbstractMatrix{T};
                cov_estimator::AbstractCovarianceEstimator=NeweyWestEstimator()) -&gt; NamedTuple</code></pre><p>Second-stage regression using fitted values from first stage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/iv.jl#L63-L69">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.weak_instrument_test-Union{Tuple{LPIVModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.weak_instrument_test-Union{Tuple{LPIVModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.weak_instrument_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">weak_instrument_test(model::LPIVModel{T}; threshold::T=T(10.0)) -&gt; NamedTuple</code></pre><p>Test for weak instruments using Stock-Yogo rule of thumb (F &gt; 10).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/iv.jl#L163-L167">source</a></section></details></article><h3 id="Smooth-LP-(Barnichon-and-Brownlees-2019)"><a class="docs-heading-anchor" href="#Smooth-LP-(Barnichon-and-Brownlees-2019)">Smooth LP (Barnichon &amp; Brownlees 2019)</a><a id="Smooth-LP-(Barnichon-and-Brownlees-2019)-1"></a><a class="docs-heading-anchor-permalink" href="#Smooth-LP-(Barnichon-and-Brownlees-2019)" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.bspline_basis-Tuple{AbstractVector{Int64}, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.bspline_basis-Tuple{AbstractVector{Int64}, Int64, Int64}"><code>MacroEconometricModels.bspline_basis</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bspline_basis(horizons::AbstractVector{Int}, degree::Int, n_interior_knots::Int;
              T::Type{&lt;:AbstractFloat}=Float64) -&gt; BSplineBasis{T}</code></pre><p>Construct B-spline basis matrix for given horizons.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/smooth.jl#L49-L54">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.bspline_basis_value-Union{Tuple{T}, Tuple{T, Int64, Int64, Vector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.bspline_basis_value-Union{Tuple{T}, Tuple{T, Int64, Int64, Vector{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.bspline_basis_value</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">bspline_basis_value(x::T, i::Int, degree::Int, knots::Vector{T}) where T</code></pre><p>Evaluate B-spline basis function using Cox-de Boor recursion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/smooth.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.compare_smooth_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.compare_smooth_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.compare_smooth_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">compare_smooth_lp(Y::AbstractMatrix{T}, shock_var::Int, horizon::Int;
                  lambda::T=T(1.0), kwargs...) -&gt; NamedTuple</code></pre><p>Compare standard LP and smooth LP.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/smooth.jl#L230-L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.cross_validate_lambda-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.cross_validate_lambda-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.cross_validate_lambda</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">cross_validate_lambda(Y::AbstractMatrix{T}, shock_var::Int, horizon::Int;
                      lambda_grid::Vector{T}=T.(10.0 .^ (-4:0.5:2)),
                      k_folds::Int=5, kwargs...) -&gt; T</code></pre><p>Select optimal λ via k-fold cross-validation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/smooth.jl#L167-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_smooth_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_smooth_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_smooth_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_smooth_lp(Y::AbstractMatrix{T}, shock_var::Int, horizon::Int;
                   degree::Int=3, n_knots::Int=4, lambda::T=T(0.0),
                   lags::Int=4, response_vars::Vector{Int}=collect(1:size(Y,2)),
                   cov_type::Symbol=:newey_west, bandwidth::Int=0) -&gt; SmoothLPModel{T}</code></pre><p>Estimate Smooth LP with B-spline parameterization (Barnichon &amp; Brownlees 2019).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/smooth.jl#L99-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.roughness_penalty_matrix-Union{Tuple{BSplineBasis{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.roughness_penalty_matrix-Union{Tuple{BSplineBasis{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.roughness_penalty_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">roughness_penalty_matrix(basis::BSplineBasis{T}) -&gt; Matrix{T}</code></pre><p>Compute roughness penalty matrix R for B-splines (second derivative penalty).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/smooth.jl#L76-L80">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.smooth_lp_irf-Union{Tuple{SmoothLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.smooth_lp_irf-Union{Tuple{SmoothLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.smooth_lp_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">smooth_lp_irf(model::SmoothLPModel{T}; conf_level::Real=0.95) -&gt; LPImpulseResponse{T}</code></pre><p>Extract smoothed IRF from SmoothLPModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/smooth.jl#L213-L217">source</a></section></details></article><h3 id="State-Dependent-LP-(Auerbach-and-Gorodnichenko-2013)"><a class="docs-heading-anchor" href="#State-Dependent-LP-(Auerbach-and-Gorodnichenko-2013)">State-Dependent LP (Auerbach &amp; Gorodnichenko 2013)</a><a id="State-Dependent-LP-(Auerbach-and-Gorodnichenko-2013)-1"></a><a class="docs-heading-anchor-permalink" href="#State-Dependent-LP-(Auerbach-and-Gorodnichenko-2013)" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_state_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractVector{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_state_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, AbstractVector{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_state_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_state_lp(Y::AbstractMatrix{T}, shock_var::Int, state_var::AbstractVector{T},
                  horizon::Int; gamma::Union{T,Symbol}=:estimate, ...) -&gt; StateLPModel{T}</code></pre><p>Estimate state-dependent LP (Auerbach &amp; Gorodnichenko 2013).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/state.jl#L124-L129">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_transition_params-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_transition_params-Union{Tuple{T}, Tuple{AbstractVector{T}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_transition_params</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_transition_params(state_var::AbstractVector{T}, Y::AbstractMatrix{T},
                           shock_var::Int; method::Symbol=:nlls, ...) -&gt; NamedTuple</code></pre><p>Estimate smooth transition parameters (γ, c).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/state.jl#L51-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.exponential_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.exponential_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.exponential_transition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">exponential_transition(z::AbstractVector{T}, gamma::T, c::T) -&gt; Vector{T}</code></pre><p>Exponential (symmetric) transition: F(z) = 1 - exp(-γ(z - c)²)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/state.jl#L36-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.indicator_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.indicator_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.indicator_transition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">indicator_transition(z::AbstractVector{T}, c::T) -&gt; Vector{T}</code></pre><p>Sharp indicator transition: F(z) = 1 if z ≥ c, else 0</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/state.jl#L44-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.logistic_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.logistic_transition-Union{Tuple{T}, Tuple{AbstractVector{T}, T, T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.logistic_transition</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">logistic_transition(z::AbstractVector{T}, gamma::T, c::T) -&gt; Vector{T}</code></pre><p>Logistic transition function: F(z) = exp(-γ(z - c)) / (1 + exp(-γ(z - c)))</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/state.jl#L25-L29">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.state_irf-Union{Tuple{StateLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.state_irf-Union{Tuple{StateLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.state_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">state_irf(model::StateLPModel{T}; regime::Symbol=:both, conf_level::Real=0.95) -&gt; NamedTuple</code></pre><p>Extract state-dependent IRFs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/state.jl#L242-L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_regime_difference-Union{Tuple{StateLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.test_regime_difference-Union{Tuple{StateLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.test_regime_difference</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">test_regime_difference(model::StateLPModel{T}; h::Union{Int,Nothing}=nothing) -&gt; NamedTuple</code></pre><p>Test whether IRFs differ across regimes.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/state.jl#L290-L294">source</a></section></details></article><h3 id="Propensity-Score-LP-(Angrist-et-al.-2018)"><a class="docs-heading-anchor" href="#Propensity-Score-LP-(Angrist-et-al.-2018)">Propensity Score LP (Angrist et al. 2018)</a><a id="Propensity-Score-LP-(Angrist-et-al.-2018)-1"></a><a class="docs-heading-anchor-permalink" href="#Propensity-Score-LP-(Angrist-et-al.-2018)" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.doubly_robust_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Bool}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.doubly_robust_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Bool}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.doubly_robust_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">doubly_robust_lp(Y::AbstractMatrix{T}, treatment::AbstractVector{Bool},
                 covariates::AbstractMatrix{T}, horizon::Int; ...) -&gt; PropensityLPModel{T}</code></pre><p>Doubly robust LP estimator combining IPW and regression adjustment.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/propensity.jl#L194-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_propensity_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Bool}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_propensity_lp-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector{Bool}, AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_propensity_lp</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_propensity_lp(Y::AbstractMatrix{T}, treatment::AbstractVector{Bool},
                       covariates::AbstractMatrix{T}, horizon::Int; ...) -&gt; PropensityLPModel{T}</code></pre><p>Estimate LP with Inverse Propensity Weighting (Angrist et al. 2018).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/propensity.jl#L92-L97">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_propensity_score-Union{Tuple{T}, Tuple{AbstractVector{Bool}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_propensity_score-Union{Tuple{T}, Tuple{AbstractVector{Bool}, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_propensity_score</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_propensity_score(treatment::AbstractVector{Bool}, X::AbstractMatrix{T};
                          method::Symbol=:logit) -&gt; Vector{T}</code></pre><p>Estimate propensity scores P(D=1|X) via logit or probit.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/propensity.jl#L25-L30">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.inverse_propensity_weights-Union{Tuple{T}, Tuple{AbstractVector{Bool}, AbstractVector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.inverse_propensity_weights-Union{Tuple{T}, Tuple{AbstractVector{Bool}, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.inverse_propensity_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">inverse_propensity_weights(treatment::AbstractVector{Bool}, propensity::AbstractVector{T};
                           trimming::Tuple{T,T}=(T(0.01), T(0.99)), normalize::Bool=true) -&gt; Vector{T}</code></pre><p>Compute IPW weights with optional trimming.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/propensity.jl#L69-L74">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.propensity_diagnostics-Union{Tuple{PropensityLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.propensity_diagnostics-Union{Tuple{PropensityLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.propensity_diagnostics</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">propensity_diagnostics(model::PropensityLPModel{T}) -&gt; NamedTuple</code></pre><p>Propensity score diagnostics (overlap, balance).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/propensity.jl#L314-L318">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.propensity_irf-Union{Tuple{PropensityLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.propensity_irf-Union{Tuple{PropensityLPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.propensity_irf</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">propensity_irf(model::PropensityLPModel{T}; conf_level::Real=0.95) -&gt; LPImpulseResponse{T}</code></pre><p>Extract treatment effect (ATE) IRF from PropensityLPModel.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/propensity.jl#L297-L301">source</a></section></details></article><h3 id="LP-Forecasting"><a class="docs-heading-anchor" href="#LP-Forecasting">LP Forecasting</a><a id="LP-Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#LP-Forecasting" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._build_forecast_controls-Union{Tuple{LPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._build_forecast_controls-Union{Tuple{LPModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._build_forecast_controls</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Build the control vector from LP model&#39;s last observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/forecast.jl#L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._forecast_ci-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T, Symbol}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._forecast_ci-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, T, Symbol}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._forecast_ci</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute forecast CIs from SEs using normal quantiles.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/forecast.jl#L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._lp_forecast_bootstrap-Union{Tuple{T}, Tuple{LPModel{T}, Vector{T}, Vector{T}, Int64, T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._lp_forecast_bootstrap-Union{Tuple{T}, Tuple{LPModel{T}, Vector{T}, Vector{T}, Int64, T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._lp_forecast_bootstrap</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Bootstrap CIs for LP forecasts via residual resampling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/forecast.jl#L154">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{LPModel{T}, AbstractVector{&lt;:Real}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{LPModel{T}, AbstractVector{&lt;:Real}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(lp::LPModel{T}, shock_path::AbstractVector{&lt;:Real};
         ci_method=:analytical, conf_level=0.95, n_boot=500) -&gt; LPForecast{T}</code></pre><p>Compute direct multi-step LP forecasts given a shock trajectory.</p><p>For each horizon h=1,...,H, the forecast uses the LP regression coefficients:     ŷ<em>{T+h} = α</em>h + β<em>h·shock</em>h + Γ<em>h·controls</em>T</p><p>where controls_T are the last <code>lags</code> observations of Y.</p><p><strong>Arguments</strong></p><ul><li><code>lp</code>: Estimated LP model</li><li><code>shock_path</code>: Vector of length H with assumed future shock values</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ci_method</code>: <code>:analytical</code> (default), <code>:bootstrap</code>, or <code>:none</code></li><li><code>conf_level</code>: Confidence level (default: 0.95)</li><li><code>n_boot</code>: Number of bootstrap replications (default: 500)</li></ul><p><strong>Returns</strong></p><p><code>LPForecast{T}</code> with point forecasts, CIs, and standard errors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/forecast.jl#L42-L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{StructuralLP{T}, Int64, AbstractVector{&lt;:Real}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{StructuralLP{T}, Int64, AbstractVector{&lt;:Real}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(slp::StructuralLP{T}, shock_idx::Int, shock_path::AbstractVector{&lt;:Real};
         ci_method=:analytical, conf_level=0.95, n_boot=500) -&gt; LPForecast{T}</code></pre><p>Compute direct multi-step forecast from a structural LP model using a specific orthogonalized shock.</p><p><strong>Arguments</strong></p><ul><li><code>slp</code>: Structural LP model</li><li><code>shock_idx</code>: Index of the structural shock to use (1:n)</li><li><code>shock_path</code>: Vector of length H with assumed shock values</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ci_method</code>: <code>:analytical</code> (default), <code>:bootstrap</code>, or <code>:none</code></li><li><code>conf_level</code>: Confidence level (default: 0.95)</li><li><code>n_boot</code>: Number of bootstrap replications (default: 500)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/forecast.jl#L204-L220">source</a></section></details></article><h3 id="LP-FEVD-(Gorodnichenko-and-Lee-2019)"><a class="docs-heading-anchor" href="#LP-FEVD-(Gorodnichenko-and-Lee-2019)">LP-FEVD (Gorodnichenko &amp; Lee 2019)</a><a id="LP-FEVD-(Gorodnichenko-and-Lee-2019)-1"></a><a class="docs-heading-anchor-permalink" href="#LP-FEVD-(Gorodnichenko-and-Lee-2019)" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_lp_fevd_h-Union{Tuple{T}, Tuple{LPModel{T}, Vector{T}, Int64, Int64, Symbol}} where T"><a class="docstring-binding" href="#MacroEconometricModels._compute_lp_fevd_h-Union{Tuple{T}, Tuple{LPModel{T}, Vector{T}, Int64, Int64, Symbol}} where T"><code>MacroEconometricModels._compute_lp_fevd_h</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Dispatch to R², LP-A, or LP-B estimator at horizon h.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L134">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._lp_fevd_bootstrap-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64, Vector{T}, Int64, T, Union{Nothing, Int64}}} where T"><a class="docstring-binding" href="#MacroEconometricModels._lp_fevd_bootstrap-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64, Vector{T}, Int64, T, Union{Nothing, Int64}}} where T"><code>MacroEconometricModels._lp_fevd_bootstrap</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Bootstrap bias correction and CIs for LP-FEVD.</p><ol><li>Fit bivariate VAR(L) on (z, y) with HQIC lag selection</li><li>Compute &#39;true&#39; FEVD from VAR (theoretical benchmark)</li><li>Simulate B samples from VAR, compute LP-FEVD for each</li><li>Bias = mean(bootstrap FEVD) - true FEVD</li><li>Bias-corrected = raw - bias</li><li>CIs from centered bootstrap distribution (Kilian 1998)</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L294-L303">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._lp_fevd_lpa_h-Union{Tuple{T}, Tuple{LPModel{T}, Vector{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._lp_fevd_lpa_h-Union{Tuple{T}, Tuple{LPModel{T}, Vector{T}, Int64, Int64}} where T"><code>MacroEconometricModels._lp_fevd_lpa_h</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_lp_fevd_lpa_h(lp_model, shock, resp_idx, h) -&gt; T</code></pre><p>LP-A FEVD: ŝ<em>h = (Σ</em>{i=0}^{h} β̂₀^{i,LP}² σ̂<em>z²) / Var(f̂</em>{t+h|t-1}). Uses IRF coefficients directly — no R² regression needed.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L167-L172">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._lp_fevd_lpb_h-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, LPModel{T}, Int64, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._lp_fevd_lpb_h-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, LPModel{T}, Int64, Int64, Int64}} where T"><code>MacroEconometricModels._lp_fevd_lpb_h</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_lp_fevd_lpb_h(f_hat, shock, lp_model, resp_idx, t_start, h) -&gt; T</code></pre><p>LP-B FEVD: ŝ<em>h = numerator / (numerator + Var(ṽ</em>{t+h|t-1})), where ṽ is the residual from the R²-regression (Eq. 6).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L194-L199">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._lp_fevd_r2_h-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._lp_fevd_r2_h-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64}} where T"><code>MacroEconometricModels._lp_fevd_r2_h</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_lp_fevd_r2_h(f_hat, shock, t_start, h) -&gt; T</code></pre><p>R² FEVD at horizon h: regress forecast errors f̂ on shock leads [z<em>{t+h},...,z</em>t].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L153-L157">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._r2_on_shock_leads-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._r2_on_shock_leads-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64}} where T"><code>MacroEconometricModels._r2_on_shock_leads</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Regress f<em>hat on [1, z</em>{t+h}, z<em>{t+h-1}, ..., z</em>t] and return R².</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L224-L226">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._r2_residual_variance-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._r2_residual_variance-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64}} where T"><code>MacroEconometricModels._r2_residual_variance</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Regress f_hat on shock leads and return Var(residuals).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L263-L265">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._scalar_lp_fevd_r2-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._scalar_lp_fevd_r2-Union{Tuple{T}, Tuple{Vector{T}, Vector{T}, Int64, Int64}} where T"><code>MacroEconometricModels._scalar_lp_fevd_r2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute R²-based FEVD for scalar (z, y) pair at horizon h. Used in bootstrap bias correction.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L437-L440">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._simulate_from_var-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._simulate_from_var-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T"><code>MacroEconometricModels._simulate_from_var</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Simulate T_sim observations from a VAR model with burn-in.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L387">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._var_theoretical_fevd-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._var_theoretical_fevd-Union{Tuple{T}, Tuple{VARModel{T}, Int64}} where T"><code>MacroEconometricModels._var_theoretical_fevd</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute theoretical FEVD of variable 2 w.r.t. shock 1 from bivariate VAR.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L421">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.fevd-Union{Tuple{T}, Tuple{StructuralLP{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.fevd-Union{Tuple{T}, Tuple{StructuralLP{T}, Int64}} where T"><code>MacroEconometricModels.fevd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">fevd(slp::StructuralLP{T}, horizon::Int; kwargs...) -&gt; LPFEVD{T}</code></pre><p>Compute LP-based FEVD for structural LP results. Dispatches to <code>lp_fevd</code>.</p><p>See <code>lp_fevd</code> for full documentation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L120-L126">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lp_fevd-Union{Tuple{T}, Tuple{StructuralLP{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.lp_fevd-Union{Tuple{T}, Tuple{StructuralLP{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.lp_fevd</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lp_fevd(slp::StructuralLP{T}, horizon::Int; kwargs...) -&gt; LPFEVD{T}</code></pre><p>Compute LP-based FEVD using the R²-based estimator of Gorodnichenko &amp; Lee (2019).</p><p>At each horizon h, the share of variable i&#39;s forecast error variance due to shock j is estimated by regressing LP forecast error residuals on structural shock leads z<em>{t+h}, z</em>{t+h-1}, ..., z_t and computing R².</p><p><strong>Arguments</strong></p><ul><li><code>slp</code>: Structural LP result from <code>structural_lp()</code></li><li><code>horizon</code>: Maximum FEVD horizon (capped at IRF horizon)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method</code>: Estimator (:r2, :lp<em>a, :lp</em>b). Default: :r2</li><li><code>bias_correct</code>: Apply VAR-based bootstrap bias correction. Default: true</li><li><code>n_boot</code>: Number of bootstrap replications. Default: 500</li><li><code>conf_level</code>: Confidence level for CIs. Default: 0.95</li><li><code>var_lags</code>: VAR lag order for bias correction (default: HQIC-selected)</li></ul><p><strong>Returns</strong></p><p><code>LPFEVD{T}</code> with raw proportions, bias-corrected values, SEs, and CIs.</p><p><strong>Reference</strong></p><p>Gorodnichenko, Y. &amp; Lee, B. (2019). &quot;Forecast Error Variance Decompositions with Local Projections.&quot; <em>JBES</em>, 38(4), 921–933.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/lp/fevd.jl#L37-L63">source</a></section></details></article><hr/><h2 id="Factor-Models"><a class="docs-heading-anchor" href="#Factor-Models">Factor Models</a><a id="Factor-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Factor-Models" title="Permalink"></a></h2><h3 id="Static-Factor-Model"><a class="docs-heading-anchor" href="#Static-Factor-Model">Static Factor Model</a><a id="Static-Factor-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Static-Factor-Model" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_factors(X, r; standardize=true) -&gt; FactorModel</code></pre><p>Estimate static factor model X<em>t = Λ F</em>t + e_t via Principal Component Analysis.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Data matrix (T × N), observations × variables</li><li><code>r</code>: Number of factors to extract</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>standardize::Bool=true</code>: Standardize data before estimation</li></ul><p><strong>Returns</strong></p><p><code>FactorModel</code> containing factors, loadings, eigenvalues, and explained variance.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">X = randn(200, 50)  # 200 observations, 50 variables
fm = estimate_factors(X, 3)  # Extract 3 factors
r2(fm)  # R² for each variable</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L57-L78">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{FactorModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{FactorModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::FactorModel, h; p=1, ci_method=:none, conf_level=0.95, n_boot=1000)</code></pre><p>Forecast factors and observables h steps ahead from a static factor model.</p><p>Internally fits a VAR(p) on the extracted factors, then uses the VAR dynamics to produce multi-step forecasts and (optionally) confidence intervals.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Estimated static factor model</li><li><code>h</code>: Forecast horizon</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>p::Int=1</code>: VAR lag order for factor dynamics</li><li><code>ci_method::Symbol=:none</code>: CI method — <code>:none</code>, <code>:theoretical</code>, or <code>:bootstrap</code></li><li><code>conf_level::Real=0.95</code>: Confidence level for intervals</li><li><code>n_boot::Int=1000</code>: Number of bootstrap replications (if <code>ci_method=:bootstrap</code>)</li></ul><p><strong>Returns</strong></p><p><code>FactorForecast</code> with factor and observable forecasts (and CIs if requested).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L248-L268">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ic_criteria-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.ic_criteria-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.ic_criteria</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ic_criteria(X, max_factors; standardize=true)</code></pre><p>Compute Bai-Ng (2002) information criteria IC1, IC2, IC3 for selecting the number of factors.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Data matrix (T × N)</li><li><code>max_factors</code>: Maximum number of factors to consider</li></ul><p><strong>Returns</strong></p><p>Named tuple with IC values and optimal factor counts:</p><ul><li><code>IC1</code>, <code>IC2</code>, <code>IC3</code>: Information criteria vectors</li><li><code>r_IC1</code>, <code>r_IC2</code>, <code>r_IC3</code>: Optimal factor counts</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = ic_criteria(X, 10)
println(&quot;Optimal factors: IC1=&quot;, result.r_IC1, &quot;, IC2=&quot;, result.r_IC2, &quot;, IC3=&quot;, result.r_IC3)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L185-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.scree_plot_data-Tuple{FactorModel}"><a class="docstring-binding" href="#MacroEconometricModels.scree_plot_data-Tuple{FactorModel}"><code>MacroEconometricModels.scree_plot_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">scree_plot_data(m::FactorModel)</code></pre><p>Return data for scree plot: factor indices, explained variance, cumulative variance.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">data = scree_plot_data(fm)
# Plot: data.factors vs data.explained_variance</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L230-L240">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.dof-Tuple{FactorModel}"><a class="docstring-binding" href="#StatsAPI.dof-Tuple{FactorModel}"><code>StatsAPI.dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L178">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{FactorModel}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{FactorModel}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict-Tuple{FactorModel}"><a class="docstring-binding" href="#StatsAPI.predict-Tuple{FactorModel}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Predicted values: F * Λ&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L158">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.r2-Union{Tuple{FactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.r2-Union{Tuple{FactorModel{T}}, Tuple{T}} where T"><code>StatsAPI.r2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>R² for each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.residuals-Union{Tuple{FactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.residuals-Union{Tuple{FactorModel{T}}, Tuple{T}} where T"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Residuals: X - predicted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/static.jl#L161">source</a></section></details></article><h3 id="Dynamic-Factor-Model"><a class="docs-heading-anchor" href="#Dynamic-Factor-Model">Dynamic Factor Model</a><a id="Dynamic-Factor-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Dynamic-Factor-Model" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_dfm_loglikelihood-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Bool}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._compute_dfm_loglikelihood-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, AbstractMatrix{T}, Bool}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._compute_dfm_loglikelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute Gaussian log-likelihood given factors and parameters.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L294">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._em_mstep-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractArray{T, 3}, AbstractArray{T, 3}, Int64, Int64, Bool}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._em_mstep-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractMatrix{T}, AbstractArray{T, 3}, AbstractArray{T, 3}, Int64, Int64, Bool}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._em_mstep</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>M-step: update loadings, VAR coefficients, and covariances.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L238">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._estimate_dfm_em-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._estimate_dfm_em-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._estimate_dfm_em</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>EM algorithm for maximum likelihood estimation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L183">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._estimate_dfm_twostep-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._estimate_dfm_twostep-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._estimate_dfm_twostep</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Two-step estimation: PCA for factors, then VAR on extracted factors.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L153">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.companion_matrix_factors-Union{Tuple{DynamicFactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.companion_matrix_factors-Union{Tuple{DynamicFactorModel{T}}, Tuple{T}} where T"><code>MacroEconometricModels.companion_matrix_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">companion_matrix_factors(model::DynamicFactorModel)</code></pre><p>Construct companion matrix for factor VAR dynamics.</p><p>The companion form converts VAR(p) to VAR(1): [F<em>t; F</em>{t-1}; ...] = C [F<em>{t-1}; F</em>{t-2}; ...] + [η_t; 0; ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L515-L522">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_dynamic_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_dynamic_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_dynamic_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_dynamic_factors(X, r, p; method=:twostep, standardize=true, max_iter=100, tol=1e-6)</code></pre><p>Estimate dynamic factor model with VAR(p) factor dynamics.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Data matrix (T × N)</li><li><code>r</code>: Number of factors</li><li><code>p</code>: Number of lags in factor VAR</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method::Symbol=:twostep</code>: Estimation method (:twostep or :em)</li><li><code>standardize::Bool=true</code>: Standardize data</li><li><code>max_iter::Int=100</code>: Maximum EM iterations (if method=:em)</li><li><code>tol::Float64=1e-6</code>: Convergence tolerance (if method=:em)</li><li><code>diagonal_idio::Bool=true</code>: Assume diagonal idiosyncratic covariance</li></ul><p><strong>Returns</strong></p><p><code>DynamicFactorModel</code> with factors, loadings, VAR coefficients, and diagnostics.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">dfm = estimate_dynamic_factors(X, 3, 2)  # 3 factors, VAR(2)
forecast(dfm, 12)  # 12-step ahead forecast</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L75-L100">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{DynamicFactorModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{DynamicFactorModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::DynamicFactorModel, h; ci_method=:none, conf_level=0.95, n_boot=1000, ci=false, ci_level=0.95)</code></pre><p>Forecast factors and observables h steps ahead.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Estimated dynamic factor model</li><li><code>h</code>: Forecast horizon</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>ci_method::Symbol=:none</code>: CI method — <code>:none</code>, <code>:theoretical</code>, <code>:bootstrap</code>, or <code>:simulation</code></li><li><code>conf_level::Real=0.95</code>: Confidence level for intervals</li><li><code>n_boot::Int=1000</code>: Bootstrap replications (for <code>:bootstrap</code> and <code>:simulation</code>)</li><li><code>ci::Bool=false</code>: Legacy keyword — <code>ci=true</code> maps to <code>ci_method=:simulation</code></li><li><code>ci_level::Real=0.95</code>: Legacy keyword — maps to <code>conf_level</code></li></ul><p><strong>Returns</strong></p><p><code>FactorForecast</code> with factor and observable forecasts (and CIs if requested).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">fc = forecast(dfm, 12; ci_method=:theoretical)
fc.observables       # h×N matrix of forecasts
fc.observables_lower # h×N lower CI bounds</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L352-L377">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ic_criteria_dynamic-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.ic_criteria_dynamic-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.ic_criteria_dynamic</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ic_criteria_dynamic(X, max_r, max_p; standardize=true, method=:twostep)</code></pre><p>Select (r, p) via AIC/BIC grid search over factor and lag combinations.</p><p><strong>Returns</strong></p><p>Named tuple with AIC/BIC matrices and optimal (r, p) combinations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L483-L490">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.is_stationary-Tuple{DynamicFactorModel}"><a class="docstring-binding" href="#MacroEconometricModels.is_stationary-Tuple{DynamicFactorModel}"><code>MacroEconometricModels.is_stationary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_stationary(model::DynamicFactorModel) -&gt; Bool</code></pre><p>Check if factor dynamics are stationary (max |eigenvalue| &lt; 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L533-L537">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.aic-Tuple{DynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.aic-Tuple{DynamicFactorModel}"><code>StatsAPI.aic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Akaike Information Criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L342">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.bic-Tuple{DynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.bic-Tuple{DynamicFactorModel}"><code>StatsAPI.bic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Bayesian Information Criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L345">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.dof-Tuple{DynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.dof-Tuple{DynamicFactorModel}"><code>StatsAPI.dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Degrees of freedom: N<em>r + r²</em>p + r(r+1)/2 + N.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L336">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.loglikelihood-Tuple{DynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.loglikelihood-Tuple{DynamicFactorModel}"><code>StatsAPI.loglikelihood</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Log-likelihood of the fitted model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L333">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{DynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{DynamicFactorModel}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L330">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict-Tuple{DynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.predict-Tuple{DynamicFactorModel}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Predicted values: F * Λ&#39;.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L313">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.r2-Union{Tuple{DynamicFactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.r2-Union{Tuple{DynamicFactorModel{T}}, Tuple{T}} where T"><code>StatsAPI.r2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>R² for each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L322">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.residuals-Union{Tuple{DynamicFactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.residuals-Union{Tuple{DynamicFactorModel{T}}, Tuple{T}} where T"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Residuals: X - predicted.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/dynamic.jl#L316">source</a></section></details></article><h3 id="Generalized-Dynamic-Factor-Model"><a class="docs-heading-anchor" href="#Generalized-Dynamic-Factor-Model">Generalized Dynamic Factor Model</a><a id="Generalized-Dynamic-Factor-Model-1"></a><a class="docs-heading-anchor-permalink" href="#Generalized-Dynamic-Factor-Model" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_common_spectral_density-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, AbstractMatrix}} where T"><a class="docstring-binding" href="#MacroEconometricModels._compute_common_spectral_density-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, AbstractMatrix}} where T"><code>MacroEconometricModels._compute_common_spectral_density</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute spectral density of common component from loadings and eigenvalues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_kernel_weights-Tuple{Int64, Symbol}"><a class="docstring-binding" href="#MacroEconometricModels._compute_kernel_weights-Tuple{Int64, Symbol}"><code>MacroEconometricModels._compute_kernel_weights</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute kernel weights for spectral smoothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._compute_variance_explained-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels._compute_variance_explained-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T"><code>MacroEconometricModels._compute_variance_explained</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute variance explained by first q factors (averaged across frequencies).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L283">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._estimate_spectral_density-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Symbol}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._estimate_spectral_density-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Symbol}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._estimate_spectral_density</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Estimate spectral density matrix with kernel smoothing.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L175">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._extract_time_domain_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Array{Complex{T}, 3}, Vector{T}}} where T"><a class="docstring-binding" href="#MacroEconometricModels._extract_time_domain_factors-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Array{Complex{T}, 3}, Vector{T}}} where T"><code>MacroEconometricModels._extract_time_domain_factors</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Extract time-domain factors via frequency-domain projection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._forecast_factors_ar-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._forecast_factors_ar-Union{Tuple{T}, Tuple{Matrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._forecast_factors_ar</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>AR(1) forecast for each factor series.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L491">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._reconstruct_time_domain-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, AbstractMatrix{T}}} where T"><a class="docstring-binding" href="#MacroEconometricModels._reconstruct_time_domain-Union{Tuple{T}, Tuple{Array{Complex{T}, 3}, AbstractMatrix{T}}} where T"><code>MacroEconometricModels._reconstruct_time_domain</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Reconstruct common component in time domain via inverse FFT.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._select_bandwidth-Tuple{Int64}"><a class="docstring-binding" href="#MacroEconometricModels._select_bandwidth-Tuple{Int64}"><code>MacroEconometricModels._select_bandwidth</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Automatic bandwidth selection: T^(1/3).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L168">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._spectral_eigendecomposition-Union{Tuple{Array{Complex{T}, 3}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels._spectral_eigendecomposition-Union{Tuple{Array{Complex{T}, 3}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels._spectral_eigendecomposition</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Eigendecomposition of spectral density at each frequency.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L217">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.common_variance_share-Union{Tuple{GeneralizedDynamicFactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.common_variance_share-Union{Tuple{GeneralizedDynamicFactorModel{T}}, Tuple{T}} where T"><code>MacroEconometricModels.common_variance_share</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">common_variance_share(model::GeneralizedDynamicFactorModel) -&gt; Vector</code></pre><p>Fraction of each variable&#39;s variance explained by the common component.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L513-L517">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_gdfm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_gdfm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_gdfm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_gdfm(X, q; standardize=true, bandwidth=0, kernel=:bartlett, r=0) -&gt; GeneralizedDynamicFactorModel</code></pre><p>Estimate Generalized Dynamic Factor Model using spectral methods.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Data matrix (T × N)</li><li><code>q</code>: Number of dynamic factors</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>standardize::Bool=true</code>: Standardize data</li><li><code>bandwidth::Int=0</code>: Kernel bandwidth (0 = automatic selection)</li><li><code>kernel::Symbol=:bartlett</code>: Kernel for spectral smoothing (:bartlett, :parzen, :tukey)</li><li><code>r::Int=0</code>: Number of static factors (0 = same as q)</li></ul><p><strong>Returns</strong></p><p><code>GeneralizedDynamicFactorModel</code> with common/idiosyncratic components and spectral loadings.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">gdfm = estimate_gdfm(X, 3)
common_variance_share(gdfm)  # Fraction of variance explained by common component</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L72-L95">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{GeneralizedDynamicFactorModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{GeneralizedDynamicFactorModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::GeneralizedDynamicFactorModel, h; method=:ar, ci_method=:none, conf_level=0.95, n_boot=1000)</code></pre><p>Forecast h steps ahead using AR extrapolation of factors.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Estimated GDFM</li><li><code>h</code>: Forecast horizon</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method::Symbol=:ar</code>: Forecasting method (currently only <code>:ar</code> supported)</li><li><code>ci_method::Symbol=:none</code>: CI method — <code>:none</code>, <code>:theoretical</code>, or <code>:bootstrap</code></li><li><code>conf_level::Real=0.95</code>: Confidence level for intervals</li><li><code>n_boot::Int=1000</code>: Bootstrap replications (for <code>:bootstrap</code>)</li></ul><p><strong>Returns</strong></p><p><code>FactorForecast</code> with factor and observable forecasts (and CIs if requested).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L355-L372">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ic_criteria_gdfm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.ic_criteria_gdfm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.ic_criteria_gdfm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ic_criteria_gdfm(X, max_q; standardize=true, bandwidth=0, kernel=:bartlett)</code></pre><p>Information criteria for selecting number of dynamic factors.</p><p>Uses eigenvalue ratio test and cumulative variance threshold.</p><p><strong>Returns</strong></p><p>Named tuple with:</p><ul><li><code>eigenvalue_ratios</code>: Ratios of consecutive eigenvalues</li><li><code>cumulative_variance</code>: Cumulative variance explained</li><li><code>q_ratio</code>: Optimal q from eigenvalue ratio</li><li><code>q_variance</code>: Optimal q from 90% variance threshold</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L315-L328">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.spectral_eigenvalue_plot_data-Tuple{GeneralizedDynamicFactorModel}"><a class="docstring-binding" href="#MacroEconometricModels.spectral_eigenvalue_plot_data-Tuple{GeneralizedDynamicFactorModel}"><code>MacroEconometricModels.spectral_eigenvalue_plot_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">spectral_eigenvalue_plot_data(model::GeneralizedDynamicFactorModel)</code></pre><p>Return data for plotting eigenvalues across frequencies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L523-L527">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.dof-Tuple{GeneralizedDynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.dof-Tuple{GeneralizedDynamicFactorModel}"><code>StatsAPI.dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Degrees of freedom.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L302">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{GeneralizedDynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{GeneralizedDynamicFactorModel}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L299">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.predict-Tuple{GeneralizedDynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.predict-Tuple{GeneralizedDynamicFactorModel}"><code>StatsAPI.predict</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Predicted values (common component).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L293">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.r2-Union{Tuple{GeneralizedDynamicFactorModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#StatsAPI.r2-Union{Tuple{GeneralizedDynamicFactorModel{T}}, Tuple{T}} where T"><code>StatsAPI.r2</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>R² for each variable.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L305">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.residuals-Tuple{GeneralizedDynamicFactorModel}"><a class="docstring-binding" href="#StatsAPI.residuals-Tuple{GeneralizedDynamicFactorModel}"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Residuals (idiosyncratic component).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/factor/generalized.jl#L296">source</a></section></details></article><hr/><h2 id="Panel-VAR"><a class="docs-heading-anchor" href="#Panel-VAR">Panel VAR</a><a id="Panel-VAR-1"></a><a class="docs-heading-anchor-permalink" href="#Panel-VAR" title="Permalink"></a></h2><h3 id="Estimation-2"><a class="docs-heading-anchor" href="#Estimation-2">Estimation</a><a class="docs-heading-anchor-permalink" href="#Estimation-2" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_pvar"><a class="docstring-binding" href="#MacroEconometricModels.estimate_pvar"><code>MacroEconometricModels.estimate_pvar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_pvar(d::PanelData{T}, p::Int; kwargs...) -&gt; PVARModel{T}</code></pre><p>Estimate Panel VAR(p) via GMM.</p><p><strong>Arguments</strong></p><ul><li><code>d::PanelData{T}</code> — balanced panel data (use <code>xtset</code> to construct)</li><li><code>p::Int</code> — number of lags</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dependent_vars::Union{Vector{String},Nothing}=nothing</code> — endogenous variable names (default: all)</li><li><code>predet_vars::Vector{String}=String[]</code> — predetermined variable names</li><li><code>exog_vars::Vector{String}=String[]</code> — strictly exogenous variable names</li><li><code>transformation::Symbol=:fd</code> — <code>:fd</code> (first-difference) or <code>:fod</code> (forward orthogonal deviations)</li><li><code>steps::Symbol=:twostep</code> — <code>:onestep</code>, <code>:twostep</code>, or <code>:mstep</code> (iterated)</li><li><code>system_instruments::Bool=false</code> — if true, use System GMM (Blundell-Bond)</li><li><code>system_constant::Bool=true</code> — include constant in level equation (System GMM)</li><li><code>min_lag_endo::Int=2</code> — minimum instrument lag for endogenous variables</li><li><code>max_lag_endo::Int=99</code> — maximum instrument lag (99 = all available)</li><li><code>collapse::Bool=false</code> — collapse instruments to limit proliferation</li><li><code>pca_instruments::Bool=false</code> — apply PCA reduction to instruments</li><li><code>pca_max_components::Int=0</code> — max PCA components (0 = auto)</li><li><code>max_iter::Int=100</code> — max iterations for iterated GMM</li></ul><p><strong>Returns</strong></p><ul><li><code>PVARModel{T}</code> with coefficient estimates, robust standard errors, and GMM internals</li></ul><p><strong>References</strong></p><ul><li>Arellano, M. &amp; Bond, S. (1991). Review of Economic Studies 58(2), 277-297.</li><li>Blundell, R. &amp; Bond, S. (1998). Journal of Econometrics 87(1), 115-143.</li><li>Windmeijer, F. (2005). Journal of Econometrics 126(1), 25-51.</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pd = xtset(df, :id, :time)
model = estimate_pvar(pd, 2; steps=:twostep)
model = estimate_pvar(pd, 1; system_instruments=true, steps=:twostep)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/pvar/estimation.jl#L30-L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_pvar_feols"><a class="docstring-binding" href="#MacroEconometricModels.estimate_pvar_feols"><code>MacroEconometricModels.estimate_pvar_feols</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_pvar_feols(d::PanelData{T}, p::Int; kwargs...) -&gt; PVARModel{T}</code></pre><p>Estimate Panel VAR(p) via Fixed Effects OLS (within estimator).</p><p>Simpler than GMM but subject to Nickell (1981) bias when T is small relative to N. Uses within-group demeaning to remove fixed effects, then pooled OLS with cluster-robust standard errors.</p><p><strong>Arguments</strong></p><ul><li><code>d::PanelData{T}</code> — panel data</li><li><code>p::Int</code> — number of lags</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>dependent_vars::Union{Vector{String},Nothing}=nothing</code> — endogenous variable names</li><li><code>predet_vars::Vector{String}=String[]</code> — predetermined variable names</li><li><code>exog_vars::Vector{String}=String[]</code> — strictly exogenous variable names</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pd = xtset(df, :id, :time)
model = estimate_pvar_feols(pd, 2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/pvar/estimation.jl#L510-L533">source</a></section></details></article><h3 id="Structural-Analysis"><a class="docs-heading-anchor" href="#Structural-Analysis">Structural Analysis</a><a id="Structural-Analysis-1"></a><a class="docs-heading-anchor-permalink" href="#Structural-Analysis" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pvar_oirf"><a class="docstring-binding" href="#MacroEconometricModels.pvar_oirf"><code>MacroEconometricModels.pvar_oirf</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvar_oirf(model::PVARModel{T}, H::Int) -&gt; Array{T, 3}</code></pre><p>Orthogonalized impulse response functions via Cholesky decomposition.</p><p>Ψ<em>h = Φ</em>h P where P = chol(Σ) is the lower Cholesky factor.</p><p>Returns H+1 × m × m array: <code>oirf[h+1, response, shock]</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model::PVARModel</code> — estimated PVAR</li><li><code>H::Int</code> — maximum horizon</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">oirf = pvar_oirf(model, 10)
oirf[1, :, :]  # impact response (h=0)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/pvar/analysis.jl#L88-L106">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pvar_girf"><a class="docstring-binding" href="#MacroEconometricModels.pvar_girf"><code>MacroEconometricModels.pvar_girf</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvar_girf(model::PVARModel{T}, H::Int) -&gt; Array{T, 3}</code></pre><p>Generalized impulse response functions (Pesaran &amp; Shin, 1998).</p><p>GIRF<em>h(j) = Φ</em>h Σ e<em>j / √σ</em>jj</p><p>where e<em>j is the j-th unit vector and σ</em>jj = Σ[j,j].</p><p>Returns H+1 × m × m array: <code>girf[h+1, response, shock]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/pvar/analysis.jl#L125-L135">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pvar_fevd"><a class="docstring-binding" href="#MacroEconometricModels.pvar_fevd"><code>MacroEconometricModels.pvar_fevd</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvar_fevd(model::PVARModel{T}, H::Int) -&gt; Array{T, 3}</code></pre><p>Forecast error variance decomposition based on OIRF.</p><p>Ω[l, k, h] = Σ<em>{j=0}^{h} (Ψ</em>j[l,k])² / MSE_h[l,l]</p><p>where MSE<em>h = Σ</em>{j=0}^{h} Φ<em>j Σ Φ</em>j&#39;.</p><p>Returns H+1 × m × m array: <code>fevd[h+1, variable, shock]</code>. Each row sums to 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">fv = pvar_fevd(model, 10)
sum(fv[11, 1, :])  # ≈ 1.0 (all shocks for var 1 at h=10)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/pvar/analysis.jl#L157-L173">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pvar_stability"><a class="docstring-binding" href="#MacroEconometricModels.pvar_stability"><code>MacroEconometricModels.pvar_stability</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvar_stability(model::PVARModel{T}) -&gt; PVARStability{T}</code></pre><p>Check stability of the PVAR by computing eigenvalues of the companion matrix. The system is stable if all eigenvalue moduli are strictly less than 1.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">stab = pvar_stability(model)
stab.is_stable  # true if all |λ| &lt; 1
stab.moduli     # sorted eigenvalue moduli</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/pvar/analysis.jl#L210-L222">source</a></section></details></article><h3 id="Bootstrap"><a class="docs-heading-anchor" href="#Bootstrap">Bootstrap</a><a id="Bootstrap-1"></a><a class="docs-heading-anchor-permalink" href="#Bootstrap" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pvar_bootstrap_irf"><a class="docstring-binding" href="#MacroEconometricModels.pvar_bootstrap_irf"><code>MacroEconometricModels.pvar_bootstrap_irf</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvar_bootstrap_irf(model::PVARModel{T}, H::Int;
                    irf_type::Symbol=:oirf, n_draws::Int=500,
                    ci::Real=0.95, rng::AbstractRNG=Random.default_rng()) -&gt; NamedTuple</code></pre><p>Group-level block bootstrap for PVAR impulse response confidence intervals.</p><p>Resamples N groups with replacement → re-estimates PVAR → computes IRF → collects pointwise quantiles.</p><p><strong>Arguments</strong></p><ul><li><code>model::PVARModel</code> — estimated PVAR</li><li><code>H::Int</code> — maximum IRF horizon</li></ul><p><strong>Keywords</strong></p><ul><li><code>irf_type::Symbol=:oirf</code> — <code>:oirf</code> or <code>:girf</code></li><li><code>n_draws::Int=500</code> — number of bootstrap replications</li><li><code>ci::Real=0.95</code> — confidence level</li><li><code>rng::AbstractRNG</code> — random number generator</li></ul><p><strong>Returns</strong></p><p>NamedTuple with:</p><ul><li><code>irf::Array{T,3}</code> — point estimate (H+1 × m × m)</li><li><code>lower::Array{T,3}</code> — lower CI bound</li><li><code>upper::Array{T,3}</code> — upper CI bound</li><li><code>draws::Array{T,4}</code> — all bootstrap draws (n_draws × H+1 × m × m)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/pvar/bootstrap.jl#L30-L56">source</a></section></details></article><h3 id="Specification-Tests"><a class="docs-heading-anchor" href="#Specification-Tests">Specification Tests</a><a id="Specification-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Specification-Tests" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pvar_hansen_j"><a class="docstring-binding" href="#MacroEconometricModels.pvar_hansen_j"><code>MacroEconometricModels.pvar_hansen_j</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvar_hansen_j(model::PVARModel{T}) -&gt; PVARTestResult{T}</code></pre><p>Hansen (1982) J-test for overidentifying restrictions.</p><p>J = (Σ<em>i Z</em>i&#39; e<em>i)&#39; W (Σ</em>i Z<em>i&#39; e</em>i) ~ χ²(q - k)</p><p>where q = number of instruments, k = number of parameters per equation.</p><p>H0: All moment conditions are valid. H1: Some moment conditions are invalid.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">j = pvar_hansen_j(model)
j.pvalue &gt; 0.05  # fail to reject → instruments valid</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/pvar_hansen_j.jl#L23-L40">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pvar_mmsc"><a class="docstring-binding" href="#MacroEconometricModels.pvar_mmsc"><code>MacroEconometricModels.pvar_mmsc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvar_mmsc(model::PVARModel{T}; hq_criterion::Real=2.1) -&gt; NamedTuple</code></pre><p>Andrews-Lu (2001) Model and Moment Selection Criteria based on Hansen J-statistic.</p><p>MMSC<em>BIC  = J - (c - b) × log(n) MMSC</em>AIC  = J - (c - b) × 2 MMSC_HQIC = J - Q(c - b) × log(log(n))</p><p>Lower values are preferred.</p><p><strong>Returns</strong></p><p>NamedTuple <code>(bic, aic, hqic)</code> of MMSC values.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">mmsc = pvar_mmsc(model)
mmsc.bic   # MMSC-BIC value</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/pvar_mmsc.jl#L23-L42">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pvar_lag_selection"><a class="docstring-binding" href="#MacroEconometricModels.pvar_lag_selection"><code>MacroEconometricModels.pvar_lag_selection</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">pvar_lag_selection(d::PanelData{T}, max_p::Int; kwargs...) -&gt; NamedTuple</code></pre><p>Select optimal PVAR lag order by estimating models for p = 1, ..., max_p and comparing Andrews-Lu MMSC criteria.</p><p><strong>Returns</strong></p><p>NamedTuple with:</p><ul><li><code>table::Matrix</code> — comparison table (max_p × 4: p, BIC, AIC, HQIC)</li><li><code>best_bic::Int</code>, <code>best_aic::Int</code>, <code>best_hqic::Int</code> — optimal lag orders</li><li><code>models::Vector{PVARModel}</code> — estimated models</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">sel = pvar_lag_selection(pd, 4)
sel.best_bic  # optimal lag by BIC</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/pvar_lag_selection.jl#L23-L40">source</a></section></details></article><h3 id="GMM-Utilities"><a class="docs-heading-anchor" href="#GMM-Utilities">GMM Utilities</a><a id="GMM-Utilities-1"></a><a class="docs-heading-anchor-permalink" href="#GMM-Utilities" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.linear_gmm_solve"><a class="docstring-binding" href="#MacroEconometricModels.linear_gmm_solve"><code>MacroEconometricModels.linear_gmm_solve</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">linear_gmm_solve(S_ZX::Matrix{T}, S_Zy::AbstractVecOrMat{T},
                  W::Matrix{T}) -&gt; Vector{T}</code></pre><p>Solve linear GMM analytically: E[Z&#39;(y - Xβ)] = 0.</p><p>Given pre-aggregated cross-products S<em>ZX = Σ</em>i Z<em>i&#39;X</em>i and S<em>Zy = Σ</em>i Z<em>i&#39;y</em>i:</p><pre><code class="nohighlight hljs">β = (S_ZX&#39; W S_ZX)⁻¹ S_ZX&#39; W S_Zy</code></pre><p><strong>Arguments</strong></p><ul><li><code>S_ZX</code> — q × k aggregated instrument-regressor cross-product</li><li><code>S_Zy</code> — q × 1 (or q-vector) aggregated instrument-response cross-product</li><li><code>W</code> — q × q weighting matrix</li></ul><p><strong>Returns</strong></p><ul><li>Parameter vector β (length k)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L667-L684">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.gmm_sandwich_vcov"><a class="docstring-binding" href="#MacroEconometricModels.gmm_sandwich_vcov"><code>MacroEconometricModels.gmm_sandwich_vcov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">gmm_sandwich_vcov(S_ZX::Matrix{T}, W::Matrix{T},
                   D_e::Matrix{T}) -&gt; Matrix{T}</code></pre><p>Robust sandwich covariance for one-step GMM:</p><pre><code class="nohighlight hljs">V = (S_ZX&#39; W S_ZX)⁻¹ S_ZX&#39; W D_e W S_ZX (S_ZX&#39; W S_ZX)⁻¹</code></pre><p>where D<em>e = Σ</em>i (Z<em>i e</em>i)(Z<em>i e</em>i)&#39; is the robust moment covariance.</p><p><strong>Arguments</strong></p><ul><li><code>S_ZX</code> — q × k aggregated instrument-regressor cross-product</li><li><code>W</code> — q × q weighting matrix</li><li><code>D_e</code> — q × q robust moment covariance</li></ul><p><strong>Returns</strong></p><ul><li>k × k covariance matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L692-L709">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.andrews_lu_mmsc"><a class="docstring-binding" href="#MacroEconometricModels.andrews_lu_mmsc"><code>MacroEconometricModels.andrews_lu_mmsc</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">andrews_lu_mmsc(j_stat::T, n_instruments::Int, n_params::Int,
                 n_obs::Int; hq_criterion::Real=2.1) -&gt; NamedTuple</code></pre><p>Andrews-Lu (2001) Model and Moment Selection Criteria based on Hansen J-statistic.</p><pre><code class="nohighlight hljs">MMSC_BIC  = J - (c - b) × log(n)
MMSC_AIC  = J - (c - b) × 2
MMSC_HQIC = J - Q(c - b) × log(log(n))</code></pre><p>where c = moment conditions, b = parameters, n = observations. Lower values indicate better model specification.</p><p><strong>Arguments</strong></p><ul><li><code>j_stat</code> — Hansen J-test statistic</li><li><code>n_instruments</code> — number of moment conditions (c)</li><li><code>n_params</code> — number of parameters (b)</li><li><code>n_obs</code> — number of observations (n)</li><li><code>hq_criterion</code> — penalty parameter Q for HQIC (default 2.1)</li></ul><p><strong>Returns</strong></p><p>NamedTuple <code>(bic, aic, hqic)</code>.</p><p><strong>References</strong></p><ul><li>Andrews, D. &amp; Lu, B. (2001). Journal of Econometrics 101(1), 123-164.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L716-L741">source</a></section></details></article><hr/><h2 id="GMM-Estimation"><a class="docs-heading-anchor" href="#GMM-Estimation">GMM Estimation</a><a id="GMM-Estimation-1"></a><a class="docs-heading-anchor-permalink" href="#GMM-Estimation" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels.andrews_lu_mmsc-Union{Tuple{T}, Tuple{T, Int64, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.andrews_lu_mmsc-Union{Tuple{T}, Tuple{T, Int64, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.andrews_lu_mmsc</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">andrews_lu_mmsc(j_stat::T, n_instruments::Int, n_params::Int,
                 n_obs::Int; hq_criterion::Real=2.1) -&gt; NamedTuple</code></pre><p>Andrews-Lu (2001) Model and Moment Selection Criteria based on Hansen J-statistic.</p><pre><code class="nohighlight hljs">MMSC_BIC  = J - (c - b) × log(n)
MMSC_AIC  = J - (c - b) × 2
MMSC_HQIC = J - Q(c - b) × log(log(n))</code></pre><p>where c = moment conditions, b = parameters, n = observations. Lower values indicate better model specification.</p><p><strong>Arguments</strong></p><ul><li><code>j_stat</code> — Hansen J-test statistic</li><li><code>n_instruments</code> — number of moment conditions (c)</li><li><code>n_params</code> — number of parameters (b)</li><li><code>n_obs</code> — number of observations (n)</li><li><code>hq_criterion</code> — penalty parameter Q for HQIC (default 2.1)</li></ul><p><strong>Returns</strong></p><p>NamedTuple <code>(bic, aic, hqic)</code>.</p><p><strong>References</strong></p><ul><li>Andrews, D. &amp; Lu, B. (2001). Journal of Econometrics 101(1), 123-164.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L716-L741">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_gmm-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_gmm-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_gmm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_gmm(moment_fn::Function, theta0::AbstractVector{T}, data;
             weighting::Symbol=:two_step, max_iter::Int=100,
             tol::T=T(1e-8), hac::Bool=true, bandwidth::Int=0) -&gt; GMMModel{T}</code></pre><p>Estimate parameters via Generalized Method of Moments.</p><p>Minimizes: Q(θ) = g(θ)&#39;W g(θ) where g(θ) = (1/n) Σᵢ gᵢ(θ)</p><p>Arguments:</p><ul><li>moment_fn: Function (theta, data) -&gt; Matrix of moment conditions (n × q)</li><li>theta0: Initial parameter guess</li><li>data: Data passed to moment function</li><li>weighting: Weighting method (:identity, :optimal, :two_step, :iterated)</li><li>max_iter: Maximum iterations for optimization and/or iterated GMM</li><li>tol: Convergence tolerance</li><li>hac: Use HAC correction for optimal weighting</li><li>bandwidth: HAC bandwidth (0 = automatic)</li></ul><p>Returns:</p><ul><li>GMMModel with estimates, covariance, and J-test results</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L387-L408">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_lp_gmm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.estimate_lp_gmm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.estimate_lp_gmm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">estimate_lp_gmm(Y::AbstractMatrix{T}, shock_var::Int, horizon::Int;
                lags::Int=4, weighting::Symbol=:two_step) -&gt; Vector{GMMModel{T}}</code></pre><p>Estimate Local Projection via GMM.</p><p>Returns a GMMModel for each horizon.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L632-L639">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.gmm_objective-Union{Tuple{T}, Tuple{AbstractVector{T}, Function, Any, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.gmm_objective-Union{Tuple{T}, Tuple{AbstractVector{T}, Function, Any, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.gmm_objective</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gmm_objective(theta::AbstractVector{T}, moment_fn::Function, data,
              W::AbstractMatrix{T}) -&gt; T</code></pre><p>Compute GMM objective: Q(θ) = g(θ)&#39;W g(θ)</p><p>where g(θ) = (1/n) Σᵢ gᵢ(θ,data)</p><p>Arguments:</p><ul><li>theta: Parameter vector</li><li>moment_fn: Function (theta, data) -&gt; Matrix of moment conditions (n × q)</li><li>data: Data passed to moment function</li><li>W: Weighting matrix (q × q)</li></ul><p>Returns:</p><ul><li>GMM objective value</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L211-L227">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.gmm_sandwich_vcov-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.gmm_sandwich_vcov-Union{Tuple{T}, Tuple{Matrix{T}, Matrix{T}, Matrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.gmm_sandwich_vcov</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gmm_sandwich_vcov(S_ZX::Matrix{T}, W::Matrix{T},
                   D_e::Matrix{T}) -&gt; Matrix{T}</code></pre><p>Robust sandwich covariance for one-step GMM:</p><pre><code class="nohighlight hljs">V = (S_ZX&#39; W S_ZX)⁻¹ S_ZX&#39; W D_e W S_ZX (S_ZX&#39; W S_ZX)⁻¹</code></pre><p>where D<em>e = Σ</em>i (Z<em>i e</em>i)(Z<em>i e</em>i)&#39; is the robust moment covariance.</p><p><strong>Arguments</strong></p><ul><li><code>S_ZX</code> — q × k aggregated instrument-regressor cross-product</li><li><code>W</code> — q × q weighting matrix</li><li><code>D_e</code> — q × q robust moment covariance</li></ul><p><strong>Returns</strong></p><ul><li>k × k covariance matrix</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L692-L709">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.gmm_summary-Union{Tuple{GMMModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.gmm_summary-Union{Tuple{GMMModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.gmm_summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">gmm_summary(model::GMMModel{T}) -&gt; NamedTuple</code></pre><p>Summary statistics for GMM estimation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L556-L560">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identity_weighting-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.identity_weighting-Union{Tuple{Int64}, Tuple{T}, Tuple{Int64, Type{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.identity_weighting</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">identity_weighting(n_moments::Int, ::Type{T}=Float64) -&gt; Matrix{T}</code></pre><p>Identity weighting matrix (one-step GMM).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L239-L243">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.j_test-Union{Tuple{GMMModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.j_test-Union{Tuple{GMMModel{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.j_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">j_test(model::GMMModel{T}) -&gt; NamedTuple</code></pre><p>Hansen&#39;s J-test for overidentifying restrictions.</p><p>H0: All moment conditions are valid (E[g(θ₀)] = 0) H1: Some moment conditions are violated</p><p>Returns:</p><ul><li>J_stat: Test statistic</li><li>p_value: p-value from chi-squared distribution</li><li>df: Degrees of freedom (n<em>moments - n</em>params)</li><li>reject_05: Whether to reject at 5% level</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L530-L543">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.linear_gmm_solve-Union{Tuple{T}, Tuple{Matrix{T}, AbstractVecOrMat{T}, Matrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.linear_gmm_solve-Union{Tuple{T}, Tuple{Matrix{T}, AbstractVecOrMat{T}, Matrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.linear_gmm_solve</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">linear_gmm_solve(S_ZX::Matrix{T}, S_Zy::AbstractVecOrMat{T},
                  W::Matrix{T}) -&gt; Vector{T}</code></pre><p>Solve linear GMM analytically: E[Z&#39;(y - Xβ)] = 0.</p><p>Given pre-aggregated cross-products S<em>ZX = Σ</em>i Z<em>i&#39;X</em>i and S<em>Zy = Σ</em>i Z<em>i&#39;y</em>i:</p><pre><code class="nohighlight hljs">β = (S_ZX&#39; W S_ZX)⁻¹ S_ZX&#39; W S_Zy</code></pre><p><strong>Arguments</strong></p><ul><li><code>S_ZX</code> — q × k aggregated instrument-regressor cross-product</li><li><code>S_Zy</code> — q × 1 (or q-vector) aggregated instrument-response cross-product</li><li><code>W</code> — q × q weighting matrix</li></ul><p><strong>Returns</strong></p><ul><li>Parameter vector β (length k)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L667-L684">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lp_gmm_moments-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Any, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.lp_gmm_moments-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64, Any, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.lp_gmm_moments</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">lp_gmm_moments(Y::AbstractMatrix{T}, shock_var::Int, h::Int, theta,
               lags::Int) -&gt; Matrix{T}</code></pre><p>Construct moment conditions for LP estimated via GMM.</p><p>Moments: E[Z<em>t * ε</em>{t+h}] = 0 where ε<em>{t+h} = y</em>{t+h} - θ&#39; * X_t and Z includes all exogenous variables.</p><p>This is useful when you need to impose cross-equation restrictions.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L578-L588">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.minimize_gmm-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.minimize_gmm-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any, AbstractMatrix{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.minimize_gmm</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">minimize_gmm(moment_fn::Function, theta0::AbstractVector{T}, data,
             W::AbstractMatrix{T}; max_iter::Int=100, tol::T=T(1e-8)) -&gt; NamedTuple</code></pre><p>Minimize GMM objective using gradient descent with BFGS-like updates.</p><p>Returns:</p><ul><li>theta: Minimizer</li><li>objective: Final objective value</li><li>converged: Convergence flag</li><li>iterations: Number of iterations</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L300-L311">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.numerical_gradient-Union{Tuple{T}, Tuple{Function, AbstractVector{T}}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.numerical_gradient-Union{Tuple{T}, Tuple{Function, AbstractVector{T}}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.numerical_gradient</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">numerical_gradient(f::Function, x::AbstractVector{T}; eps::T=T(1e-7)) -&gt; Matrix{T}</code></pre><p>Compute numerical gradient (Jacobian) of function f at point x using central differences.</p><p>Arguments:</p><ul><li>f: Function that takes vector x and returns vector (moment conditions)</li><li>x: Point at which to evaluate gradient</li><li>eps: Step size for finite differences</li></ul><p>Returns:</p><ul><li>Jacobian matrix (n<em>moments × n</em>params)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L175-L187">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.optimal_weighting_matrix-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.optimal_weighting_matrix-Union{Tuple{T}, Tuple{Function, AbstractVector{T}, Any}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.optimal_weighting_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">optimal_weighting_matrix(moment_fn::Function, theta::AbstractVector{T}, data;
                         hac::Bool=true, bandwidth::Int=0) -&gt; Matrix{T}</code></pre><p>Compute optimal GMM weighting matrix: W = inv(Var(g)).</p><p>For i.i.d. data: W = inv((1/n) Σᵢ gᵢ gᵢ&#39;) For time series: Uses HAC estimation with Newey-West kernel.</p><p>Arguments:</p><ul><li>moment_fn: Moment function</li><li>theta: Current parameter estimate</li><li>data: Data</li><li>hac: Use HAC correction for serial correlation</li><li>bandwidth: HAC bandwidth (0 = automatic)</li></ul><p>Returns:</p><ul><li>Optimal weighting matrix (q × q)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/gmm/gmm.jl#L248-L266">source</a></section></details></article><hr/><h2 id="Unit-Root-and-Cointegration-Tests"><a class="docs-heading-anchor" href="#Unit-Root-and-Cointegration-Tests">Unit Root and Cointegration Tests</a><a id="Unit-Root-and-Cointegration-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Unit-Root-and-Cointegration-Tests" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels.adf_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.adf_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.adf_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">adf_test(y; lags=:aic, max_lags=nothing, regression=:constant) -&gt; ADFResult</code></pre><p>Augmented Dickey-Fuller test for unit root.</p><p>Tests H₀: y has a unit root (non-stationary) against H₁: y is stationary.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>lags</code>: Number of augmenting lags, or :aic/:bic/:hqic for automatic selection</li><li><code>max_lags</code>: Maximum lags for automatic selection (default: floor(12*(T/100)^0.25))</li><li><code>regression</code>: Deterministic terms - :none, :constant (default), or :trend</li></ul><p><strong>Returns</strong></p><p><code>ADFResult</code> containing test statistic, p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk (has unit root)
result = adf_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀</code></pre><p><strong>References</strong></p><ul><li>Dickey, D. A., &amp; Fuller, W. A. (1979). Distribution of the estimators for autoregressive time series with a unit root. JASA, 74(366), 427-431.</li><li>MacKinnon, J. G. (2010). Critical values for cointegration tests. Queen&#39;s Economics Department Working Paper No. 1227.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/adf.jl#L23-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.kpss_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.kpss_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.kpss_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">kpss_test(y; regression=:constant, bandwidth=:auto) -&gt; KPSSResult</code></pre><p>Kwiatkowski-Phillips-Schmidt-Shin test for stationarity.</p><p>Tests H₀: y is stationary against H₁: y has a unit root.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :constant (level stationarity) or :trend (trend stationarity)</li><li><code>bandwidth</code>: Bartlett kernel bandwidth, or :auto for Newey-West selection</li></ul><p><strong>Returns</strong></p><p><code>KPSSResult</code> containing test statistic, p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200)  # Stationary series
result = kpss_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀ (stationarity)</code></pre><p><strong>References</strong></p><ul><li>Kwiatkowski, D., Phillips, P. C., Schmidt, P., &amp; Shin, Y. (1992). Testing the null hypothesis of stationarity against the alternative of a unit root. Journal of Econometrics, 54(1-3), 159-178.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/kpss.jl#L25-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.pp_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.pp_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.pp_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">pp_test(y; regression=:constant, bandwidth=:auto) -&gt; PPResult</code></pre><p>Phillips-Perron test for unit root with non-parametric correction.</p><p>Tests H₀: y has a unit root against H₁: y is stationary.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :none, :constant (default), or :trend</li><li><code>bandwidth</code>: Newey-West bandwidth, or :auto for automatic selection</li></ul><p><strong>Returns</strong></p><p><code>PPResult</code> containing test statistic (Zt), p-value, critical values, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))  # Random walk
result = pp_test(y)
result.pvalue &gt; 0.05  # Should fail to reject H₀</code></pre><p><strong>References</strong></p><ul><li>Phillips, P. C., &amp; Perron, P. (1988). Testing for a unit root in time series regression. Biometrika, 75(2), 335-346.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/pp.jl#L25-L50">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.za_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.za_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.za_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">za_test(y; regression=:both, trim=0.15, lags=:aic, max_lags=nothing) -&gt; ZAResult</code></pre><p>Zivot-Andrews test for unit root with endogenous structural break.</p><p>Tests H₀: y has a unit root without break against H₁: y is stationary with break.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: Type of break - :constant (intercept), :trend (slope), or :both</li><li><code>trim</code>: Trimming fraction for break search (default 0.15)</li><li><code>lags</code>: Number of augmenting lags, or :aic/:bic for automatic selection</li><li><code>max_lags</code>: Maximum lags for selection</li></ul><p><strong>Returns</strong></p><p><code>ZAResult</code> containing minimum t-statistic, break point, p-value, etc.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Series with structural break
y = vcat(randn(100), randn(100) .+ 2)
result = za_test(y; regression=:constant)</code></pre><p><strong>References</strong></p><ul><li>Zivot, E., &amp; Andrews, D. W. K. (1992). Further evidence on the great crash, the oil-price shock, and the unit-root hypothesis. JBES, 10(3), 251-270.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/za.jl#L25-L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ngperron_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.ngperron_test-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.ngperron_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">ngperron_test(y; regression=:constant) -&gt; NgPerronResult</code></pre><p>Ng-Perron unit root tests with GLS detrending (MZα, MZt, MSB, MPT).</p><p>Tests H₀: y has a unit root against H₁: y is stationary. These tests have better size properties than ADF/PP in small samples.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>regression</code>: :constant (default) or :trend</li></ul><p><strong>Returns</strong></p><p><code>NgPerronResult</code> containing MZα, MZt, MSB, MPT statistics and critical values.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(100))
result = ngperron_test(y)
# Check if MZt rejects at 5%
result.MZt &lt; result.critical_values[:MZt][5]</code></pre><p><strong>References</strong></p><ul><li>Ng, S., &amp; Perron, P. (2001). Lag length selection and the construction of unit root tests with good size and power. Econometrica, 69(6), 1519-1554.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/ngperron.jl#L25-L51">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.johansen_test-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.johansen_test-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.johansen_test</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">johansen_test(Y, p; deterministic=:constant) -&gt; JohansenResult</code></pre><p>Johansen cointegration test for VAR system.</p><p>Tests for the number of cointegrating relationships among variables using trace and maximum eigenvalue tests.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n)</li><li><code>p</code>: Number of lags in the VECM representation</li><li><code>deterministic</code>: Specification for deterministic terms<ul><li>:none - No deterministic terms</li><li>:constant - Constant in cointegrating relation (default)</li><li>:trend - Linear trend in levels</li></ul></li></ul><p><strong>Returns</strong></p><p><code>JohansenResult</code> containing trace and max-eigenvalue statistics, cointegrating vectors, adjustment coefficients, and estimated rank.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs"># Generate cointegrated system
n, T = 3, 200
Y = randn(T, n)
Y[:, 2] = Y[:, 1] + 0.1 * randn(T)  # Y2 cointegrated with Y1

result = johansen_test(Y, 2)
result.rank  # Should detect 1 or 2 cointegrating relations</code></pre><p><strong>References</strong></p><ul><li>Johansen, S. (1991). Estimation and hypothesis testing of cointegration vectors in Gaussian vector autoregressive models. Econometrica, 59(6), 1551-1580.</li><li>Osterwald-Lenum, M. (1992). A note with quantiles of the asymptotic distribution of the ML cointegration rank test statistics. Oxford BEJM.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/johansen.jl#L25-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.is_stationary-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.is_stationary-Union{Tuple{VARModel{T}}, Tuple{T}} where T"><code>MacroEconometricModels.is_stationary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">is_stationary(model::VARModel) -&gt; VARStationarityResult</code></pre><p>Check if estimated VAR model is stationary.</p><p>A VAR(p) is stationary if and only if all eigenvalues of the companion matrix have modulus strictly less than 1.</p><p><strong>Returns</strong></p><p><code>VARStationarityResult</code> with:</p><ul><li><code>is_stationary</code>: Boolean indicating stationarity</li><li><code>eigenvalues</code>: Complex eigenvalues of companion matrix</li><li><code>max_modulus</code>: Maximum eigenvalue modulus</li><li><code>companion_matrix</code>: The (np × np) companion form matrix</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = estimate_var(Y, 2)
result = is_stationary(model)
if !result.is_stationary
    println(&quot;Warning: VAR is non-stationary, max modulus = &quot;, result.max_modulus)
end</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/stationarity.jl#L25-L48">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_all_variables-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.test_all_variables-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.test_all_variables</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">test_all_variables(Y; test=:adf, kwargs...) -&gt; Vector</code></pre><p>Apply unit root test to each column of Y.</p><p><strong>Arguments</strong></p><ul><li><code>Y</code>: Data matrix (T × n)</li><li><code>test</code>: Test to apply (:adf, :kpss, :pp, :za, :ngperron)</li><li><code>kwargs...</code>: Additional arguments passed to the test</li></ul><p><strong>Returns</strong></p><p>Vector of test results, one per variable.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Y = randn(200, 3)
Y[:, 1] = cumsum(Y[:, 1])  # Make first column non-stationary
results = test_all_variables(Y; test=:adf)
[r.pvalue for r in results]  # P-values for each variable</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/convenience.jl#L88-L108">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.unit_root_summary-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.unit_root_summary-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.unit_root_summary</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">unit_root_summary(y; tests=[:adf, :kpss, :pp], kwargs...) -&gt; NamedTuple</code></pre><p>Run multiple unit root tests and return summary with PrettyTables output.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>tests</code>: Vector of test symbols to run (default: [:adf, :kpss, :pp])</li><li><code>kwargs...</code>: Additional arguments passed to individual tests</li></ul><p><strong>Returns</strong></p><p>NamedTuple with test results, conclusion, and summary table.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = cumsum(randn(200))
summary = unit_root_summary(y)
summary.conclusion  # Overall conclusion</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/convenience.jl#L25-L44">source</a></section></details></article><hr/><h2 id="Model-Comparison-Tests"><a class="docs-heading-anchor" href="#Model-Comparison-Tests">Model Comparison Tests</a><a id="Model-Comparison-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Comparison-Tests" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lr_test"><a class="docstring-binding" href="#MacroEconometricModels.lr_test"><code>MacroEconometricModels.lr_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lr_test(m1, m2) -&gt; LRTestResult</code></pre><p>Likelihood ratio test for nested models.</p><p>Computes LR = -2(ℓ<em>R - ℓ</em>U) where the restricted model has fewer parameters. Under H₀ (restricted model is correct), LR ~ χ²(df) where df = dof<em>U - dof</em>R.</p><p>Works for <strong>any</strong> two models implementing <code>loglikelihood</code>, <code>dof</code>, and <code>nobs</code> from StatsAPI. Automatically determines which model is restricted by comparing degrees of freedom.</p><p><strong>Arguments</strong></p><ul><li><code>m1</code>, <code>m2</code>: Two fitted models (order does not matter)</li></ul><p><strong>Returns</strong></p><p><a href="../api_types/#MacroEconometricModels.LRTestResult"><code>LRTestResult</code></a> with test statistic, p-value, and model details.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ar2 = estimate_ar(y, 2; method=:mle)
ar4 = estimate_ar(y, 4; method=:mle)
result = lr_test(ar2, ar4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/model_comparison.jl#L117-L141">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.lm_test"><a class="docstring-binding" href="#MacroEconometricModels.lm_test"><code>MacroEconometricModels.lm_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">lm_test(m1, m2) -&gt; LMTestResult</code></pre><p>Lagrange multiplier (score) test for nested models.</p><p>Evaluates the score of the unrestricted log-likelihood at the restricted parameter estimates. Under H₀, LM = s&#39;(-H)⁻¹s ~ χ²(df) where df = dof<em>U - dof</em>R.</p><p>Automatically determines restricted/unrestricted by comparing <code>dof</code>. Dispatches to model-family specific implementations for ARIMA, VAR, and volatility models.</p><p><strong>Supported model pairs</strong></p><ul><li><code>AbstractARIMAModel</code> × <code>AbstractARIMAModel</code> (same differencing order <code>d</code>)</li><li><code>VARModel</code> × <code>VARModel</code> (different lag orders, same data)</li><li><code>ARCHModel</code> × <code>ARCHModel</code>, <code>GARCHModel</code> × <code>GARCHModel</code></li><li><code>ARCHModel</code> × <code>GARCHModel</code> (cross-type nesting)</li><li><code>EGARCHModel</code> × <code>EGARCHModel</code>, <code>GJRGARCHModel</code> × <code>GJRGARCHModel</code></li></ul><p><strong>Arguments</strong></p><ul><li><code>m1</code>, <code>m2</code>: Two fitted models from the same family (order does not matter)</li></ul><p><strong>Returns</strong></p><p><a href="../api_types/#MacroEconometricModels.LMTestResult"><code>LMTestResult</code></a> with test statistic, p-value, and score norm diagnostic.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">ar2 = estimate_ar(y, 2; method=:mle)
ar4 = estimate_ar(y, 4; method=:mle)
result = lm_test(ar2, ar4)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/model_comparison.jl#L411-L441">source</a></section></details></article><hr/><h2 id="Granger-Causality-Tests"><a class="docs-heading-anchor" href="#Granger-Causality-Tests">Granger Causality Tests</a><a id="Granger-Causality-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Granger-Causality-Tests" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels.granger_test"><a class="docstring-binding" href="#MacroEconometricModels.granger_test"><code>MacroEconometricModels.granger_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">granger_test(model::VARModel, cause::Int, effect::Int) -&gt; GrangerCausalityResult</code></pre><p>Test whether variable <code>cause</code> Granger-causes variable <code>effect</code> in a VAR model.</p><p>H₀: A₁[effect, cause] = A₂[effect, cause] = ... = Aₚ[effect, cause] = 0 H₁: At least one lag coefficient is nonzero</p><p>Uses a Wald χ² test with df = p (number of lags).</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Estimated <code>VARModel</code></li><li><code>cause</code>: Index of the causing variable (1-based)</li><li><code>effect</code>: Index of the effect variable (1-based)</li></ul><p><strong>Returns</strong></p><p><a href="../api_types/#MacroEconometricModels.GrangerCausalityResult"><code>GrangerCausalityResult</code></a> with Wald statistic, p-value, and test details.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Y = randn(200, 3)
m = estimate_var(Y, 2)
g = granger_test(m, 1, 2)  # does variable 1 Granger-cause variable 2?</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/granger.jl#L78-L102">source</a></section><section><div><pre><code class="language-julia hljs">granger_test(model::VARModel, cause::Vector{Int}, effect::Int) -&gt; GrangerCausalityResult</code></pre><p>Test whether a group of variables <code>cause</code> jointly Granger-cause variable <code>effect</code>.</p><p>H₀: All lag coefficients from cause variables to the effect equation are zero H₁: At least one lag coefficient is nonzero</p><p>Uses a Wald χ² test with df = p × length(cause).</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Estimated <code>VARModel</code></li><li><code>cause</code>: Indices of the causing variables (1-based)</li><li><code>effect</code>: Index of the effect variable (1-based)</li></ul><p><strong>Returns</strong></p><p><a href="../api_types/#MacroEconometricModels.GrangerCausalityResult"><code>GrangerCausalityResult</code></a> with Wald statistic, p-value, and test details.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Y = randn(200, 4)
m = estimate_var(Y, 2)
g = granger_test(m, [1, 2], 3)  # do variables 1 and 2 jointly Granger-cause variable 3?</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/granger.jl#L118-L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.granger_test_all"><a class="docstring-binding" href="#MacroEconometricModels.granger_test_all"><code>MacroEconometricModels.granger_test_all</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">granger_test_all(model::VARModel) -&gt; Matrix{Union{GrangerCausalityResult, Nothing}}</code></pre><p>Compute pairwise Granger causality tests for all variable pairs in a VAR model.</p><p>Returns an n×n matrix where entry [i,j] tests whether variable j Granger-causes variable i. Diagonal entries are <code>nothing</code>.</p><p><strong>Arguments</strong></p><ul><li><code>model</code>: Estimated <code>VARModel</code></li></ul><p><strong>Returns</strong></p><p>n×n matrix of <a href="../api_types/#MacroEconometricModels.GrangerCausalityResult"><code>GrangerCausalityResult</code></a> (or <code>nothing</code> on diagonal).</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">Y = randn(200, 3)
m = estimate_var(Y, 2)
results = granger_test_all(m)
results[2, 1]  # does variable 1 Granger-cause variable 2?</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/granger.jl#L196-L217">source</a></section></details></article><hr/><h2 id="Volatility-Models"><a class="docs-heading-anchor" href="#Volatility-Models">Volatility Models</a><a id="Volatility-Models-1"></a><a class="docs-heading-anchor-permalink" href="#Volatility-Models" title="Permalink"></a></h2><h3 id="ARCH-Estimation-and-Diagnostics"><a class="docs-heading-anchor" href="#ARCH-Estimation-and-Diagnostics">ARCH Estimation and Diagnostics</a><a id="ARCH-Estimation-and-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#ARCH-Estimation-and-Diagnostics" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_arch"><a class="docstring-binding" href="#MacroEconometricModels.estimate_arch"><code>MacroEconometricModels.estimate_arch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_arch(y, q; method=:mle) -&gt; ARCHModel</code></pre><p>Estimate ARCH(q) model via Maximum Likelihood.</p><p>σ²ₜ = ω + α₁ε²ₜ₋₁ + ... + αqε²ₜ₋q</p><p>Uses two-stage optimization: NelderMead initialization → LBFGS refinement.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>q</code>: ARCH order (≥ 1)</li><li><code>method</code>: Estimation method (currently only <code>:mle</code>)</li></ul><p><strong>Returns</strong></p><p><code>ARCHModel</code> with estimated parameters and conditional variances.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(500)
model = estimate_arch(y, 1)
println(&quot;ω = &quot;, model.omega, &quot;, α₁ = &quot;, model.alpha[1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/estimation.jl#L121-L144">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.arch_lm_test"><a class="docstring-binding" href="#MacroEconometricModels.arch_lm_test"><code>MacroEconometricModels.arch_lm_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">arch_lm_test(y_or_model, q=5)</code></pre><p>ARCH-LM test for conditional heteroskedasticity (Engle 1982).</p><p>H₀: No ARCH effects (α₁ = ... = αq = 0) H₁: ARCH(q) effects present</p><p>Test statistic: T·R² from regression of ε²ₜ on ε²ₜ₋₁,...,ε²ₜ₋q, distributed χ²(q).</p><p><strong>Arguments</strong></p><ul><li><code>y_or_model</code>: Raw data vector or AbstractVolatilityModel (uses standardized residuals)</li><li><code>q</code>: Number of lags (default 5)</li></ul><p><strong>Returns</strong></p><p>Named tuple <code>(statistic, pvalue, q)</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia hljs">result = arch_lm_test(randn(500), 5)
println(&quot;p-value: &quot;, result.pvalue)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/arch_diagnostics.jl#L27-L49">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.ljung_box_squared"><a class="docstring-binding" href="#MacroEconometricModels.ljung_box_squared"><code>MacroEconometricModels.ljung_box_squared</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">ljung_box_squared(z_or_model, K=10)</code></pre><p>Ljung-Box test on squared (standardized) residuals.</p><p>H₀: No serial correlation in z²ₜ H₁: Serial correlation present in z²ₜ</p><p>Test statistic: Q = n(n+2) Σₖ ρ̂²ₖ/(n-k), distributed χ²(K).</p><p><strong>Arguments</strong></p><ul><li><code>z_or_model</code>: Standardized residuals vector or AbstractVolatilityModel</li><li><code>K</code>: Number of lags (default 10)</li></ul><p><strong>Returns</strong></p><p>Named tuple <code>(statistic, pvalue, K)</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/arch_diagnostics.jl#L97-L113">source</a></section></details></article><h3 id="GARCH-Estimation-and-Diagnostics"><a class="docs-heading-anchor" href="#GARCH-Estimation-and-Diagnostics">GARCH Estimation and Diagnostics</a><a id="GARCH-Estimation-and-Diagnostics-1"></a><a class="docs-heading-anchor-permalink" href="#GARCH-Estimation-and-Diagnostics" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_garch"><a class="docstring-binding" href="#MacroEconometricModels.estimate_garch"><code>MacroEconometricModels.estimate_garch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_garch(y, p=1, q=1; method=:mle) -&gt; GARCHModel</code></pre><p>Estimate GARCH(p,q) model via Maximum Likelihood (Bollerslev 1986).</p><p>σ²ₜ = ω + α₁ε²ₜ₋₁ + ... + αqε²ₜ₋q + β₁σ²ₜ₋₁ + ... + βpσ²ₜ₋p</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: GARCH order (default 1)</li><li><code>q</code>: ARCH order (default 1)</li><li><code>method</code>: Estimation method (currently only <code>:mle</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = estimate_garch(y, 1, 1)
println(&quot;Persistence: &quot;, persistence(model))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/estimation.jl#L203-L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_egarch"><a class="docstring-binding" href="#MacroEconometricModels.estimate_egarch"><code>MacroEconometricModels.estimate_egarch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_egarch(y, p=1, q=1; method=:mle) -&gt; EGARCHModel</code></pre><p>Estimate EGARCH(p,q) model via Maximum Likelihood (Nelson 1991).</p><p>log(σ²ₜ) = ω + Σαᵢ(|zₜ₋ᵢ| - E|z|) + Σγᵢzₜ₋ᵢ + Σβⱼlog(σ²ₜ₋ⱼ)</p><p>The γ parameters capture leverage effects (typically γ &lt; 0 for equities).</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: GARCH order (default 1)</li><li><code>q</code>: ARCH order (default 1)</li><li><code>method</code>: Estimation method (currently only <code>:mle</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = estimate_egarch(y, 1, 1)
println(&quot;Leverage: &quot;, model.gamma[1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/estimation.jl#L296-L316">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_gjr_garch"><a class="docstring-binding" href="#MacroEconometricModels.estimate_gjr_garch"><code>MacroEconometricModels.estimate_gjr_garch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_gjr_garch(y, p=1, q=1; method=:mle) -&gt; GJRGARCHModel</code></pre><p>Estimate GJR-GARCH(p,q) model via Maximum Likelihood (Glosten, Jagannathan &amp; Runkle 1993).</p><p>σ²ₜ = ω + Σ(αᵢ + γᵢI(εₜ₋ᵢ&lt;0))ε²ₜ₋ᵢ + Σβⱼσ²ₜ₋ⱼ</p><p>γᵢ &gt; 0 captures the asymmetric (leverage) effect.</p><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>p</code>: GARCH order (default 1)</li><li><code>q</code>: ARCH order (default 1)</li><li><code>method</code>: Estimation method (currently only <code>:mle</code>)</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">model = estimate_gjr_garch(y, 1, 1)
println(&quot;Asymmetry: &quot;, model.gamma[1])</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/estimation.jl#L385-L405">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.news_impact_curve"><a class="docstring-binding" href="#MacroEconometricModels.news_impact_curve"><code>MacroEconometricModels.news_impact_curve</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">news_impact_curve(m; range=(-3,3), n_points=200)</code></pre><p>Compute the news impact curve: how a shock εₜ₋₁ maps to σ²ₜ, holding all else at unconditional values.</p><p>Returns named tuple <code>(shocks, variance)</code> where both are vectors of length <code>n_points</code>.</p><p><strong>Supported models</strong></p><ul><li><code>GARCHModel</code>: Symmetric parabola</li><li><code>GJRGARCHModel</code>: Asymmetric parabola (steeper for negative shocks)</li><li><code>EGARCHModel</code>: Asymmetric exponential curve</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/diagnostics.jl#L23-L34">source</a></section></details></article><h3 id="Stochastic-Volatility"><a class="docs-heading-anchor" href="#Stochastic-Volatility">Stochastic Volatility</a><a id="Stochastic-Volatility-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Volatility" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.estimate_sv"><a class="docstring-binding" href="#MacroEconometricModels.estimate_sv"><code>MacroEconometricModels.estimate_sv</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">estimate_sv(y; n_samples=2000, burnin=1000,
            dist=:normal, leverage=false,
            quantile_levels=[0.025, 0.5, 0.975]) -&gt; SVModel</code></pre><p>Estimate a Stochastic Volatility model via Kim-Shephard-Chib (1998) Gibbs sampler with Omori et al. (2007) 10-component mixture approximation.</p><p><strong>Model</strong></p><pre><code class="nohighlight hljs">yₜ = exp(hₜ/2) εₜ,       εₜ ~ N(0,1)
hₜ = μ + φ(hₜ₋₁ - μ) + σ_η ηₜ,  ηₜ ~ N(0,1)</code></pre><p><strong>Arguments</strong></p><ul><li><code>y</code>: Time series vector</li><li><code>n_samples</code>: Number of posterior samples to keep (default 2000)</li><li><code>burnin</code>: Number of burn-in iterations to discard (default 1000)</li><li><code>dist</code>: Error distribution (<code>:normal</code> or <code>:studentt</code>)</li><li><code>leverage</code>: Whether to include leverage effect (correlated innovations)</li><li><code>quantile_levels</code>: Quantile levels for volatility posterior</li></ul><p><strong>Example</strong></p><pre><code class="language-julia hljs">y = randn(200) .* exp.(cumsum(0.1 .* randn(200)) ./ 2)
model = estimate_sv(y; n_samples=1000)
println(&quot;φ = &quot;, mean(model.phi_post))</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/sv/estimation.jl#L394-L420">source</a></section></details></article><h3 id="Volatility-Forecasting"><a class="docs-heading-anchor" href="#Volatility-Forecasting">Volatility Forecasting</a><a id="Volatility-Forecasting-1"></a><a class="docs-heading-anchor-permalink" href="#Volatility-Forecasting" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARCHModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{ARCHModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(m::ARCHModel, h; conf_level=0.95, n_sim=10000) -&gt; VolatilityForecast</code></pre><p>Forecast conditional variance from an ARCH(q) model.</p><p>For h &gt; q, the forecast converges to the unconditional variance. Confidence intervals are computed via simulation.</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: Fitted ARCHModel</li><li><code>h</code>: Forecast horizon</li><li><code>conf_level</code>: Confidence level for intervals (default 0.95)</li><li><code>n_sim</code>: Number of simulation paths for CIs (default 10000)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/forecast.jl#L23-L36">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{EGARCHModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{EGARCHModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(m::EGARCHModel, h; conf_level=0.95, n_sim=10000) -&gt; VolatilityForecast</code></pre><p>Forecast conditional variance from an EGARCH(p,q) model via simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/forecast.jl#L77-L81">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{GARCHModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{GARCHModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(m::GARCHModel, h; conf_level=0.95, n_sim=10000) -&gt; VolatilityForecast</code></pre><p>Forecast conditional variance from a GARCH(p,q) model.</p><p>Uses analytical iteration for point forecasts and simulation for CIs. Point forecasts converge to unconditional variance as h → ∞.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/forecast.jl#L27-L34">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{GJRGARCHModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{GJRGARCHModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(m::GJRGARCHModel, h; conf_level=0.95, n_sim=10000) -&gt; VolatilityForecast</code></pre><p>Forecast conditional variance from a GJR-GARCH(p,q) model via simulation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/forecast.jl#L123-L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{SVModel{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{SVModel{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(m::SVModel, h; conf_level=0.95) -&gt; VolatilityForecast</code></pre><p>Posterior predictive forecast of volatility from an SV model.</p><p>For each posterior draw (μ, φ, σ<em>η), simulates the log-volatility path forward h</em>{T+1}, ..., h_{T+h} and returns quantiles of exp(hₜ).</p><p><strong>Arguments</strong></p><ul><li><code>m</code>: Fitted SVModel</li><li><code>h</code>: Forecast horizon</li><li><code>conf_level</code>: Confidence level for intervals (default 0.95)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/sv/forecast.jl#L23-L35">source</a></section></details></article><h3 id="Volatility-Accessors"><a class="docs-heading-anchor" href="#Volatility-Accessors">Volatility Accessors</a><a id="Volatility-Accessors-1"></a><a class="docs-heading-anchor-permalink" href="#Volatility-Accessors" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.persistence"><a class="docstring-binding" href="#MacroEconometricModels.persistence"><code>MacroEconometricModels.persistence</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return persistence Σαᵢ for ARCH model.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L102">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.halflife"><a class="docstring-binding" href="#MacroEconometricModels.halflife"><code>MacroEconometricModels.halflife</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return half-life of volatility shocks: log(0.5) / log(persistence).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L105">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.unconditional_variance"><a class="docstring-binding" href="#MacroEconometricModels.unconditional_variance"><code>MacroEconometricModels.unconditional_variance</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return unconditional variance ω / (1 - Σαᵢ).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L113">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.arch_order"><a class="docstring-binding" href="#MacroEconometricModels.arch_order"><code>MacroEconometricModels.arch_order</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return ARCH order q.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L99">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.garch_order"><a class="docstring-binding" href="#MacroEconometricModels.garch_order"><code>MacroEconometricModels.garch_order</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Return GARCH order p.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L147">source</a></section></details></article><h3 id="Volatility-StatsAPI-Interface"><a class="docs-heading-anchor" href="#Volatility-StatsAPI-Interface">Volatility StatsAPI Interface</a><a id="Volatility-StatsAPI-Interface-1"></a><a class="docs-heading-anchor-permalink" href="#Volatility-StatsAPI-Interface" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{ARCHModel}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{ARCHModel}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.coef-Tuple{ARCHModel}"><a class="docstring-binding" href="#StatsAPI.coef-Tuple{ARCHModel}"><code>StatsAPI.coef</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Coefficient vector <code>[μ, ω, α₁, …, αq]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L127">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.residuals-Tuple{ARCHModel}"><a class="docstring-binding" href="#StatsAPI.residuals-Tuple{ARCHModel}"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Raw residuals <span>$\hat{\varepsilon}_t$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L130">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.aic-Tuple{ARCHModel}"><a class="docstring-binding" href="#StatsAPI.aic-Tuple{ARCHModel}"><code>StatsAPI.aic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Akaike Information Criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L139">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.bic-Tuple{ARCHModel}"><a class="docstring-binding" href="#StatsAPI.bic-Tuple{ARCHModel}"><code>StatsAPI.bic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Bayesian Information Criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L142">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.dof-Tuple{ARCHModel}"><a class="docstring-binding" href="#StatsAPI.dof-Tuple{ARCHModel}"><code>StatsAPI.dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of estimated parameters: <code>2 + q</code> (μ + ω + q alphas).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L145">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.islinear-Tuple{ARCHModel}"><a class="docstring-binding" href="#StatsAPI.islinear-Tuple{ARCHModel}"><code>StatsAPI.islinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>false</code> — ARCH models are nonlinear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/arch/types.jl#L148">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{GARCHModel}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{GARCHModel}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L186">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.coef-Tuple{GARCHModel}"><a class="docstring-binding" href="#StatsAPI.coef-Tuple{GARCHModel}"><code>StatsAPI.coef</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Coefficient vector <code>[μ, ω, α₁, …, αq, β₁, …, βp]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L193">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.residuals-Tuple{GARCHModel}"><a class="docstring-binding" href="#StatsAPI.residuals-Tuple{GARCHModel}"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Raw residuals <span>$\hat{\varepsilon}_t$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.aic-Tuple{GARCHModel}"><a class="docstring-binding" href="#StatsAPI.aic-Tuple{GARCHModel}"><code>StatsAPI.aic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Akaike Information Criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L221">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.bic-Tuple{GARCHModel}"><a class="docstring-binding" href="#StatsAPI.bic-Tuple{GARCHModel}"><code>StatsAPI.bic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Bayesian Information Criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L228">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.dof-Tuple{GARCHModel}"><a class="docstring-binding" href="#StatsAPI.dof-Tuple{GARCHModel}"><code>StatsAPI.dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of estimated parameters: <code>2 + q + p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L235">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.islinear-Tuple{GARCHModel}"><a class="docstring-binding" href="#StatsAPI.islinear-Tuple{GARCHModel}"><code>StatsAPI.islinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>false</code> — GARCH models are nonlinear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L242">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{EGARCHModel}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{EGARCHModel}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L188">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.coef-Tuple{EGARCHModel}"><a class="docstring-binding" href="#StatsAPI.coef-Tuple{EGARCHModel}"><code>StatsAPI.coef</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Coefficient vector <code>[μ, ω, α₁, …, αq, γ₁, …, γq, β₁, …, βp]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L195">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.residuals-Tuple{EGARCHModel}"><a class="docstring-binding" href="#StatsAPI.residuals-Tuple{EGARCHModel}"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Raw residuals <span>$\hat{\varepsilon}_t$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L202">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.aic-Tuple{EGARCHModel}"><a class="docstring-binding" href="#StatsAPI.aic-Tuple{EGARCHModel}"><code>StatsAPI.aic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Akaike Information Criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L223">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.bic-Tuple{EGARCHModel}"><a class="docstring-binding" href="#StatsAPI.bic-Tuple{EGARCHModel}"><code>StatsAPI.bic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Bayesian Information Criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L230">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.dof-Tuple{EGARCHModel}"><a class="docstring-binding" href="#StatsAPI.dof-Tuple{EGARCHModel}"><code>StatsAPI.dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of estimated parameters: <code>2 + 2q + p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L237">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.islinear-Tuple{EGARCHModel}"><a class="docstring-binding" href="#StatsAPI.islinear-Tuple{EGARCHModel}"><code>StatsAPI.islinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>false</code> — EGARCH models are nonlinear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L244">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{GJRGARCHModel}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{GJRGARCHModel}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L190">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.coef-Tuple{GJRGARCHModel}"><a class="docstring-binding" href="#StatsAPI.coef-Tuple{GJRGARCHModel}"><code>StatsAPI.coef</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Coefficient vector <code>[μ, ω, α₁, …, αq, γ₁, …, γq, β₁, …, βp]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L197">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.residuals-Tuple{GJRGARCHModel}"><a class="docstring-binding" href="#StatsAPI.residuals-Tuple{GJRGARCHModel}"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Raw residuals <span>$\hat{\varepsilon}_t$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.aic-Tuple{GJRGARCHModel}"><a class="docstring-binding" href="#StatsAPI.aic-Tuple{GJRGARCHModel}"><code>StatsAPI.aic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Akaike Information Criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L225">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.bic-Tuple{GJRGARCHModel}"><a class="docstring-binding" href="#StatsAPI.bic-Tuple{GJRGARCHModel}"><code>StatsAPI.bic</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Bayesian Information Criterion.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L232">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.dof-Tuple{GJRGARCHModel}"><a class="docstring-binding" href="#StatsAPI.dof-Tuple{GJRGARCHModel}"><code>StatsAPI.dof</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of estimated parameters: <code>2 + 2q + p</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L239">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.islinear-Tuple{GJRGARCHModel}"><a class="docstring-binding" href="#StatsAPI.islinear-Tuple{GJRGARCHModel}"><code>StatsAPI.islinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>false</code> — GJR-GARCH models are nonlinear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/garch/types.jl#L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.nobs-Tuple{SVModel}"><a class="docstring-binding" href="#StatsAPI.nobs-Tuple{SVModel}"><code>StatsAPI.nobs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Number of observations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/sv/types.jl#L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.coef-Tuple{SVModel}"><a class="docstring-binding" href="#StatsAPI.coef-Tuple{SVModel}"><code>StatsAPI.coef</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Posterior mean coefficients <code>[μ, φ, σ_η]</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/sv/types.jl#L79">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.residuals-Tuple{SVModel}"><a class="docstring-binding" href="#StatsAPI.residuals-Tuple{SVModel}"><code>StatsAPI.residuals</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Standardized residuals <span>$y_t / \sqrt{\hat{\sigma}^2_t}$</span>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/sv/types.jl#L82">source</a></section></details></article><article><details class="docstring" open="true"><summary id="StatsAPI.islinear-Tuple{SVModel}"><a class="docstring-binding" href="#StatsAPI.islinear-Tuple{SVModel}"><code>StatsAPI.islinear</code></a> — <span class="docstring-category">Method</span></summary><section><div><p><code>false</code> — SV models are nonlinear.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/sv/types.jl#L88">source</a></section></details></article><hr/><h2 id="Nowcasting"><a class="docs-heading-anchor" href="#Nowcasting">Nowcasting</a><a id="Nowcasting-1"></a><a class="docs-heading-anchor-permalink" href="#Nowcasting" title="Permalink"></a></h2><h3 id="Estimation-3"><a class="docs-heading-anchor" href="#Estimation-3">Estimation</a><a class="docs-heading-anchor-permalink" href="#Estimation-3" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.nowcast_dfm"><a class="docstring-binding" href="#MacroEconometricModels.nowcast_dfm"><code>MacroEconometricModels.nowcast_dfm</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nowcast_dfm(Y, nM, nQ; r=2, p=1, idio=:ar1, blocks=nothing,
            max_iter=100, thresh=1e-4) -&gt; NowcastDFM{T}</code></pre><p>Estimate a dynamic factor model on mixed-frequency data with missing values.</p><p>The first <code>nM</code> columns of <code>Y</code> are monthly variables; the next <code>nQ</code> columns are quarterly variables (observed every 3rd month, NaN otherwise).</p><p><strong>Arguments</strong></p><ul><li><code>Y::AbstractMatrix</code> — T_obs × N data matrix (NaN for missing)</li><li><code>nM::Int</code> — number of monthly variables</li><li><code>nQ::Int</code> — number of quarterly variables</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>r::Int=2</code> — number of factors</li><li><code>p::Int=1</code> — VAR lags in factor dynamics</li><li><code>idio::Symbol=:ar1</code> — idiosyncratic component (<code>:ar1</code> or <code>:iid</code>)</li><li><code>blocks::Union{Matrix{Int},Nothing}=nothing</code> — block structure (N × n_blocks)</li><li><code>max_iter::Int=100</code> — maximum EM iterations</li><li><code>thresh::Real=1e-4</code> — convergence threshold (relative log-likelihood change)</li></ul><p><strong>Returns</strong></p><p><code>NowcastDFM{T}</code> with smoothed data, factors, and state-space parameters.</p><p><strong>References</strong></p><ul><li>Bańbura, M. &amp; Modugno, M. (2014). Maximum Likelihood Estimation of Factor Models on Datasets with Arbitrary Pattern of Missing Data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nowcast/dfm.jl#L30-L58">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.nowcast_bvar"><a class="docstring-binding" href="#MacroEconometricModels.nowcast_bvar"><code>MacroEconometricModels.nowcast_bvar</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nowcast_bvar(Y, nM, nQ; lags=5, thresh=1e-6, max_iter=200,
            lambda0=0.2, theta0=1.0, miu0=1.0, alpha0=2.0) -&gt; NowcastBVAR{T}</code></pre><p>Estimate a large BVAR for mixed-frequency nowcasting.</p><p>The first <code>nM</code> columns are monthly variables; the next <code>nQ</code> columns are quarterly (observed every 3rd month). The BVAR is estimated on the complete (non-NaN) portion, then the Kalman smoother fills the ragged edge.</p><p><strong>Arguments</strong></p><ul><li><code>Y::AbstractMatrix</code> — T_obs × N data matrix (NaN for missing)</li><li><code>nM::Int</code> — number of monthly variables</li><li><code>nQ::Int</code> — number of quarterly variables</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>lags::Int=5</code> — number of lags</li><li><code>thresh::Real=1e-6</code> — optimization convergence threshold</li><li><code>max_iter::Int=200</code> — max optimization iterations</li><li><code>lambda0::Real=0.2</code> — initial overall shrinkage</li><li><code>theta0::Real=1.0</code> — initial cross-variable shrinkage</li><li><code>miu0::Real=1.0</code> — initial sum-of-coefficients weight</li><li><code>alpha0::Real=2.0</code> — initial co-persistence weight</li></ul><p><strong>Returns</strong></p><p><code>NowcastBVAR{T}</code> with smoothed data and posterior parameters.</p><p><strong>References</strong></p><ul><li>Cimadomo, J., Giannone, D., Lenza, M., Monti, F. &amp; Sokol, A. (2022). Nowcasting with Large Bayesian Vector Autoregressions.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nowcast/bvar_nowcast.jl#L31-L61">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.nowcast_bridge"><a class="docstring-binding" href="#MacroEconometricModels.nowcast_bridge"><code>MacroEconometricModels.nowcast_bridge</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nowcast_bridge(Y, nM, nQ; lagM=1, lagQ=1, lagY=1) -&gt; NowcastBridge{T}</code></pre><p>Estimate bridge equation combination nowcast.</p><p>Each bridge equation uses a pair of monthly indicators (aggregated to quarterly) plus optional lagged quarterly variables and autoregressive terms to predict the target quarterly variable (last column).</p><p><strong>Arguments</strong></p><ul><li><code>Y::AbstractMatrix</code> — T_obs × N data matrix (NaN for missing)</li><li><code>nM::Int</code> — number of monthly variables</li><li><code>nQ::Int</code> — number of quarterly variables (last <code>nQ</code> columns)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>lagM::Int=1</code> — lags for monthly indicators (after quarterly aggregation)</li><li><code>lagQ::Int=1</code> — lags for quarterly indicators</li><li><code>lagY::Int=1</code> — autoregressive lags for target variable</li></ul><p><strong>Returns</strong></p><p><code>NowcastBridge{T}</code> with combined and individual nowcasts.</p><p><strong>References</strong></p><ul><li>Bańbura, M., Belousova, I., Bodnár, K. &amp; Tóth, M. B. (2023). Nowcasting Employment in the Euro Area. ECB Working Paper No 2815.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nowcast/bridge.jl#L30-L55">source</a></section></details></article><h3 id="Nowcast-and-Forecast"><a class="docs-heading-anchor" href="#Nowcast-and-Forecast">Nowcast and Forecast</a><a id="Nowcast-and-Forecast-1"></a><a class="docs-heading-anchor-permalink" href="#Nowcast-and-Forecast" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.nowcast"><a class="docstring-binding" href="#MacroEconometricModels.nowcast"><code>MacroEconometricModels.nowcast</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nowcast(model::AbstractNowcastModel; target_var=nothing) -&gt; NowcastResult{T}</code></pre><p>Generate nowcast result from an estimated nowcasting model.</p><p>Returns the current-quarter nowcast and next-quarter forecast for the target variable (default: last quarterly variable).</p><p><strong>Arguments</strong></p><ul><li><code>model::AbstractNowcastModel</code> — estimated nowcast model</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>target_var::Union{Int,Nothing}=nothing</code> — target variable index (default: last column)</li></ul><p><strong>Returns</strong></p><p><code>NowcastResult{T}</code> with nowcast and forecast values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nowcast/forecast.jl#L27-L43">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{NowcastDFM{T}, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.forecast-Union{Tuple{T}, Tuple{NowcastDFM{T}, Int64}} where T"><code>MacroEconometricModels.forecast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">forecast(model::NowcastDFM, h; target_var=nothing) -&gt; Vector{T}</code></pre><p>Generate h-step ahead monthly forecast from DFM nowcasting model.</p><p><strong>Arguments</strong></p><ul><li><code>model::NowcastDFM</code> — estimated model</li><li><code>h::Int</code> — forecast horizon (months)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>target_var::Union{Int,Nothing}</code> — variable to forecast (default: all)</li></ul><p><strong>Returns</strong></p><p>Vector of h forecast values (if target_var specified) or Matrix h × N.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nowcast/forecast.jl#L110-L124">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.nowcast-Union{Tuple{NowcastDFM{T}}, Tuple{T}} where T"><a class="docstring-binding" href="#MacroEconometricModels.nowcast-Union{Tuple{NowcastDFM{T}}, Tuple{T}} where T"><code>MacroEconometricModels.nowcast</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">nowcast(model::AbstractNowcastModel; target_var=nothing) -&gt; NowcastResult{T}</code></pre><p>Generate nowcast result from an estimated nowcasting model.</p><p>Returns the current-quarter nowcast and next-quarter forecast for the target variable (default: last quarterly variable).</p><p><strong>Arguments</strong></p><ul><li><code>model::AbstractNowcastModel</code> — estimated nowcast model</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>target_var::Union{Int,Nothing}=nothing</code> — target variable index (default: last column)</li></ul><p><strong>Returns</strong></p><p><code>NowcastResult{T}</code> with nowcast and forecast values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nowcast/forecast.jl#L27-L43">source</a></section></details></article><h3 id="News-Decomposition"><a class="docs-heading-anchor" href="#News-Decomposition">News Decomposition</a><a id="News-Decomposition-1"></a><a class="docs-heading-anchor-permalink" href="#News-Decomposition" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.nowcast_news"><a class="docstring-binding" href="#MacroEconometricModels.nowcast_news"><code>MacroEconometricModels.nowcast_news</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">nowcast_news(X_new, X_old, model::NowcastDFM, target_period;
             target_var=size(X_new,2), groups=nothing) -&gt; NowcastNews{T}</code></pre><p>Compute news decomposition between two data vintages.</p><p>Identifies new data releases (positions where <code>X_old</code> is NaN but <code>X_new</code> is not), computes their individual impacts on the nowcast via Kalman gain weights, and decomposes the total revision.</p><p><strong>Arguments</strong></p><ul><li><code>X_new::AbstractMatrix</code> — new data vintage (T_obs × N)</li><li><code>X_old::AbstractMatrix</code> — old data vintage (same size, more NaN)</li><li><code>model::NowcastDFM</code> — estimated DFM model</li><li><code>target_period::Int</code> — time period for which to compute nowcast</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>target_var::Int</code> — target variable index (default: last column)</li><li><code>groups::Union{Vector{Int},Nothing}</code> — group assignment per variable (for aggregation)</li></ul><p><strong>Returns</strong></p><p><code>NowcastNews{T}</code> with per-release impacts and total decomposition.</p><p><strong>References</strong></p><ul><li>Bańbura, M. &amp; Modugno, M. (2014). Maximum Likelihood Estimation of Factor Models on Datasets with Arbitrary Pattern of Missing Data.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nowcast/news.jl#L30-L56">source</a></section></details></article><h3 id="Panel-Balancing"><a class="docs-heading-anchor" href="#Panel-Balancing">Panel Balancing</a><a id="Panel-Balancing-1"></a><a class="docs-heading-anchor-permalink" href="#Panel-Balancing" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.balance_panel"><a class="docstring-binding" href="#MacroEconometricModels.balance_panel"><code>MacroEconometricModels.balance_panel</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">balance_panel(pd::PanelData; method=:dfm, r=3, p=2) -&gt; PanelData</code></pre><p>Balance a panel dataset by filling missing values (NaN) using DFM-based nowcasting to estimate missing observations.</p><p>For each group with missing data, runs <code>nowcast_dfm</code> treating all variables as monthly (nM = n_vars, nQ = 0) to obtain Kalman-smoothed estimates.</p><p><strong>Arguments</strong></p><ul><li><code>pd::PanelData</code> — input panel data (may be unbalanced or have NaN)</li></ul><p><strong>Keyword Arguments</strong></p><ul><li><code>method::Symbol=:dfm</code> — fill method (currently only <code>:dfm</code>)</li><li><code>r::Int=3</code> — number of factors for DFM</li><li><code>p::Int=2</code> — VAR lags in DFM factor dynamics</li></ul><p><strong>Returns</strong></p><p>New <code>PanelData</code> with NaN filled and <code>balanced=true</code> if applicable.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">pd = xtset(df, :id, :t)
pd_bal = balance_panel(pd; r=2, p=1)
isbalanced(pd_bal)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/panel.jl#L228-L254">source</a></section><section><div><pre><code class="language-julia hljs">balance_panel(ts::TimeSeriesData; method=:dfm, r=3, p=2) -&gt; TimeSeriesData</code></pre><p>Fill missing values (NaN) in a TimeSeriesData container using DFM nowcasting.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">ts = TimeSeriesData(randn(100, 3))
ts.data[95:100, 2] .= NaN
ts_bal = balance_panel(ts; r=2)</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/data/panel.jl#L291-L302">source</a></section></details></article><hr/><h2 id="Display-and-References"><a class="docs-heading-anchor" href="#Display-and-References">Display and References</a><a id="Display-and-References-1"></a><a class="docs-heading-anchor-permalink" href="#Display-and-References" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels._coef_table-Union{Tuple{T}, Tuple{IO, String, Vector{String}, Vector{T}, Vector{T}}} where T"><a class="docstring-binding" href="#MacroEconometricModels._coef_table-Union{Tuple{T}, Tuple{IO, String, Vector{String}, Vector{T}, Vector{T}}} where T"><code>MacroEconometricModels._coef_table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_coef_table(io, title, names, coefs, se; dist=:z, dof_r=0, level=0.95)</code></pre><p>Publication-quality 7-column coefficient table (Stata/EViews style).</p><p>Columns: Name | Coef. | Std.Err. | z/t | P&gt;|z/t| | [95% CI lower | CI upper] | stars</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/display.jl#L112-L118">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._matrix_table-Tuple{IO, AbstractMatrix, String}"><a class="docstring-binding" href="#MacroEconometricModels._matrix_table-Tuple{IO, AbstractMatrix, String}"><code>MacroEconometricModels._matrix_table</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Print a labeled matrix as a PrettyTables table.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/display.jl#L167">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._pretty_table-Tuple{IO, Any}"><a class="docstring-binding" href="#MacroEconometricModels._pretty_table-Tuple{IO, Any}"><code>MacroEconometricModels._pretty_table</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">_pretty_table(io::IO, data; kwargs...)</code></pre><p>Central PrettyTables wrapper that respects the global display backend.</p><p>For <code>:text</code> backend, applies <code>_TEXT_TABLE_FORMAT</code> automatically. For <code>:latex</code> and <code>:html</code> backends, omits text-only formatting options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/display.jl#L65-L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._select_horizons-Tuple{Int64}"><a class="docstring-binding" href="#MacroEconometricModels._select_horizons-Tuple{Int64}"><code>MacroEconometricModels._select_horizons</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Select representative horizons for display.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/display.jl#L104">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._sig_legend-Tuple{IO}"><a class="docstring-binding" href="#MacroEconometricModels._sig_legend-Tuple{IO}"><code>MacroEconometricModels._sig_legend</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Print significance legend footer.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/display.jl#L161">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.get_display_backend-Tuple{}"><a class="docstring-binding" href="#MacroEconometricModels.get_display_backend-Tuple{}"><code>MacroEconometricModels.get_display_backend</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">get_display_backend() -&gt; Symbol</code></pre><p>Return the current PrettyTables display backend (<code>:text</code>, <code>:latex</code>, or <code>:html</code>).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/display.jl#L52-L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.set_display_backend-Tuple{Symbol}"><a class="docstring-binding" href="#MacroEconometricModels.set_display_backend-Tuple{Symbol}"><code>MacroEconometricModels.set_display_backend</code></a> — <span class="docstring-category">Method</span></summary><section><div><pre><code class="language-julia hljs">set_display_backend(backend::Symbol)</code></pre><p>Set the PrettyTables output backend. Options: <code>:text</code> (default), <code>:latex</code>, <code>:html</code>.</p><p><strong>Examples</strong></p><pre><code class="language-julia hljs">set_display_backend(:latex)   # all show() methods now emit LaTeX
set_display_backend(:html)    # switch to HTML tables
set_display_backend(:text)    # back to terminal-friendly text</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/display.jl#L35-L46">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.refs"><a class="docstring-binding" href="#MacroEconometricModels.refs"><code>MacroEconometricModels.refs</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">refs([io::IO], x; format=get_display_backend())</code></pre><p>Print bibliographic references for a model, result, or method.</p><p>Supports four output formats via the <code>format</code> keyword:</p><ul><li><code>:text</code> — AEA plain text (default, follows <code>get_display_backend()</code>)</li><li><code>:latex</code> — <code>\bibitem{}</code> entries</li><li><code>:bibtex</code> — BibTeX <code>@article{}</code>/<code>@book{}</code> entries</li><li><code>:html</code> — HTML with clickable DOI links</li></ul><p><strong>Dispatch</strong></p><ul><li><strong>Instance dispatch</strong>: <code>refs(model)</code> prints references for the model type</li><li><strong>Symbol dispatch</strong>: <code>refs(:fastica)</code> prints references for a method name</li></ul><p><strong>Examples</strong></p><pre><code class="language-julia hljs">model = estimate_var(Y, 2)
refs(model)                        # AEA text to stdout
refs(model; format=:bibtex)        # BibTeX entries

refs(:johansen)                    # Johansen (1991)
refs(:fastica; format=:latex)      # Hyvärinen (1999) as \bibitem</code></pre></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/summary_refs.jl#L784-L808">source</a></section></details></article><hr/><h2 id="Non-Gaussian-Identification"><a class="docs-heading-anchor" href="#Non-Gaussian-Identification">Non-Gaussian Identification</a><a id="Non-Gaussian-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Gaussian-Identification" title="Permalink"></a></h2><h3 id="Normality-Tests"><a class="docs-heading-anchor" href="#Normality-Tests">Normality Tests</a><a id="Normality-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Normality-Tests" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.jarque_bera_test"><a class="docstring-binding" href="#MacroEconometricModels.jarque_bera_test"><code>MacroEconometricModels.jarque_bera_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">jarque_bera_test(model::VARModel; method=:multivariate) -&gt; NormalityTestResult
jarque_bera_test(U::AbstractMatrix; method=:multivariate)  -&gt; NormalityTestResult</code></pre><p>Multivariate Jarque-Bera test for normality of VAR residuals.</p><p>Methods:</p><ul><li><code>:multivariate</code> — joint test based on multivariate skewness and kurtosis (Lütkepohl 2005)</li><li><code>:component</code> — component-wise univariate JB tests on standardized residuals</li></ul><p><strong>Reference</strong>: Jarque &amp; Bera (1980), Lütkepohl (2005, §4.5)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/normality.jl#L189-L200">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.mardia_test"><a class="docstring-binding" href="#MacroEconometricModels.mardia_test"><code>MacroEconometricModels.mardia_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">mardia_test(model::VARModel; type=:both) -&gt; NormalityTestResult
mardia_test(U::AbstractMatrix; type=:both) -&gt; NormalityTestResult</code></pre><p>Mardia&#39;s tests for multivariate normality based on multivariate skewness and kurtosis.</p><p>Types:</p><ul><li><code>:skewness</code> — tests multivariate skewness b₁,ₖ</li><li><code>:kurtosis</code> — tests multivariate kurtosis b₂,ₖ</li><li><code>:both</code> — combined test (sum of both statistics)</li></ul><p>Under H₀: T·b₁,ₖ/6 ~ χ²(k(k+1)(k+2)/6), (b₂,ₖ - k(k+2)) / √(8k(k+2)/T) ~ N(0,1).</p><p><strong>Reference</strong>: Mardia (1970)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/normality.jl#L246-L260">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.doornik_hansen_test"><a class="docstring-binding" href="#MacroEconometricModels.doornik_hansen_test"><code>MacroEconometricModels.doornik_hansen_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">doornik_hansen_test(model::VARModel) -&gt; NormalityTestResult
doornik_hansen_test(U::AbstractMatrix)  -&gt; NormalityTestResult</code></pre><p>Doornik-Hansen omnibus test for multivariate normality.</p><p>Applies the Bowman-Shenton transformation to each component&#39;s skewness and kurtosis, then sums z₁² + z₂² across components. Under H₀: DH ~ χ²(2k).</p><p><strong>Reference</strong>: Doornik &amp; Hansen (2008)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/normality.jl#L301-L311">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.henze_zirkler_test"><a class="docstring-binding" href="#MacroEconometricModels.henze_zirkler_test"><code>MacroEconometricModels.henze_zirkler_test</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">henze_zirkler_test(model::VARModel) -&gt; NormalityTestResult
henze_zirkler_test(U::AbstractMatrix)  -&gt; NormalityTestResult</code></pre><p>Henze-Zirkler test for multivariate normality based on the empirical characteristic function.</p><p>The test statistic is:</p><p class="math-container">\[T_{\beta} = \frac{1}{n} \sum_{i,j} e^{-\beta^2 D_{ij}/2} - 2(1+\beta^2)^{-k/2} \sum_i e^{-\beta^2 d_i^2/(2(1+\beta^2))} + n(1+2\beta^2)^{-k/2}\]</p><p>where <span>$D_{ij} = (z_i - z_j)&#39;(z_i - z_j)$</span> and <span>$d_i = z_i&#39; z_i$</span>.</p><p><strong>Reference</strong>: Henze &amp; Zirkler (1990)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/normality.jl#L347-L360">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.normality_test_suite"><a class="docstring-binding" href="#MacroEconometricModels.normality_test_suite"><code>MacroEconometricModels.normality_test_suite</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">normality_test_suite(model::VARModel) -&gt; NormalityTestSuite
normality_test_suite(U::AbstractMatrix)  -&gt; NormalityTestSuite</code></pre><p>Run all available multivariate normality tests and return a <code>NormalityTestSuite</code>.</p><p>Tests included:</p><ol><li>Multivariate Jarque-Bera</li><li>Component-wise Jarque-Bera</li><li>Mardia skewness</li><li>Mardia kurtosis</li><li>Mardia combined</li><li>Doornik-Hansen</li><li>Henze-Zirkler</li></ol></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/teststat/normality.jl#L423-L437">source</a></section></details></article><h3 id="ICA-based-Identification"><a class="docs-heading-anchor" href="#ICA-based-Identification">ICA-based Identification</a><a id="ICA-based-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#ICA-based-Identification" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_fastica"><a class="docstring-binding" href="#MacroEconometricModels.identify_fastica"><code>MacroEconometricModels.identify_fastica</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_fastica(model::VARModel; contrast=:logcosh, approach=:deflation,
                 max_iter=200, tol=1e-6) -&gt; ICASVARResult</code></pre><p>Identify SVAR via FastICA (Hyvärinen 1999).</p><p>Recovers independent non-Gaussian structural shocks by maximizing non-Gaussianity of the recovered sources.</p><p>Arguments:</p><ul><li><code>contrast</code> — non-Gaussianity measure: <code>:logcosh</code> (default, robust), <code>:exp</code>, <code>:kurtosis</code></li><li><code>approach</code> — <code>:deflation</code> (one-by-one) or <code>:symmetric</code> (simultaneous)</li><li><code>max_iter</code> — maximum iterations per component</li><li><code>tol</code> — convergence tolerance</li></ul><p><strong>Reference</strong>: Hyvärinen (1999)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/ica.jl#L203-L219">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_jade"><a class="docstring-binding" href="#MacroEconometricModels.identify_jade"><code>MacroEconometricModels.identify_jade</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_jade(model::VARModel; max_iter=100, tol=1e-6) -&gt; ICASVARResult</code></pre><p>Identify SVAR via JADE (Joint Approximate Diagonalization of Eigenmatrices).</p><p>Uses fourth-order cumulant matrices and joint diagonalization via Jacobi rotations.</p><p><strong>Reference</strong>: Cardoso &amp; Souloumiac (1993)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/ica.jl#L331-L339">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_sobi"><a class="docstring-binding" href="#MacroEconometricModels.identify_sobi"><code>MacroEconometricModels.identify_sobi</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_sobi(model::VARModel; lags=1:12, max_iter=100, tol=1e-6) -&gt; ICASVARResult</code></pre><p>Identify SVAR via SOBI (Second-Order Blind Identification).</p><p>Uses autocovariance matrices at multiple lags and joint diagonalization. Exploits temporal structure rather than higher-order statistics.</p><p><strong>Reference</strong>: Belouchrani et al. (1997)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/ica.jl#L380-L389">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_dcov"><a class="docstring-binding" href="#MacroEconometricModels.identify_dcov"><code>MacroEconometricModels.identify_dcov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_dcov(model::VARModel; max_iter=200, tol=1e-6) -&gt; ICASVARResult</code></pre><p>Identify SVAR by minimizing pairwise distance covariance between recovered shocks.</p><p>Distance covariance (Székely et al. 2007) is zero iff the variables are independent, making it a natural criterion for ICA.</p><p><strong>Reference</strong>: Matteson &amp; Tsay (2017)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/ica.jl#L455-L464">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_hsic"><a class="docstring-binding" href="#MacroEconometricModels.identify_hsic"><code>MacroEconometricModels.identify_hsic</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_hsic(model::VARModel; kernel=:gaussian, sigma=1.0,
              max_iter=200, tol=1e-6) -&gt; ICASVARResult</code></pre><p>Identify SVAR by minimizing pairwise HSIC between recovered shocks.</p><p>HSIC with a characteristic kernel (Gaussian) is zero iff variables are independent.</p><p><strong>Reference</strong>: Gretton et al. (2005)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/ica.jl#L520-L529">source</a></section></details></article><h3 id="Non-Gaussian-ML-Identification"><a class="docs-heading-anchor" href="#Non-Gaussian-ML-Identification">Non-Gaussian ML Identification</a><a id="Non-Gaussian-ML-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Non-Gaussian-ML-Identification" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_student_t"><a class="docstring-binding" href="#MacroEconometricModels.identify_student_t"><code>MacroEconometricModels.identify_student_t</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_student_t(model::VARModel; max_iter=500, tol=1e-6) -&gt; NonGaussianMLResult</code></pre><p>Identify SVAR assuming Student-t distributed structural shocks.</p><p>Each shock εⱼ ~ t(νⱼ) (standardized to unit variance). Identification is achieved when at most one νⱼ = ∞ (Gaussian).</p><p><strong>Reference</strong>: Lanne, Meitz &amp; Saikkonen (2017)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/ml.jl#L421-L430">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_mixture_normal"><a class="docstring-binding" href="#MacroEconometricModels.identify_mixture_normal"><code>MacroEconometricModels.identify_mixture_normal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_mixture_normal(model::VARModel; n_components=2, max_iter=500, tol=1e-6) -&gt; NonGaussianMLResult</code></pre><p>Identify SVAR assuming mixture-of-normals distributed structural shocks.</p><p>Each shock εⱼ ~ p<em>j N(0,σ₁ⱼ²) + (1-p</em>j) N(0,σ₂ⱼ²) with unit variance constraint.</p><p><strong>Reference</strong>: Lanne &amp; Lütkepohl (2010)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/ml.jl#L436-L444">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_pml"><a class="docstring-binding" href="#MacroEconometricModels.identify_pml"><code>MacroEconometricModels.identify_pml</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_pml(model::VARModel; max_iter=500, tol=1e-6) -&gt; NonGaussianMLResult</code></pre><p>Identify SVAR via Pseudo Maximum Likelihood using Pearson Type IV distributions.</p><p>Allows both skewness and excess kurtosis in the structural shocks.</p><p><strong>Reference</strong>: Herwartz (2018)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/ml.jl#L450-L458">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_skew_normal"><a class="docstring-binding" href="#MacroEconometricModels.identify_skew_normal"><code>MacroEconometricModels.identify_skew_normal</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_skew_normal(model::VARModel; max_iter=500, tol=1e-6) -&gt; NonGaussianMLResult</code></pre><p>Identify SVAR assuming skew-normal distributed structural shocks.</p><p>Each shock εⱼ has pdf f(x) = 2 φ(x) Φ(αⱼ x), where αⱼ controls skewness.</p><p><strong>Reference</strong>: Azzalini (1985)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/ml.jl#L464-L472">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_nongaussian_ml"><a class="docstring-binding" href="#MacroEconometricModels.identify_nongaussian_ml"><code>MacroEconometricModels.identify_nongaussian_ml</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_nongaussian_ml(model::VARModel; distribution=:student_t,
                        max_iter=500, tol=1e-6) -&gt; NonGaussianMLResult</code></pre><p>Unified non-Gaussian ML SVAR identification dispatcher.</p><p>Supported distributions:</p><ul><li><code>:student_t</code> — independent Student-t shocks (Lanne, Meitz &amp; Saikkonen 2017)</li><li><code>:mixture_normal</code> — mixture of two normals (Lanne &amp; Lütkepohl 2010)</li><li><code>:pml</code> — Pearson Type IV / Pseudo-ML (Herwartz 2018)</li><li><code>:skew_normal</code> — skew-normal (Azzalini 1985)</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/ml.jl#L478-L489">source</a></section></details></article><h3 id="Heteroskedasticity-Identification"><a class="docs-heading-anchor" href="#Heteroskedasticity-Identification">Heteroskedasticity Identification</a><a id="Heteroskedasticity-Identification-1"></a><a class="docs-heading-anchor-permalink" href="#Heteroskedasticity-Identification" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_markov_switching"><a class="docstring-binding" href="#MacroEconometricModels.identify_markov_switching"><code>MacroEconometricModels.identify_markov_switching</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_markov_switching(model::VARModel; n_regimes=2, max_iter=500, tol=1e-6) -&gt; MarkovSwitchingSVARResult</code></pre><p>Identify SVAR via Markov-switching heteroskedasticity (Lanne &amp; Lütkepohl 2008).</p><p>Estimates regime-specific covariance matrices Σ₁, Σ₂, ..., Σ_K via EM algorithm, then identifies B₀ from the eigendecomposition of Σ₁⁻¹ Σ₂.</p><p>Identification requires that the relative variance ratios (eigenvalues) are distinct.</p><p><strong>Reference</strong>: Lanne &amp; Lütkepohl (2008), Rigobon (2003)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/heteroskedastic.jl#L375-L386">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_garch"><a class="docstring-binding" href="#MacroEconometricModels.identify_garch"><code>MacroEconometricModels.identify_garch</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_garch(model::VARModel; max_iter=500, tol=1e-6) -&gt; GARCHSVARResult</code></pre><p>Identify SVAR via GARCH-based heteroskedasticity (Normandin &amp; Phaneuf 2004).</p><p>Iterative procedure:</p><ol><li>Start with Cholesky B₀</li><li>Compute structural shocks ε<em>t = B₀⁻¹ u</em>t</li><li>Fit GARCH(1,1) to each ε_j,t</li><li>Use conditional covariances to re-estimate B₀</li><li>Repeat until convergence</li></ol><p><strong>Reference</strong>: Normandin &amp; Phaneuf (2004)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/heteroskedastic.jl#L511-L524">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_smooth_transition"><a class="docstring-binding" href="#MacroEconometricModels.identify_smooth_transition"><code>MacroEconometricModels.identify_smooth_transition</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_smooth_transition(model::VARModel, transition_var::AbstractVector;
                           max_iter=500, tol=1e-6) -&gt; SmoothTransitionSVARResult</code></pre><p>Identify SVAR via smooth-transition heteroskedasticity (Lütkepohl &amp; Netšunajev 2017).</p><p>The covariance matrix varies smoothly between two regimes:</p><p class="math-container">\[\Sigma_t = B_0 [I + G(s_t)(\Lambda - I)] B_0&#39;\]</p><p>where G(s<em>t) = 1/(1 + exp(-γ(s</em>t - c))) is the logistic transition function.</p><p>Arguments:</p><ul><li><code>transition_var</code> — the transition variable s_t (e.g., a lagged endogenous variable)</li></ul><p><strong>Reference</strong>: Lütkepohl &amp; Netšunajev (2017)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/heteroskedastic.jl#L620-L636">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.identify_external_volatility"><a class="docstring-binding" href="#MacroEconometricModels.identify_external_volatility"><code>MacroEconometricModels.identify_external_volatility</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">identify_external_volatility(model::VARModel, regime_indicator::AbstractVector{Int};
                             regimes=2) -&gt; ExternalVolatilitySVARResult</code></pre><p>Identify SVAR via externally specified volatility regimes (Rigobon 2003).</p><p>Uses a known regime indicator (e.g., NBER recessions, financial crises) to split the sample and estimate regime-specific covariance matrices.</p><p>Arguments:</p><ul><li><code>regime_indicator</code> — integer vector of regime labels (1, 2, ..., K)</li><li><code>regimes</code> — number of distinct regimes (default: 2)</li></ul><p><strong>Reference</strong>: Rigobon (2003)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/heteroskedastic.jl#L702-L716">source</a></section></details></article><h3 id="Identifiability-Tests"><a class="docs-heading-anchor" href="#Identifiability-Tests">Identifiability Tests</a><a id="Identifiability-Tests-1"></a><a class="docs-heading-anchor-permalink" href="#Identifiability-Tests" title="Permalink"></a></h3><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_identification_strength"><a class="docstring-binding" href="#MacroEconometricModels.test_identification_strength"><code>MacroEconometricModels.test_identification_strength</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_identification_strength(model::VARModel; method=:fastica,
                             n_bootstrap=999) -&gt; IdentifiabilityTestResult</code></pre><p>Test the strength of non-Gaussian identification via bootstrap.</p><p>Resamples residuals with replacement, re-estimates B₀, and computes the Procrustes distance between bootstrap and original B₀. Small distances indicate strong identification.</p><p>Returns: test statistic = median Procrustes distance, p-value from distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/tests.jl#L194-L204">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_shock_gaussianity"><a class="docstring-binding" href="#MacroEconometricModels.test_shock_gaussianity"><code>MacroEconometricModels.test_shock_gaussianity</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_shock_gaussianity(result::ICASVARResult) -&gt; IdentifiabilityTestResult
test_shock_gaussianity(result::NonGaussianMLResult) -&gt; IdentifiabilityTestResult</code></pre><p>Test whether recovered structural shocks are non-Gaussian using univariate JB tests.</p><p>Non-Gaussian identification requires at most one shock to be Gaussian. This test checks each shock individually and reports the joint result.</p><p>At most one Gaussian shock → identification holds.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/tests.jl#L274-L284">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_gaussian_vs_nongaussian"><a class="docstring-binding" href="#MacroEconometricModels.test_gaussian_vs_nongaussian"><code>MacroEconometricModels.test_gaussian_vs_nongaussian</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_gaussian_vs_nongaussian(model::VARModel; distribution=:student_t) -&gt; IdentifiabilityTestResult</code></pre><p>Likelihood ratio test: H₀ Gaussian vs H₁ non-Gaussian structural shocks.</p><p>Under H₀, the LR statistic LR = 2(ℓ₁ - ℓ₀) ~ χ²(n<em>extra</em>params).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/tests.jl#L328-L334">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_shock_independence"><a class="docstring-binding" href="#MacroEconometricModels.test_shock_independence"><code>MacroEconometricModels.test_shock_independence</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_shock_independence(result::ICASVARResult; max_lag=10) -&gt; IdentifiabilityTestResult
test_shock_independence(result::NonGaussianMLResult; max_lag=10) -&gt; IdentifiabilityTestResult</code></pre><p>Test independence of recovered structural shocks.</p><p>Uses both cross-correlation (portmanteau) and distance covariance tests. Independence is a necessary condition for valid identification.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/tests.jl#L358-L366">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.test_overidentification"><a class="docstring-binding" href="#MacroEconometricModels.test_overidentification"><code>MacroEconometricModels.test_overidentification</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">test_overidentification(model::VARModel, result::AbstractNonGaussianSVAR;
                        restrictions=nothing, n_bootstrap=499) -&gt; IdentifiabilityTestResult</code></pre><p>Test overidentifying restrictions for non-Gaussian SVAR.</p><p>When additional restrictions beyond non-Gaussianity are imposed (e.g., zero restrictions on B₀), this test checks whether those restrictions are consistent with the data.</p><p>Uses a bootstrap approach: compares the restricted log-likelihood to bootstrap distribution.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/nongaussian/tests.jl#L409-L419">source</a></section></details></article><hr/><h2 id="Covariance-Estimators"><a class="docs-heading-anchor" href="#Covariance-Estimators">Covariance Estimators</a><a id="Covariance-Estimators-1"></a><a class="docs-heading-anchor-permalink" href="#Covariance-Estimators" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels.newey_west"><a class="docstring-binding" href="#MacroEconometricModels.newey_west"><code>MacroEconometricModels.newey_west</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">newey_west(X::AbstractMatrix{T}, residuals::AbstractVector{T};
           bandwidth::Int=0, kernel::Symbol=:bartlett, prewhiten::Bool=false,
           XtX_inv::Union{Nothing,AbstractMatrix{T}}=nothing) -&gt; Matrix{T}</code></pre><p>Compute Newey-West HAC covariance matrix.</p><p>V_NW = (X&#39;X)^{-1} S (X&#39;X)^{-1} where S = Γ₀ + Σⱼ₌₁ᵐ w(j) (Γⱼ + Γⱼ&#39;)</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Design matrix (n × k)</li><li><code>residuals</code>: Residuals vector (n × 1)</li><li><code>bandwidth</code>: Truncation lag (0 = automatic selection)</li><li><code>kernel</code>: Kernel function</li><li><code>prewhiten</code>: Use AR(1) prewhitening</li><li><code>XtX_inv</code>: Pre-computed (X&#39;X)^{-1} for performance (optional)</li></ul><p><strong>Returns</strong></p><p>Robust covariance matrix (k × k)</p><p><strong>Performance</strong></p><p>Pass <code>XtX_inv</code> when calling multiple times with the same X to avoid recomputation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L180-L203">source</a></section><section><div><pre><code class="language-julia hljs">newey_west(X::AbstractMatrix{T}, residuals::AbstractMatrix{T}; ...) -&gt; Matrix{T}</code></pre><p>Multivariate version for systems of equations.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L258-L262">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.white_vcov"><a class="docstring-binding" href="#MacroEconometricModels.white_vcov"><code>MacroEconometricModels.white_vcov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">white_vcov(X::AbstractMatrix{T}, residuals::AbstractVector{T}; variant::Symbol=:hc0,
           XtX_inv::Union{Nothing,AbstractMatrix{T}}=nothing) -&gt; Matrix{T}</code></pre><p>White heteroscedasticity-robust covariance estimator.</p><p>Variants: :hc0, :hc1, :hc2, :hc3</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Design matrix (n × k)</li><li><code>residuals</code>: Residuals vector (n × 1)</li><li><code>variant</code>: HC variant (:hc0 = standard, :hc1 = small sample, :hc2/:hc3 = leverage-adjusted)</li><li><code>XtX_inv</code>: Pre-computed (X&#39;X)^{-1} for performance (optional)</li></ul><p><strong>Returns</strong></p><p>Robust covariance matrix (k × k)</p><p><strong>Performance</strong></p><p>Pass <code>XtX_inv</code> when calling multiple times with the same X to avoid recomputation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L282-L301">source</a></section><section><div><pre><code class="language-julia hljs">white_vcov(X::AbstractMatrix{T}, residuals::AbstractMatrix{T}; ...) -&gt; Matrix{T}</code></pre><p>Multivariate version.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L348-L352">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.driscoll_kraay"><a class="docstring-binding" href="#MacroEconometricModels.driscoll_kraay"><code>MacroEconometricModels.driscoll_kraay</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">driscoll_kraay(X::AbstractMatrix{T}, u::AbstractVector{T};
               bandwidth::Int=0, kernel::Symbol=:bartlett,
               XtX_inv::Union{Nothing,AbstractMatrix{T}}=nothing) -&gt; Matrix{T}</code></pre><p>Driscoll-Kraay standard errors for time series regression.</p><p>In a pure time series context, this is equivalent to Newey-West HAC estimation applied to the moment conditions X&#39;u. For panel data applications, it would average across cross-sectional units first, but here we treat the data as a single time series.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Design matrix (T × k)</li><li><code>u</code>: Residuals vector (T × 1)</li><li><code>bandwidth</code>: Bandwidth for kernel. If 0, uses optimal bandwidth selection.</li><li><code>kernel</code>: Kernel function (:bartlett, :parzen, :quadratic<em>spectral, :tukey</em>hanning)</li><li><code>XtX_inv</code>: Pre-computed (X&#39;X)^{-1} for performance (optional)</li></ul><p><strong>Returns</strong></p><p>Robust covariance matrix (k × k)</p><p><strong>References</strong></p><ul><li>Driscoll, J. C., &amp; Kraay, A. C. (1998). Consistent covariance matrix estimation with spatially dependent panel data. Review of Economics and Statistics.</li></ul><p><strong>Performance</strong></p><p>Pass <code>XtX_inv</code> when calling multiple times with the same X to avoid recomputation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L372-L400">source</a></section><section><div><pre><code class="language-julia hljs">driscoll_kraay(X::AbstractMatrix{T}, U::AbstractMatrix{T};
               bandwidth::Int=0, kernel::Symbol=:bartlett) -&gt; Matrix{T}</code></pre><p>Driscoll-Kraay standard errors for multi-equation system.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L422-L427">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.robust_vcov"><a class="docstring-binding" href="#MacroEconometricModels.robust_vcov"><code>MacroEconometricModels.robust_vcov</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">robust_vcov(X::AbstractMatrix{T}, residuals::AbstractVecOrMat{T},
            estimator::AbstractCovarianceEstimator) -&gt; Matrix{T}</code></pre><p>Dispatch to appropriate covariance estimator based on estimator type.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L446-L451">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.long_run_variance"><a class="docstring-binding" href="#MacroEconometricModels.long_run_variance"><code>MacroEconometricModels.long_run_variance</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">long_run_variance(x::AbstractVector{T}; bandwidth::Int=0, kernel::Symbol=:bartlett) -&gt; T</code></pre><p>Estimate long-run variance: S = Σⱼ₌₋∞^∞ γⱼ</p><p>Used for unit root tests, cointegration tests, and other applications requiring consistent variance estimation under serial correlation.</p><p><strong>Arguments</strong></p><ul><li><code>x</code>: Time series vector</li><li><code>bandwidth</code>: Truncation lag (0 = automatic)</li><li><code>kernel</code>: Kernel function</li></ul><p><strong>Returns</strong></p><p>Long-run variance estimate (scalar)</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L514-L529">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.long_run_covariance"><a class="docstring-binding" href="#MacroEconometricModels.long_run_covariance"><code>MacroEconometricModels.long_run_covariance</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">long_run_covariance(X::AbstractMatrix{T}; bandwidth::Int=0, kernel::Symbol=:bartlett) -&gt; Matrix{T}</code></pre><p>Estimate long-run covariance matrix of multivariate time series.</p><p><strong>Arguments</strong></p><ul><li><code>X</code>: Multivariate time series (T × k)</li><li><code>bandwidth</code>: Truncation lag (0 = automatic)</li><li><code>kernel</code>: Kernel function</li></ul><p><strong>Returns</strong></p><p>Long-run covariance matrix (k × k)</p><p><strong>Performance</strong></p><p>Uses BLAS matrix operations for lag autocovariance computation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L549-L564">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.optimal_bandwidth_nw"><a class="docstring-binding" href="#MacroEconometricModels.optimal_bandwidth_nw"><code>MacroEconometricModels.optimal_bandwidth_nw</code></a> — <span class="docstring-category">Function</span></summary><section><div><pre><code class="language-julia hljs">optimal_bandwidth_nw(residuals::AbstractVector{T}) -&gt; Int</code></pre><p>Compute optimal bandwidth using Newey-West (1994) automatic selection.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L144-L148">source</a></section><section><div><pre><code class="language-julia hljs">optimal_bandwidth_nw(residuals::AbstractMatrix{T}) -&gt; Int</code></pre><p>Multivariate version: average optimal bandwidth across columns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/covariance.jl#L165-L169">source</a></section></details></article><hr/><h2 id="Utility-Functions"><a class="docs-heading-anchor" href="#Utility-Functions">Utility Functions</a><a id="Utility-Functions-1"></a><a class="docs-heading-anchor-permalink" href="#Utility-Functions" title="Permalink"></a></h2><article><details class="docstring" open="true"><summary id="MacroEconometricModels._default_names-Tuple{Int64, String}"><a class="docstring-binding" href="#MacroEconometricModels._default_names-Tuple{Int64, String}"><code>MacroEconometricModels._default_names</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Generate default names: [&quot;prefix 1&quot;, &quot;prefix 2&quot;, ...]</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L256">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._suppress_warnings-Tuple{Any}"><a class="docstring-binding" href="#MacroEconometricModels._suppress_warnings-Tuple{Any}"><code>MacroEconometricModels._suppress_warnings</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Suppress all log messages (warnings, info) within <code>f()</code>. Used in bootstrap loops.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L121">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._validate_data"><a class="docstring-binding" href="#MacroEconometricModels._validate_data"><code>MacroEconometricModels._validate_data</code></a> — <span class="docstring-category">Function</span></summary><section><div><p>Validate data contains no NaN or Inf values.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L76">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._validate_narrative_data-Tuple{Symbol, AbstractMatrix}"><a class="docstring-binding" href="#MacroEconometricModels._validate_narrative_data-Tuple{Symbol, AbstractMatrix}"><code>MacroEconometricModels._validate_narrative_data</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate that narrative method has required data matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L246">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels._validate_var_shock_indices-Tuple{String, String, Vector{String}, Vector{String}}"><a class="docstring-binding" href="#MacroEconometricModels._validate_var_shock_indices-Tuple{String, String, Vector{String}, Vector{String}}"><code>MacroEconometricModels._validate_var_shock_indices</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Resolve variable/shock names to indices, throwing on invalid names.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L236">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.companion_matrix-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.companion_matrix-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.companion_matrix</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Construct companion matrix F for VAR(p) → VAR(1) representation.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L201">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.construct_var_matrices-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.construct_var_matrices-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.construct_var_matrices</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Construct VAR design matrices: Y<em>eff = X * B + U. Returns (Y</em>eff, X) where X = [1, Y<em>{t-1}, ..., Y</em>{t-p}].</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L174-L177">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.extract_ar_coefficients-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T"><a class="docstring-binding" href="#MacroEconometricModels.extract_ar_coefficients-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64, Int64}} where T"><code>MacroEconometricModels.extract_ar_coefficients</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Extract AR coefficient matrices [A₁, ..., Aₚ] from stacked B matrix.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L196">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.logdet_safe-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.logdet_safe-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.logdet_safe</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Log determinant with eigenvalue fallback for numerical issues.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L159">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.robust_inv-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.robust_inv-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.robust_inv</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Compute inverse with fallback to pseudo-inverse for singular matrices.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L128">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.safe_cholesky-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.safe_cholesky-Union{Tuple{AbstractMatrix{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.safe_cholesky</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Cholesky decomposition with automatic jitter for numerical stability.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L143">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.univariate_ar_variance-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><a class="docstring-binding" href="#MacroEconometricModels.univariate_ar_variance-Union{Tuple{AbstractVector{T}}, Tuple{T}} where T&lt;:AbstractFloat"><code>MacroEconometricModels.univariate_ar_variance</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>AR(1) residual standard deviation for Minnesota prior scaling.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L222">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_dynamic_factor_inputs-NTuple{4, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.validate_dynamic_factor_inputs-NTuple{4, Int64}"><code>MacroEconometricModels.validate_dynamic_factor_inputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate dynamic factor model inputs.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L44">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_factor_inputs-Tuple{Int64, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.validate_factor_inputs-Tuple{Int64, Int64, Int64}"><code>MacroEconometricModels.validate_factor_inputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate factor model inputs: 1 ≤ r ≤ min(T, N).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L37">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_horizon-Tuple{Int64}"><a class="docstring-binding" href="#MacroEconometricModels.validate_horizon-Tuple{Int64}"><code>MacroEconometricModels.validate_horizon</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate horizon: h ≥ min_val (default 1).</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L68">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_in_range-Tuple{Real, String, Real, Real}"><a class="docstring-binding" href="#MacroEconometricModels.validate_in_range-Tuple{Real, String, Real, Real}"><code>MacroEconometricModels.validate_in_range</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate lo ≤ value ≤ hi.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L56">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_lags-Tuple{Int64}"><a class="docstring-binding" href="#MacroEconometricModels.validate_lags-Tuple{Int64}"><code>MacroEconometricModels.validate_lags</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate lag order: p ≥ 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L64">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_nonnegative-Tuple{Real, String}"><a class="docstring-binding" href="#MacroEconometricModels.validate_nonnegative-Tuple{Real, String}"><code>MacroEconometricModels.validate_nonnegative</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate value ≥ 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L60">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_option-Tuple{Symbol, String, Tuple}"><a class="docstring-binding" href="#MacroEconometricModels.validate_option-Tuple{Symbol, String, Tuple}"><code>MacroEconometricModels.validate_option</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate symbol is in valid_options.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L72">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_positive-Tuple{Real, String}"><a class="docstring-binding" href="#MacroEconometricModels.validate_positive-Tuple{Real, String}"><code>MacroEconometricModels.validate_positive</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate value &gt; 0.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L52">source</a></section></details></article><article><details class="docstring" open="true"><summary id="MacroEconometricModels.validate_var_inputs-Tuple{Int64, Int64, Int64}"><a class="docstring-binding" href="#MacroEconometricModels.validate_var_inputs-Tuple{Int64, Int64, Int64}"><code>MacroEconometricModels.validate_var_inputs</code></a> — <span class="docstring-category">Method</span></summary><section><div><p>Validate VAR inputs: p ≥ 1, T &gt; p + min<em>obs</em>factor, n ≥ 1.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/FriedmanJP/MacroEconometricModels.jl/blob/35938be082889d36d4ecfbed43298680da7f34f2/src/core/utils.jl#L29">source</a></section></details></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../api_types/">« Types</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.16.1 on <span class="colophon-date" title="Friday 20 February 2026 19:11">Friday 20 February 2026</span>. Using Julia version 1.10.10.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
