<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Structural LP IRF (cholesky)</title>
<style>* { margin: 0; padding: 0; box-sizing: border-box; }
body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Arial, sans-serif;
    background: #fff;
    color: #333;
    padding: 20px;
}
.figure-title {
    font-size: 18px;
    font-weight: 600;
    text-align: center;
    margin-bottom: 16px;
    color: #222;
}
.figure-source {
    font-size: 11px;
    color: #888;
    text-align: center;
    margin-top: 8px;
}
.panel-grid {
    display: flex;
    flex-wrap: wrap;
    gap: 16px;
    justify-content: center;
}
.panel {
    width: calc(33% - 16px);
    min-width: 300px;
    background: #fff;
    border: 1px solid #e0e0e0;
    border-radius: 4px;
    padding: 12px;
}
.panel-title {
    font-size: 13px;
    font-weight: 600;
    text-align: center;
    margin-bottom: 8px;
    color: #444;
}
.axis text { font-size: 11px; fill: #666; }
.axis line, .axis path { stroke: #ccc; }
.grid line { stroke: #f0f0f0; stroke-dasharray: 2,2; }
.grid .domain { stroke: none; }
.tooltip {
    position: absolute;
    background: rgba(0,0,0,0.8);
    color: #fff;
    padding: 6px 10px;
    border-radius: 4px;
    font-size: 11px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.15s;
    z-index: 1000;
}
.legend { font-size: 11px; }
.legend rect { rx: 2; }
svg { overflow: visible; }
</style>
</head>
<body>
<div class="figure-title">Structural LP IRF (cholesky)</div>
<div class="panel-grid">
<div class="panel">
<div class="panel-title">y1 ← y1</div>
<div id="irf_31"></div>
</div>
<div class="panel">
<div class="panel-title">y2 ← y1</div>
<div id="irf_32"></div>
</div>
<div class="panel">
<div class="panel-title">y3 ← y1</div>
<div id="irf_33"></div>
</div>
<div class="panel">
<div class="panel-title">y1 ← y2</div>
<div id="irf_34"></div>
</div>
<div class="panel">
<div class="panel-title">y2 ← y2</div>
<div id="irf_35"></div>
</div>
<div class="panel">
<div class="panel-title">y3 ← y2</div>
<div id="irf_36"></div>
</div>
<div class="panel">
<div class="panel-title">y1 ← y3</div>
<div id="irf_37"></div>
</div>
<div class="panel">
<div class="panel-title">y2 ← y3</div>
<div id="irf_38"></div>
</div>
<div class="panel">
<div class="panel-title">y3 ← y3</div>
<div id="irf_39"></div>
</div>
</div>

<div class="tooltip" id="tooltip"></div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
<script>
// Shared utilities
const tooltip = d3.select('#tooltip');
function fmt(v) {
    if (v === null || v === undefined) return '';
    return Math.abs(v) >= 1000 ? v.toFixed(1) : (Math.abs(v) >= 1 ? v.toFixed(3) : v.toFixed(4));
}
function showTip(evt, html) {
    tooltip.html(html).style('opacity',1)
        .style('left',(evt.pageX+12)+'px').style('top',(evt.pageY-28)+'px');
}
function hideTip() { tooltip.style('opacity',0); }

(function() {
    const data = [{"x":0,"irf":0.002330997482190871,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":1,"irf":-0.0002297645721544303,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":2,"irf":0.0002192885408277192,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":3,"irf":0.0007853662675901835,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":4,"irf":0.00018696548913100383,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":5,"irf":0.00033560002524697663,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":6,"irf":0.00032176681228002836,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":7,"irf":-0.0002740394415231493,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":8,"irf":0.00018030157811939386,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":9,"irf":0.0010763835111881565,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":10,"irf":-0.00017335295769840044,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":11,"irf":-0.0003990815836276817,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":12,"irf":-0.0002786758355710704,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":13,"irf":-0.0002618273788670178,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":14,"irf":-0.00016956131793356013,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":15,"irf":-7.063498431562432e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":16,"irf":7.296928162057887e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":17,"irf":-6.362474259213038e-6,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":18,"irf":-0.00024388157212178446,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":19,"irf":-0.0001853490501117545,"ci_lo":0.0,"ci_hi":0.0,"zero":0}];
    const series = [{"name":"IRF","color":"#1f77b4","key":"irf","dash":""}];
    const bands = [{"lo_key":"ci_lo","hi_key":"ci_hi","color":"#1f77b4","alpha":0.15}];
    const refLines = [{"value":0,"color":"#999","dash":"4,3"}];

    const container = d3.select('#irf_31');
    const W = Math.max(container.node().clientWidth - 24, 280);
    const margin = {top:10, right:15, bottom:35, left:55};
    const w = W - margin.left - margin.right;
    const h = Math.min(w * 0.6, 250);

    const svg = container.append('svg').attr('width', W).attr('height', h + margin.top + margin.bottom);
    const g = svg.append('g').attr('transform', 'translate('+margin.left+','+margin.top+')');

    // Compute domains
    const xVals = data.map(d => d.x);
    const allYVals = [];
    series.forEach(s => data.forEach(d => { if(d[s.key]!==null) allYVals.push(d[s.key]); }));
    bands.forEach(b => data.forEach(d => {
        if(d[b.lo_key]!==null) allYVals.push(d[b.lo_key]);
        if(d[b.hi_key]!==null) allYVals.push(d[b.hi_key]);
    }));
    refLines.forEach(r => allYVals.push(r.value));

    const x = d3.scaleLinear().domain(d3.extent(xVals)).range([0,w]);
    const yExt = d3.extent(allYVals);
    const yPad = (yExt[1]-yExt[0])*0.08 || 1;
    const y = d3.scaleLinear().domain([yExt[0]-yPad, yExt[1]+yPad]).range([h,0]);

    // Grid
    g.append('g').attr('class','grid').call(d3.axisLeft(y).tickSize(-w).tickFormat(''));

    // Bands
    bands.forEach(b => {
        const area = d3.area()
            .x(d => x(d.x))
            .y0(d => y(d[b.lo_key]!==null ? d[b.lo_key] : 0))
            .y1(d => y(d[b.hi_key]!==null ? d[b.hi_key] : 0))
            .defined(d => d[b.lo_key]!==null && d[b.hi_key]!==null);
        g.append('path').datum(data).attr('d',area)
            .attr('fill',b.color).attr('opacity',b.alpha||0.15);
    });

    // Reference lines
    refLines.forEach(r => {
        g.append('line').attr('x1',0).attr('x2',w)
            .attr('y1',y(r.value)).attr('y2',y(r.value))
            .attr('stroke',r.color||'#999').attr('stroke-width',1)
            .attr('stroke-dasharray',r.dash||'4,3');
    });

    // Lines
    series.forEach(s => {
        const line = d3.line().x(d=>x(d.x)).y(d=>y(d[s.key]))
            .defined(d=>d[s.key]!==null);
        g.append('path').datum(data).attr('d',line)
            .attr('fill','none').attr('stroke',s.color).attr('stroke-width',1.8)
            .attr('stroke-dasharray',s.dash||'');
    });

    // Axes
    g.append('g').attr('class','axis').attr('transform','translate(0,'+h+')')
        .call(d3.axisBottom(x).ticks(Math.min(xVals.length,8)));
    g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(6));

    if('Horizon') g.append('text').attr('x',w/2).attr('y',h+30).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Horizon');
    if('Response') g.append('text').attr('transform','rotate(-90)')
        .attr('x',-h/2).attr('y',-42).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Response');

    // Legend
    if(series.length > 1) {
        const leg = g.append('g').attr('class','legend').attr('transform','translate(5,-5)');
        series.forEach((s,i) => {
            const gi = leg.append('g').attr('transform','translate('+(i*100)+',0)');
            gi.append('line').attr('x1',0).attr('x2',16).attr('y1',0).attr('y2',0)
                .attr('stroke',s.color).attr('stroke-width',2)
                .attr('stroke-dasharray',s.dash||'');
            gi.append('text').attr('x',20).attr('y',4).attr('font-size','10px')
                .attr('fill','#555').text(s.name);
        });
    }

    // Tooltip overlay
    svg.append('rect').attr('width',W).attr('height',h+margin.top+margin.bottom)
        .attr('fill','none').attr('pointer-events','all')
        .on('mousemove', function(evt) {
            const [mx] = d3.pointer(evt, g.node());
            const x0 = x.invert(mx);
            const idx = d3.minIndex(data, d => Math.abs(d.x - x0));
            const d = data[idx];
            let html = '<b>x='+fmt(d.x)+'</b>';
            series.forEach(s => { if(d[s.key]!==null) html += '<br>'+s.name+': '+fmt(d[s.key]); });
            showTip(evt, html);
        })
        .on('mouseout', hideTip);
})();

(function() {
    const data = [{"x":0,"irf":-0.08431073821804026,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":1,"irf":0.014490983646245261,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":2,"irf":-0.013468403753602708,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":3,"irf":-0.004851245135510915,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":4,"irf":0.003959800462646239,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":5,"irf":-0.008138071026182862,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":6,"irf":-0.008547069440012604,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":7,"irf":-0.0023521956438945437,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":8,"irf":-0.013267611719687697,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":9,"irf":-0.004386865657355009,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":10,"irf":-0.0002846079662706667,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":11,"irf":-0.011214965452664078,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":12,"irf":-0.00021769258141759095,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":13,"irf":-0.011296293738348232,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":14,"irf":0.005311986956765601,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":15,"irf":0.009378614428997109,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":16,"irf":0.009975129860956083,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":17,"irf":0.00010161177032070478,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":18,"irf":0.005653891971032491,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":19,"irf":0.009724883377476568,"ci_lo":0.0,"ci_hi":0.0,"zero":0}];
    const series = [{"name":"IRF","color":"#1f77b4","key":"irf","dash":""}];
    const bands = [{"lo_key":"ci_lo","hi_key":"ci_hi","color":"#1f77b4","alpha":0.15}];
    const refLines = [{"value":0,"color":"#999","dash":"4,3"}];

    const container = d3.select('#irf_32');
    const W = Math.max(container.node().clientWidth - 24, 280);
    const margin = {top:10, right:15, bottom:35, left:55};
    const w = W - margin.left - margin.right;
    const h = Math.min(w * 0.6, 250);

    const svg = container.append('svg').attr('width', W).attr('height', h + margin.top + margin.bottom);
    const g = svg.append('g').attr('transform', 'translate('+margin.left+','+margin.top+')');

    // Compute domains
    const xVals = data.map(d => d.x);
    const allYVals = [];
    series.forEach(s => data.forEach(d => { if(d[s.key]!==null) allYVals.push(d[s.key]); }));
    bands.forEach(b => data.forEach(d => {
        if(d[b.lo_key]!==null) allYVals.push(d[b.lo_key]);
        if(d[b.hi_key]!==null) allYVals.push(d[b.hi_key]);
    }));
    refLines.forEach(r => allYVals.push(r.value));

    const x = d3.scaleLinear().domain(d3.extent(xVals)).range([0,w]);
    const yExt = d3.extent(allYVals);
    const yPad = (yExt[1]-yExt[0])*0.08 || 1;
    const y = d3.scaleLinear().domain([yExt[0]-yPad, yExt[1]+yPad]).range([h,0]);

    // Grid
    g.append('g').attr('class','grid').call(d3.axisLeft(y).tickSize(-w).tickFormat(''));

    // Bands
    bands.forEach(b => {
        const area = d3.area()
            .x(d => x(d.x))
            .y0(d => y(d[b.lo_key]!==null ? d[b.lo_key] : 0))
            .y1(d => y(d[b.hi_key]!==null ? d[b.hi_key] : 0))
            .defined(d => d[b.lo_key]!==null && d[b.hi_key]!==null);
        g.append('path').datum(data).attr('d',area)
            .attr('fill',b.color).attr('opacity',b.alpha||0.15);
    });

    // Reference lines
    refLines.forEach(r => {
        g.append('line').attr('x1',0).attr('x2',w)
            .attr('y1',y(r.value)).attr('y2',y(r.value))
            .attr('stroke',r.color||'#999').attr('stroke-width',1)
            .attr('stroke-dasharray',r.dash||'4,3');
    });

    // Lines
    series.forEach(s => {
        const line = d3.line().x(d=>x(d.x)).y(d=>y(d[s.key]))
            .defined(d=>d[s.key]!==null);
        g.append('path').datum(data).attr('d',line)
            .attr('fill','none').attr('stroke',s.color).attr('stroke-width',1.8)
            .attr('stroke-dasharray',s.dash||'');
    });

    // Axes
    g.append('g').attr('class','axis').attr('transform','translate(0,'+h+')')
        .call(d3.axisBottom(x).ticks(Math.min(xVals.length,8)));
    g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(6));

    if('Horizon') g.append('text').attr('x',w/2).attr('y',h+30).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Horizon');
    if('Response') g.append('text').attr('transform','rotate(-90)')
        .attr('x',-h/2).attr('y',-42).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Response');

    // Legend
    if(series.length > 1) {
        const leg = g.append('g').attr('class','legend').attr('transform','translate(5,-5)');
        series.forEach((s,i) => {
            const gi = leg.append('g').attr('transform','translate('+(i*100)+',0)');
            gi.append('line').attr('x1',0).attr('x2',16).attr('y1',0).attr('y2',0)
                .attr('stroke',s.color).attr('stroke-width',2)
                .attr('stroke-dasharray',s.dash||'');
            gi.append('text').attr('x',20).attr('y',4).attr('font-size','10px')
                .attr('fill','#555').text(s.name);
        });
    }

    // Tooltip overlay
    svg.append('rect').attr('width',W).attr('height',h+margin.top+margin.bottom)
        .attr('fill','none').attr('pointer-events','all')
        .on('mousemove', function(evt) {
            const [mx] = d3.pointer(evt, g.node());
            const x0 = x.invert(mx);
            const idx = d3.minIndex(data, d => Math.abs(d.x - x0));
            const d = data[idx];
            let html = '<b>x='+fmt(d.x)+'</b>';
            series.forEach(s => { if(d[s.key]!==null) html += '<br>'+s.name+': '+fmt(d[s.key]); });
            showTip(evt, html);
        })
        .on('mouseout', hideTip);
})();

(function() {
    const data = [{"x":0,"irf":-5.700453368001623e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":1,"irf":2.8712441659545537e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":2,"irf":5.98158614879986e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":3,"irf":-6.392131576192133e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":4,"irf":-0.0001243520218017242,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":5,"irf":6.992775681794713e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":6,"irf":1.5034071308159017e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":7,"irf":-2.7020868509353478e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":8,"irf":-0.00011825666291129864,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":9,"irf":0.000135746287126167,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":10,"irf":5.173935619686414e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":11,"irf":4.402175717749148e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":12,"irf":-5.067571974693915e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":13,"irf":-4.165875787814648e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":14,"irf":-4.337086527664982e-6,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":15,"irf":-2.976938354108442e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":16,"irf":0.0001287964618869706,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":17,"irf":-7.431100183619946e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":18,"irf":-1.787478069185176e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":19,"irf":-8.676424149597046e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0}];
    const series = [{"name":"IRF","color":"#1f77b4","key":"irf","dash":""}];
    const bands = [{"lo_key":"ci_lo","hi_key":"ci_hi","color":"#1f77b4","alpha":0.15}];
    const refLines = [{"value":0,"color":"#999","dash":"4,3"}];

    const container = d3.select('#irf_33');
    const W = Math.max(container.node().clientWidth - 24, 280);
    const margin = {top:10, right:15, bottom:35, left:55};
    const w = W - margin.left - margin.right;
    const h = Math.min(w * 0.6, 250);

    const svg = container.append('svg').attr('width', W).attr('height', h + margin.top + margin.bottom);
    const g = svg.append('g').attr('transform', 'translate('+margin.left+','+margin.top+')');

    // Compute domains
    const xVals = data.map(d => d.x);
    const allYVals = [];
    series.forEach(s => data.forEach(d => { if(d[s.key]!==null) allYVals.push(d[s.key]); }));
    bands.forEach(b => data.forEach(d => {
        if(d[b.lo_key]!==null) allYVals.push(d[b.lo_key]);
        if(d[b.hi_key]!==null) allYVals.push(d[b.hi_key]);
    }));
    refLines.forEach(r => allYVals.push(r.value));

    const x = d3.scaleLinear().domain(d3.extent(xVals)).range([0,w]);
    const yExt = d3.extent(allYVals);
    const yPad = (yExt[1]-yExt[0])*0.08 || 1;
    const y = d3.scaleLinear().domain([yExt[0]-yPad, yExt[1]+yPad]).range([h,0]);

    // Grid
    g.append('g').attr('class','grid').call(d3.axisLeft(y).tickSize(-w).tickFormat(''));

    // Bands
    bands.forEach(b => {
        const area = d3.area()
            .x(d => x(d.x))
            .y0(d => y(d[b.lo_key]!==null ? d[b.lo_key] : 0))
            .y1(d => y(d[b.hi_key]!==null ? d[b.hi_key] : 0))
            .defined(d => d[b.lo_key]!==null && d[b.hi_key]!==null);
        g.append('path').datum(data).attr('d',area)
            .attr('fill',b.color).attr('opacity',b.alpha||0.15);
    });

    // Reference lines
    refLines.forEach(r => {
        g.append('line').attr('x1',0).attr('x2',w)
            .attr('y1',y(r.value)).attr('y2',y(r.value))
            .attr('stroke',r.color||'#999').attr('stroke-width',1)
            .attr('stroke-dasharray',r.dash||'4,3');
    });

    // Lines
    series.forEach(s => {
        const line = d3.line().x(d=>x(d.x)).y(d=>y(d[s.key]))
            .defined(d=>d[s.key]!==null);
        g.append('path').datum(data).attr('d',line)
            .attr('fill','none').attr('stroke',s.color).attr('stroke-width',1.8)
            .attr('stroke-dasharray',s.dash||'');
    });

    // Axes
    g.append('g').attr('class','axis').attr('transform','translate(0,'+h+')')
        .call(d3.axisBottom(x).ticks(Math.min(xVals.length,8)));
    g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(6));

    if('Horizon') g.append('text').attr('x',w/2).attr('y',h+30).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Horizon');
    if('Response') g.append('text').attr('transform','rotate(-90)')
        .attr('x',-h/2).attr('y',-42).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Response');

    // Legend
    if(series.length > 1) {
        const leg = g.append('g').attr('class','legend').attr('transform','translate(5,-5)');
        series.forEach((s,i) => {
            const gi = leg.append('g').attr('transform','translate('+(i*100)+',0)');
            gi.append('line').attr('x1',0).attr('x2',16).attr('y1',0).attr('y2',0)
                .attr('stroke',s.color).attr('stroke-width',2)
                .attr('stroke-dasharray',s.dash||'');
            gi.append('text').attr('x',20).attr('y',4).attr('font-size','10px')
                .attr('fill','#555').text(s.name);
        });
    }

    // Tooltip overlay
    svg.append('rect').attr('width',W).attr('height',h+margin.top+margin.bottom)
        .attr('fill','none').attr('pointer-events','all')
        .on('mousemove', function(evt) {
            const [mx] = d3.pointer(evt, g.node());
            const x0 = x.invert(mx);
            const idx = d3.minIndex(data, d => Math.abs(d.x - x0));
            const d = data[idx];
            let html = '<b>x='+fmt(d.x)+'</b>';
            series.forEach(s => { if(d[s.key]!==null) html += '<br>'+s.name+': '+fmt(d[s.key]); });
            showTip(evt, html);
        })
        .on('mouseout', hideTip);
})();

(function() {
    const data = [{"x":0,"irf":0.000673827866935817,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":1,"irf":0.0019336767143849456,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":2,"irf":0.001429555675212355,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":3,"irf":0.0007783248995865518,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":4,"irf":0.00012314161726891733,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":5,"irf":0.0005365872274123961,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":6,"irf":0.0004387248245089336,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":7,"irf":0.0006611808642400318,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":8,"irf":0.0004732531243404667,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":9,"irf":-0.0004795684996326556,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":10,"irf":0.0007597796347856969,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":11,"irf":-2.1619045287303226e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":12,"irf":0.0003884588310748397,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":13,"irf":0.0003141934279787291,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":14,"irf":0.00016489208027577982,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":15,"irf":-3.379084075405886e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":16,"irf":-0.00022262978283768935,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":17,"irf":0.00041838688155375196,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":18,"irf":0.0005370967888411052,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":19,"irf":-3.808172074677414e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0}];
    const series = [{"name":"IRF","color":"#1f77b4","key":"irf","dash":""}];
    const bands = [{"lo_key":"ci_lo","hi_key":"ci_hi","color":"#1f77b4","alpha":0.15}];
    const refLines = [{"value":0,"color":"#999","dash":"4,3"}];

    const container = d3.select('#irf_34');
    const W = Math.max(container.node().clientWidth - 24, 280);
    const margin = {top:10, right:15, bottom:35, left:55};
    const w = W - margin.left - margin.right;
    const h = Math.min(w * 0.6, 250);

    const svg = container.append('svg').attr('width', W).attr('height', h + margin.top + margin.bottom);
    const g = svg.append('g').attr('transform', 'translate('+margin.left+','+margin.top+')');

    // Compute domains
    const xVals = data.map(d => d.x);
    const allYVals = [];
    series.forEach(s => data.forEach(d => { if(d[s.key]!==null) allYVals.push(d[s.key]); }));
    bands.forEach(b => data.forEach(d => {
        if(d[b.lo_key]!==null) allYVals.push(d[b.lo_key]);
        if(d[b.hi_key]!==null) allYVals.push(d[b.hi_key]);
    }));
    refLines.forEach(r => allYVals.push(r.value));

    const x = d3.scaleLinear().domain(d3.extent(xVals)).range([0,w]);
    const yExt = d3.extent(allYVals);
    const yPad = (yExt[1]-yExt[0])*0.08 || 1;
    const y = d3.scaleLinear().domain([yExt[0]-yPad, yExt[1]+yPad]).range([h,0]);

    // Grid
    g.append('g').attr('class','grid').call(d3.axisLeft(y).tickSize(-w).tickFormat(''));

    // Bands
    bands.forEach(b => {
        const area = d3.area()
            .x(d => x(d.x))
            .y0(d => y(d[b.lo_key]!==null ? d[b.lo_key] : 0))
            .y1(d => y(d[b.hi_key]!==null ? d[b.hi_key] : 0))
            .defined(d => d[b.lo_key]!==null && d[b.hi_key]!==null);
        g.append('path').datum(data).attr('d',area)
            .attr('fill',b.color).attr('opacity',b.alpha||0.15);
    });

    // Reference lines
    refLines.forEach(r => {
        g.append('line').attr('x1',0).attr('x2',w)
            .attr('y1',y(r.value)).attr('y2',y(r.value))
            .attr('stroke',r.color||'#999').attr('stroke-width',1)
            .attr('stroke-dasharray',r.dash||'4,3');
    });

    // Lines
    series.forEach(s => {
        const line = d3.line().x(d=>x(d.x)).y(d=>y(d[s.key]))
            .defined(d=>d[s.key]!==null);
        g.append('path').datum(data).attr('d',line)
            .attr('fill','none').attr('stroke',s.color).attr('stroke-width',1.8)
            .attr('stroke-dasharray',s.dash||'');
    });

    // Axes
    g.append('g').attr('class','axis').attr('transform','translate(0,'+h+')')
        .call(d3.axisBottom(x).ticks(Math.min(xVals.length,8)));
    g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(6));

    if('Horizon') g.append('text').attr('x',w/2).attr('y',h+30).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Horizon');
    if('Response') g.append('text').attr('transform','rotate(-90)')
        .attr('x',-h/2).attr('y',-42).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Response');

    // Legend
    if(series.length > 1) {
        const leg = g.append('g').attr('class','legend').attr('transform','translate(5,-5)');
        series.forEach((s,i) => {
            const gi = leg.append('g').attr('transform','translate('+(i*100)+',0)');
            gi.append('line').attr('x1',0).attr('x2',16).attr('y1',0).attr('y2',0)
                .attr('stroke',s.color).attr('stroke-width',2)
                .attr('stroke-dasharray',s.dash||'');
            gi.append('text').attr('x',20).attr('y',4).attr('font-size','10px')
                .attr('fill','#555').text(s.name);
        });
    }

    // Tooltip overlay
    svg.append('rect').attr('width',W).attr('height',h+margin.top+margin.bottom)
        .attr('fill','none').attr('pointer-events','all')
        .on('mousemove', function(evt) {
            const [mx] = d3.pointer(evt, g.node());
            const x0 = x.invert(mx);
            const idx = d3.minIndex(data, d => Math.abs(d.x - x0));
            const d = data[idx];
            let html = '<b>x='+fmt(d.x)+'</b>';
            series.forEach(s => { if(d[s.key]!==null) html += '<br>'+s.name+': '+fmt(d[s.key]); });
            showTip(evt, html);
        })
        .on('mouseout', hideTip);
})();

(function() {
    const data = [{"x":0,"irf":-0.0670459458726619,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":1,"irf":-0.053248090105750975,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":2,"irf":-0.023348547921654538,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":3,"irf":-0.047483366622497164,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":4,"irf":-0.009765065236630746,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":5,"irf":-0.027530031867352277,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":6,"irf":-0.007544629018928281,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":7,"irf":0.0003240690460173861,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":8,"irf":-0.0045658515365453334,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":9,"irf":-0.008047964387132097,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":10,"irf":0.006793127424285908,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":11,"irf":-0.009724857334621063,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":12,"irf":-0.002027729244565725,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":13,"irf":-0.003704987423958613,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":14,"irf":0.0009379541625003397,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":15,"irf":0.010718862928319743,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":16,"irf":-0.006506908203391966,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":17,"irf":0.0024952229950315633,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":18,"irf":-0.008024641426191319,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":19,"irf":0.0012753136178281213,"ci_lo":0.0,"ci_hi":0.0,"zero":0}];
    const series = [{"name":"IRF","color":"#1f77b4","key":"irf","dash":""}];
    const bands = [{"lo_key":"ci_lo","hi_key":"ci_hi","color":"#1f77b4","alpha":0.15}];
    const refLines = [{"value":0,"color":"#999","dash":"4,3"}];

    const container = d3.select('#irf_35');
    const W = Math.max(container.node().clientWidth - 24, 280);
    const margin = {top:10, right:15, bottom:35, left:55};
    const w = W - margin.left - margin.right;
    const h = Math.min(w * 0.6, 250);

    const svg = container.append('svg').attr('width', W).attr('height', h + margin.top + margin.bottom);
    const g = svg.append('g').attr('transform', 'translate('+margin.left+','+margin.top+')');

    // Compute domains
    const xVals = data.map(d => d.x);
    const allYVals = [];
    series.forEach(s => data.forEach(d => { if(d[s.key]!==null) allYVals.push(d[s.key]); }));
    bands.forEach(b => data.forEach(d => {
        if(d[b.lo_key]!==null) allYVals.push(d[b.lo_key]);
        if(d[b.hi_key]!==null) allYVals.push(d[b.hi_key]);
    }));
    refLines.forEach(r => allYVals.push(r.value));

    const x = d3.scaleLinear().domain(d3.extent(xVals)).range([0,w]);
    const yExt = d3.extent(allYVals);
    const yPad = (yExt[1]-yExt[0])*0.08 || 1;
    const y = d3.scaleLinear().domain([yExt[0]-yPad, yExt[1]+yPad]).range([h,0]);

    // Grid
    g.append('g').attr('class','grid').call(d3.axisLeft(y).tickSize(-w).tickFormat(''));

    // Bands
    bands.forEach(b => {
        const area = d3.area()
            .x(d => x(d.x))
            .y0(d => y(d[b.lo_key]!==null ? d[b.lo_key] : 0))
            .y1(d => y(d[b.hi_key]!==null ? d[b.hi_key] : 0))
            .defined(d => d[b.lo_key]!==null && d[b.hi_key]!==null);
        g.append('path').datum(data).attr('d',area)
            .attr('fill',b.color).attr('opacity',b.alpha||0.15);
    });

    // Reference lines
    refLines.forEach(r => {
        g.append('line').attr('x1',0).attr('x2',w)
            .attr('y1',y(r.value)).attr('y2',y(r.value))
            .attr('stroke',r.color||'#999').attr('stroke-width',1)
            .attr('stroke-dasharray',r.dash||'4,3');
    });

    // Lines
    series.forEach(s => {
        const line = d3.line().x(d=>x(d.x)).y(d=>y(d[s.key]))
            .defined(d=>d[s.key]!==null);
        g.append('path').datum(data).attr('d',line)
            .attr('fill','none').attr('stroke',s.color).attr('stroke-width',1.8)
            .attr('stroke-dasharray',s.dash||'');
    });

    // Axes
    g.append('g').attr('class','axis').attr('transform','translate(0,'+h+')')
        .call(d3.axisBottom(x).ticks(Math.min(xVals.length,8)));
    g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(6));

    if('Horizon') g.append('text').attr('x',w/2).attr('y',h+30).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Horizon');
    if('Response') g.append('text').attr('transform','rotate(-90)')
        .attr('x',-h/2).attr('y',-42).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Response');

    // Legend
    if(series.length > 1) {
        const leg = g.append('g').attr('class','legend').attr('transform','translate(5,-5)');
        series.forEach((s,i) => {
            const gi = leg.append('g').attr('transform','translate('+(i*100)+',0)');
            gi.append('line').attr('x1',0).attr('x2',16).attr('y1',0).attr('y2',0)
                .attr('stroke',s.color).attr('stroke-width',2)
                .attr('stroke-dasharray',s.dash||'');
            gi.append('text').attr('x',20).attr('y',4).attr('font-size','10px')
                .attr('fill','#555').text(s.name);
        });
    }

    // Tooltip overlay
    svg.append('rect').attr('width',W).attr('height',h+margin.top+margin.bottom)
        .attr('fill','none').attr('pointer-events','all')
        .on('mousemove', function(evt) {
            const [mx] = d3.pointer(evt, g.node());
            const x0 = x.invert(mx);
            const idx = d3.minIndex(data, d => Math.abs(d.x - x0));
            const d = data[idx];
            let html = '<b>x='+fmt(d.x)+'</b>';
            series.forEach(s => { if(d[s.key]!==null) html += '<br>'+s.name+': '+fmt(d[s.key]); });
            showTip(evt, html);
        })
        .on('mouseout', hideTip);
})();

(function() {
    const data = [{"x":0,"irf":0.00017284931032461977,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":1,"irf":0.00022095514345248467,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":2,"irf":-2.4056170230988504e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":3,"irf":-0.00011804484439095719,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":4,"irf":-0.0001200453640251848,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":5,"irf":5.702226490341167e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":6,"irf":6.978059890650577e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":7,"irf":6.443927284109275e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":8,"irf":-0.00017733424265291766,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":9,"irf":0.00014036401187373214,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":10,"irf":-3.92090244815998e-6,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":11,"irf":0.00013856383512713273,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":12,"irf":-6.676453281999152e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":13,"irf":0.00010857727214902657,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":14,"irf":-0.000194908442916664,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":15,"irf":-5.2249619885971595e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":16,"irf":0.00015514144601596404,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":17,"irf":0.00013566583662137896,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":18,"irf":-8.819485758592555e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":19,"irf":-8.317999624156366e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0}];
    const series = [{"name":"IRF","color":"#1f77b4","key":"irf","dash":""}];
    const bands = [{"lo_key":"ci_lo","hi_key":"ci_hi","color":"#1f77b4","alpha":0.15}];
    const refLines = [{"value":0,"color":"#999","dash":"4,3"}];

    const container = d3.select('#irf_36');
    const W = Math.max(container.node().clientWidth - 24, 280);
    const margin = {top:10, right:15, bottom:35, left:55};
    const w = W - margin.left - margin.right;
    const h = Math.min(w * 0.6, 250);

    const svg = container.append('svg').attr('width', W).attr('height', h + margin.top + margin.bottom);
    const g = svg.append('g').attr('transform', 'translate('+margin.left+','+margin.top+')');

    // Compute domains
    const xVals = data.map(d => d.x);
    const allYVals = [];
    series.forEach(s => data.forEach(d => { if(d[s.key]!==null) allYVals.push(d[s.key]); }));
    bands.forEach(b => data.forEach(d => {
        if(d[b.lo_key]!==null) allYVals.push(d[b.lo_key]);
        if(d[b.hi_key]!==null) allYVals.push(d[b.hi_key]);
    }));
    refLines.forEach(r => allYVals.push(r.value));

    const x = d3.scaleLinear().domain(d3.extent(xVals)).range([0,w]);
    const yExt = d3.extent(allYVals);
    const yPad = (yExt[1]-yExt[0])*0.08 || 1;
    const y = d3.scaleLinear().domain([yExt[0]-yPad, yExt[1]+yPad]).range([h,0]);

    // Grid
    g.append('g').attr('class','grid').call(d3.axisLeft(y).tickSize(-w).tickFormat(''));

    // Bands
    bands.forEach(b => {
        const area = d3.area()
            .x(d => x(d.x))
            .y0(d => y(d[b.lo_key]!==null ? d[b.lo_key] : 0))
            .y1(d => y(d[b.hi_key]!==null ? d[b.hi_key] : 0))
            .defined(d => d[b.lo_key]!==null && d[b.hi_key]!==null);
        g.append('path').datum(data).attr('d',area)
            .attr('fill',b.color).attr('opacity',b.alpha||0.15);
    });

    // Reference lines
    refLines.forEach(r => {
        g.append('line').attr('x1',0).attr('x2',w)
            .attr('y1',y(r.value)).attr('y2',y(r.value))
            .attr('stroke',r.color||'#999').attr('stroke-width',1)
            .attr('stroke-dasharray',r.dash||'4,3');
    });

    // Lines
    series.forEach(s => {
        const line = d3.line().x(d=>x(d.x)).y(d=>y(d[s.key]))
            .defined(d=>d[s.key]!==null);
        g.append('path').datum(data).attr('d',line)
            .attr('fill','none').attr('stroke',s.color).attr('stroke-width',1.8)
            .attr('stroke-dasharray',s.dash||'');
    });

    // Axes
    g.append('g').attr('class','axis').attr('transform','translate(0,'+h+')')
        .call(d3.axisBottom(x).ticks(Math.min(xVals.length,8)));
    g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(6));

    if('Horizon') g.append('text').attr('x',w/2).attr('y',h+30).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Horizon');
    if('Response') g.append('text').attr('transform','rotate(-90)')
        .attr('x',-h/2).attr('y',-42).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Response');

    // Legend
    if(series.length > 1) {
        const leg = g.append('g').attr('class','legend').attr('transform','translate(5,-5)');
        series.forEach((s,i) => {
            const gi = leg.append('g').attr('transform','translate('+(i*100)+',0)');
            gi.append('line').attr('x1',0).attr('x2',16).attr('y1',0).attr('y2',0)
                .attr('stroke',s.color).attr('stroke-width',2)
                .attr('stroke-dasharray',s.dash||'');
            gi.append('text').attr('x',20).attr('y',4).attr('font-size','10px')
                .attr('fill','#555').text(s.name);
        });
    }

    // Tooltip overlay
    svg.append('rect').attr('width',W).attr('height',h+margin.top+margin.bottom)
        .attr('fill','none').attr('pointer-events','all')
        .on('mousemove', function(evt) {
            const [mx] = d3.pointer(evt, g.node());
            const x0 = x.invert(mx);
            const idx = d3.minIndex(data, d => Math.abs(d.x - x0));
            const d = data[idx];
            let html = '<b>x='+fmt(d.x)+'</b>';
            series.forEach(s => { if(d[s.key]!==null) html += '<br>'+s.name+': '+fmt(d[s.key]); });
            showTip(evt, html);
        })
        .on('mouseout', hideTip);
})();

(function() {
    const data = [{"x":0,"irf":0.0012102494235956226,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":1,"irf":0.00016755299541007935,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":2,"irf":-8.130723785927253e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":3,"irf":-0.00013873817414726048,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":4,"irf":2.5197452304482826e-6,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":5,"irf":-0.00032744429254825665,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":6,"irf":-5.176416245736135e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":7,"irf":0.00019422883024053597,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":8,"irf":-0.0003045935765068557,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":9,"irf":-0.00041653875402383533,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":10,"irf":-4.027472577429363e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":11,"irf":-0.0008138246043706374,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":12,"irf":-0.0005535282166633486,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":13,"irf":-0.0002630473354287567,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":14,"irf":-0.0003884256415973696,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":15,"irf":-0.00020937487697403968,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":16,"irf":7.475213234222071e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":17,"irf":-0.0002672730336417038,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":18,"irf":-0.0005784551323760071,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":19,"irf":-0.0003056745536166917,"ci_lo":0.0,"ci_hi":0.0,"zero":0}];
    const series = [{"name":"IRF","color":"#1f77b4","key":"irf","dash":""}];
    const bands = [{"lo_key":"ci_lo","hi_key":"ci_hi","color":"#1f77b4","alpha":0.15}];
    const refLines = [{"value":0,"color":"#999","dash":"4,3"}];

    const container = d3.select('#irf_37');
    const W = Math.max(container.node().clientWidth - 24, 280);
    const margin = {top:10, right:15, bottom:35, left:55};
    const w = W - margin.left - margin.right;
    const h = Math.min(w * 0.6, 250);

    const svg = container.append('svg').attr('width', W).attr('height', h + margin.top + margin.bottom);
    const g = svg.append('g').attr('transform', 'translate('+margin.left+','+margin.top+')');

    // Compute domains
    const xVals = data.map(d => d.x);
    const allYVals = [];
    series.forEach(s => data.forEach(d => { if(d[s.key]!==null) allYVals.push(d[s.key]); }));
    bands.forEach(b => data.forEach(d => {
        if(d[b.lo_key]!==null) allYVals.push(d[b.lo_key]);
        if(d[b.hi_key]!==null) allYVals.push(d[b.hi_key]);
    }));
    refLines.forEach(r => allYVals.push(r.value));

    const x = d3.scaleLinear().domain(d3.extent(xVals)).range([0,w]);
    const yExt = d3.extent(allYVals);
    const yPad = (yExt[1]-yExt[0])*0.08 || 1;
    const y = d3.scaleLinear().domain([yExt[0]-yPad, yExt[1]+yPad]).range([h,0]);

    // Grid
    g.append('g').attr('class','grid').call(d3.axisLeft(y).tickSize(-w).tickFormat(''));

    // Bands
    bands.forEach(b => {
        const area = d3.area()
            .x(d => x(d.x))
            .y0(d => y(d[b.lo_key]!==null ? d[b.lo_key] : 0))
            .y1(d => y(d[b.hi_key]!==null ? d[b.hi_key] : 0))
            .defined(d => d[b.lo_key]!==null && d[b.hi_key]!==null);
        g.append('path').datum(data).attr('d',area)
            .attr('fill',b.color).attr('opacity',b.alpha||0.15);
    });

    // Reference lines
    refLines.forEach(r => {
        g.append('line').attr('x1',0).attr('x2',w)
            .attr('y1',y(r.value)).attr('y2',y(r.value))
            .attr('stroke',r.color||'#999').attr('stroke-width',1)
            .attr('stroke-dasharray',r.dash||'4,3');
    });

    // Lines
    series.forEach(s => {
        const line = d3.line().x(d=>x(d.x)).y(d=>y(d[s.key]))
            .defined(d=>d[s.key]!==null);
        g.append('path').datum(data).attr('d',line)
            .attr('fill','none').attr('stroke',s.color).attr('stroke-width',1.8)
            .attr('stroke-dasharray',s.dash||'');
    });

    // Axes
    g.append('g').attr('class','axis').attr('transform','translate(0,'+h+')')
        .call(d3.axisBottom(x).ticks(Math.min(xVals.length,8)));
    g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(6));

    if('Horizon') g.append('text').attr('x',w/2).attr('y',h+30).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Horizon');
    if('Response') g.append('text').attr('transform','rotate(-90)')
        .attr('x',-h/2).attr('y',-42).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Response');

    // Legend
    if(series.length > 1) {
        const leg = g.append('g').attr('class','legend').attr('transform','translate(5,-5)');
        series.forEach((s,i) => {
            const gi = leg.append('g').attr('transform','translate('+(i*100)+',0)');
            gi.append('line').attr('x1',0).attr('x2',16).attr('y1',0).attr('y2',0)
                .attr('stroke',s.color).attr('stroke-width',2)
                .attr('stroke-dasharray',s.dash||'');
            gi.append('text').attr('x',20).attr('y',4).attr('font-size','10px')
                .attr('fill','#555').text(s.name);
        });
    }

    // Tooltip overlay
    svg.append('rect').attr('width',W).attr('height',h+margin.top+margin.bottom)
        .attr('fill','none').attr('pointer-events','all')
        .on('mousemove', function(evt) {
            const [mx] = d3.pointer(evt, g.node());
            const x0 = x.invert(mx);
            const idx = d3.minIndex(data, d => Math.abs(d.x - x0));
            const d = data[idx];
            let html = '<b>x='+fmt(d.x)+'</b>';
            series.forEach(s => { if(d[s.key]!==null) html += '<br>'+s.name+': '+fmt(d[s.key]); });
            showTip(evt, html);
        })
        .on('mouseout', hideTip);
})();

(function() {
    const data = [{"x":0,"irf":-0.037656426905583545,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":1,"irf":-0.013266864675890179,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":2,"irf":-0.0032645261211456493,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":3,"irf":0.014935516680750402,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":4,"irf":0.0008840915367257344,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":5,"irf":0.006728754377149944,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":6,"irf":-0.003581064104688209,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":7,"irf":-0.0020224496661551392,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":8,"irf":0.008451348624790465,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":9,"irf":-0.005205928815709961,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":10,"irf":-0.011298789609990671,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":11,"irf":0.0210999904418275,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":12,"irf":0.01496374412587881,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":13,"irf":0.011719505470924936,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":14,"irf":-0.00884475891208739,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":15,"irf":-0.004709243400547782,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":16,"irf":-0.001349080878615831,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":17,"irf":-0.007140532845662659,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":18,"irf":0.010016849470960569,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":19,"irf":-0.00019310394007163094,"ci_lo":0.0,"ci_hi":0.0,"zero":0}];
    const series = [{"name":"IRF","color":"#1f77b4","key":"irf","dash":""}];
    const bands = [{"lo_key":"ci_lo","hi_key":"ci_hi","color":"#1f77b4","alpha":0.15}];
    const refLines = [{"value":0,"color":"#999","dash":"4,3"}];

    const container = d3.select('#irf_38');
    const W = Math.max(container.node().clientWidth - 24, 280);
    const margin = {top:10, right:15, bottom:35, left:55};
    const w = W - margin.left - margin.right;
    const h = Math.min(w * 0.6, 250);

    const svg = container.append('svg').attr('width', W).attr('height', h + margin.top + margin.bottom);
    const g = svg.append('g').attr('transform', 'translate('+margin.left+','+margin.top+')');

    // Compute domains
    const xVals = data.map(d => d.x);
    const allYVals = [];
    series.forEach(s => data.forEach(d => { if(d[s.key]!==null) allYVals.push(d[s.key]); }));
    bands.forEach(b => data.forEach(d => {
        if(d[b.lo_key]!==null) allYVals.push(d[b.lo_key]);
        if(d[b.hi_key]!==null) allYVals.push(d[b.hi_key]);
    }));
    refLines.forEach(r => allYVals.push(r.value));

    const x = d3.scaleLinear().domain(d3.extent(xVals)).range([0,w]);
    const yExt = d3.extent(allYVals);
    const yPad = (yExt[1]-yExt[0])*0.08 || 1;
    const y = d3.scaleLinear().domain([yExt[0]-yPad, yExt[1]+yPad]).range([h,0]);

    // Grid
    g.append('g').attr('class','grid').call(d3.axisLeft(y).tickSize(-w).tickFormat(''));

    // Bands
    bands.forEach(b => {
        const area = d3.area()
            .x(d => x(d.x))
            .y0(d => y(d[b.lo_key]!==null ? d[b.lo_key] : 0))
            .y1(d => y(d[b.hi_key]!==null ? d[b.hi_key] : 0))
            .defined(d => d[b.lo_key]!==null && d[b.hi_key]!==null);
        g.append('path').datum(data).attr('d',area)
            .attr('fill',b.color).attr('opacity',b.alpha||0.15);
    });

    // Reference lines
    refLines.forEach(r => {
        g.append('line').attr('x1',0).attr('x2',w)
            .attr('y1',y(r.value)).attr('y2',y(r.value))
            .attr('stroke',r.color||'#999').attr('stroke-width',1)
            .attr('stroke-dasharray',r.dash||'4,3');
    });

    // Lines
    series.forEach(s => {
        const line = d3.line().x(d=>x(d.x)).y(d=>y(d[s.key]))
            .defined(d=>d[s.key]!==null);
        g.append('path').datum(data).attr('d',line)
            .attr('fill','none').attr('stroke',s.color).attr('stroke-width',1.8)
            .attr('stroke-dasharray',s.dash||'');
    });

    // Axes
    g.append('g').attr('class','axis').attr('transform','translate(0,'+h+')')
        .call(d3.axisBottom(x).ticks(Math.min(xVals.length,8)));
    g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(6));

    if('Horizon') g.append('text').attr('x',w/2).attr('y',h+30).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Horizon');
    if('Response') g.append('text').attr('transform','rotate(-90)')
        .attr('x',-h/2).attr('y',-42).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Response');

    // Legend
    if(series.length > 1) {
        const leg = g.append('g').attr('class','legend').attr('transform','translate(5,-5)');
        series.forEach((s,i) => {
            const gi = leg.append('g').attr('transform','translate('+(i*100)+',0)');
            gi.append('line').attr('x1',0).attr('x2',16).attr('y1',0).attr('y2',0)
                .attr('stroke',s.color).attr('stroke-width',2)
                .attr('stroke-dasharray',s.dash||'');
            gi.append('text').attr('x',20).attr('y',4).attr('font-size','10px')
                .attr('fill','#555').text(s.name);
        });
    }

    // Tooltip overlay
    svg.append('rect').attr('width',W).attr('height',h+margin.top+margin.bottom)
        .attr('fill','none').attr('pointer-events','all')
        .on('mousemove', function(evt) {
            const [mx] = d3.pointer(evt, g.node());
            const x0 = x.invert(mx);
            const idx = d3.minIndex(data, d => Math.abs(d.x - x0));
            const d = data[idx];
            let html = '<b>x='+fmt(d.x)+'</b>';
            series.forEach(s => { if(d[s.key]!==null) html += '<br>'+s.name+': '+fmt(d[s.key]); });
            showTip(evt, html);
        })
        .on('mouseout', hideTip);
})();

(function() {
    const data = [{"x":0,"irf":-0.001310319024577589,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":1,"irf":-0.0005644170275437326,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":2,"irf":-0.0002097573758868692,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":3,"irf":0.00011638079028109428,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":4,"irf":-5.1169505891564646e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":5,"irf":-3.460046299830743e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":6,"irf":0.00010015799081998969,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":7,"irf":-3.956717656753522e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":8,"irf":4.013071400429196e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":9,"irf":0.00011131300843374976,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":10,"irf":0.00019625080904339806,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":11,"irf":-0.00042887627137169396,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":12,"irf":-0.00014149818694892343,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":13,"irf":2.1548098080939818e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":14,"irf":0.000421403896329666,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":15,"irf":-7.92910927263975e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":16,"irf":-5.125023010868959e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":17,"irf":0.00010629787778257113,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":18,"irf":-0.00015028209292739626,"ci_lo":0.0,"ci_hi":0.0,"zero":0},
{"x":19,"irf":3.4874862078378205e-5,"ci_lo":0.0,"ci_hi":0.0,"zero":0}];
    const series = [{"name":"IRF","color":"#1f77b4","key":"irf","dash":""}];
    const bands = [{"lo_key":"ci_lo","hi_key":"ci_hi","color":"#1f77b4","alpha":0.15}];
    const refLines = [{"value":0,"color":"#999","dash":"4,3"}];

    const container = d3.select('#irf_39');
    const W = Math.max(container.node().clientWidth - 24, 280);
    const margin = {top:10, right:15, bottom:35, left:55};
    const w = W - margin.left - margin.right;
    const h = Math.min(w * 0.6, 250);

    const svg = container.append('svg').attr('width', W).attr('height', h + margin.top + margin.bottom);
    const g = svg.append('g').attr('transform', 'translate('+margin.left+','+margin.top+')');

    // Compute domains
    const xVals = data.map(d => d.x);
    const allYVals = [];
    series.forEach(s => data.forEach(d => { if(d[s.key]!==null) allYVals.push(d[s.key]); }));
    bands.forEach(b => data.forEach(d => {
        if(d[b.lo_key]!==null) allYVals.push(d[b.lo_key]);
        if(d[b.hi_key]!==null) allYVals.push(d[b.hi_key]);
    }));
    refLines.forEach(r => allYVals.push(r.value));

    const x = d3.scaleLinear().domain(d3.extent(xVals)).range([0,w]);
    const yExt = d3.extent(allYVals);
    const yPad = (yExt[1]-yExt[0])*0.08 || 1;
    const y = d3.scaleLinear().domain([yExt[0]-yPad, yExt[1]+yPad]).range([h,0]);

    // Grid
    g.append('g').attr('class','grid').call(d3.axisLeft(y).tickSize(-w).tickFormat(''));

    // Bands
    bands.forEach(b => {
        const area = d3.area()
            .x(d => x(d.x))
            .y0(d => y(d[b.lo_key]!==null ? d[b.lo_key] : 0))
            .y1(d => y(d[b.hi_key]!==null ? d[b.hi_key] : 0))
            .defined(d => d[b.lo_key]!==null && d[b.hi_key]!==null);
        g.append('path').datum(data).attr('d',area)
            .attr('fill',b.color).attr('opacity',b.alpha||0.15);
    });

    // Reference lines
    refLines.forEach(r => {
        g.append('line').attr('x1',0).attr('x2',w)
            .attr('y1',y(r.value)).attr('y2',y(r.value))
            .attr('stroke',r.color||'#999').attr('stroke-width',1)
            .attr('stroke-dasharray',r.dash||'4,3');
    });

    // Lines
    series.forEach(s => {
        const line = d3.line().x(d=>x(d.x)).y(d=>y(d[s.key]))
            .defined(d=>d[s.key]!==null);
        g.append('path').datum(data).attr('d',line)
            .attr('fill','none').attr('stroke',s.color).attr('stroke-width',1.8)
            .attr('stroke-dasharray',s.dash||'');
    });

    // Axes
    g.append('g').attr('class','axis').attr('transform','translate(0,'+h+')')
        .call(d3.axisBottom(x).ticks(Math.min(xVals.length,8)));
    g.append('g').attr('class','axis').call(d3.axisLeft(y).ticks(6));

    if('Horizon') g.append('text').attr('x',w/2).attr('y',h+30).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Horizon');
    if('Response') g.append('text').attr('transform','rotate(-90)')
        .attr('x',-h/2).attr('y',-42).attr('text-anchor','middle')
        .attr('font-size','11px').attr('fill','#666').text('Response');

    // Legend
    if(series.length > 1) {
        const leg = g.append('g').attr('class','legend').attr('transform','translate(5,-5)');
        series.forEach((s,i) => {
            const gi = leg.append('g').attr('transform','translate('+(i*100)+',0)');
            gi.append('line').attr('x1',0).attr('x2',16).attr('y1',0).attr('y2',0)
                .attr('stroke',s.color).attr('stroke-width',2)
                .attr('stroke-dasharray',s.dash||'');
            gi.append('text').attr('x',20).attr('y',4).attr('font-size','10px')
                .attr('fill','#555').text(s.name);
        });
    }

    // Tooltip overlay
    svg.append('rect').attr('width',W).attr('height',h+margin.top+margin.bottom)
        .attr('fill','none').attr('pointer-events','all')
        .on('mousemove', function(evt) {
            const [mx] = d3.pointer(evt, g.node());
            const x0 = x.invert(mx);
            const idx = d3.minIndex(data, d => Math.abs(d.x - x0));
            const d = data[idx];
            let html = '<b>x='+fmt(d.x)+'</b>';
            series.forEach(s => { if(d[s.key]!==null) html += '<br>'+s.name+': '+fmt(d[s.key]); });
            showTip(evt, html);
        })
        .on('mouseout', hideTip);
})();

</script>
</body>
</html>